/*!
 * # Semantic UI 2.2.9 - State
 * http://github.com/semantic-org/semantic-ui/
 *
 *
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (e, t, n, a) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.state = function (t) {
        let a,
            i = e(this),
            o = i.selector || "",
            s = (n.documentElement, (new Date()).getTime()),
            c = [],
            r = arguments[0],
            l = typeof r === "string",
            u = [].slice.call(arguments, 1); return i.each(function () {
                let n,
                    d = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.state.settings, t) : e.extend({}, e.fn.state.settings),
                    v = d.error,
                    f = d.metadata,
                    g = d.className,
                    b = d.namespace,
                    x = d.states,
                    h = d.text,
                    m = `.${b}`,
                    p = `${b}-module`,
                    T = e(this),
                    y = this,
                    w = T.data(p); n = { initialize() { n.verbose("Initializing module"), d.automatic && n.add.defaults(), d.context && o !== "" ? e(d.context).on(o, `mouseenter${m}`, n.change.text).on(o, `mouseleave${m}`, n.reset.text).on(o, `click${m}`, n.toggle.state) : T.on(`mouseenter${m}`, n.change.text).on(`mouseleave${m}`, n.reset.text).on(`click${m}`, n.toggle.state), n.instantiate(); },
                        instantiate() { n.verbose("Storing instance of module", n), w = n, T.data(p, n); },
                        destroy() { n.verbose("Destroying previous module", w), T.off(m).removeData(p); },
                        refresh() { n.verbose("Refreshing selector cache"), T = e(y); },
                        add: { defaults() { const a = t && e.isPlainObject(t.states) ? t.states : {}; e.each(d.defaults, (t, i) => { void 0 !== n.is[t] && n.is[t]() && (n.verbose("Adding default states", t, y), e.extend(d.states, i, a)); }); } },
                        is: { active() { return T.hasClass(g.active); }, loading() { return T.hasClass(g.loading); }, inactive() { return !T.hasClass(g.active); }, state(e) { return void 0 !== g[e] && T.hasClass(g[e]); }, enabled() { return !T.is(d.filter.active); }, disabled() { return T.is(d.filter.active); }, textEnabled() { return !T.is(d.filter.text); }, button() { return T.is(".button:not(a, .submit)"); }, input() { return T.is("input"); }, progress() { return T.is(".ui.progress"); } },
                        allow(e) { n.debug("Now allowing state", e), x[e] = !0; },
                        disallow(e) { n.debug("No longer allowing", e), x[e] = !1; },
                        allows(e) { return x[e] || !1; },
                        enable() { T.removeClass(g.disabled); },
                        disable() { T.addClass(g.disabled); },
                        setState(e) { n.allows(e) && T.addClass(g[e]); },
                        removeState(e) { n.allows(e) && T.removeClass(g[e]); },
                        toggle: { state() { let t; if (n.allows("active") && n.is.enabled()) { if (n.refresh(), void 0 !== e.fn.api) if (t = T.api("get request"), T.api("was cancelled"))n.debug("API Request cancelled by beforesend"), d.activateTest = function () { return !1; }, d.deactivateTest = function () { return !1; }; else if (t) return void n.listenTo(t); n.change.state(); } } },
                        listenTo(t) { n.debug("API request detected, waiting for state signal", t), t && (h.loading && n.update.text(h.loading), e.when(t).then(() => { t.state() == "resolved" ? (n.debug("API request succeeded"), d.activateTest = function () { return !0; }, d.deactivateTest = function () { return !0; }) : (n.debug("API request failed"), d.activateTest = function () { return !1; }, d.deactivateTest = function () { return !1; }), n.change.state(); })); },
                        change: { state() { n.debug("Determining state change direction"), n.is.inactive() ? n.activate() : n.deactivate(), d.sync && n.sync(), d.onChange.call(y); }, text() { n.is.textEnabled() && (n.is.disabled() ? (n.verbose("Changing text to disabled text", h.hover), n.update.text(h.disabled)) : n.is.active() ? h.hover ? (n.verbose("Changing text to hover text", h.hover), n.update.text(h.hover)) : h.deactivate && (n.verbose("Changing text to deactivating text", h.deactivate), n.update.text(h.deactivate)) : h.hover ? (n.verbose("Changing text to hover text", h.hover), n.update.text(h.hover)) : h.activate && (n.verbose("Changing text to activating text", h.activate), n.update.text(h.activate))); } },
                        activate() { d.activateTest.call(y) && (n.debug("Setting state to active"), T.addClass(g.active), n.update.text(h.active), d.onActivate.call(y)); },
                        deactivate() { d.deactivateTest.call(y) && (n.debug("Setting state to inactive"), T.removeClass(g.active), n.update.text(h.inactive), d.onDeactivate.call(y)); },
                        sync() { n.verbose("Syncing other buttons to current state"), n.is.active() ? i.not(T).state("activate") : i.not(T).state("deactivate"); },
                        get: { text() { return d.selector.text ? T.find(d.selector.text).text() : T.html(); }, textFor(e) { return h[e] || !1; } },
                        flash: { text(e, t, a) { const i = n.get.text(); n.debug("Flashing text message", e, t), e = e || d.text.flash, t = t || d.flashDuration, a = a || function () {}, n.update.text(e), setTimeout(() => { n.update.text(i), a.call(y); }, t); } },
                        reset: { text() {
                            let e = h.active || T.data(f.storedText),
                                t = h.inactive || T.data(f.storedText); n.is.textEnabled() && (n.is.active() && e ? (n.verbose("Resetting active text", e), n.update.text(e)) : t && (n.verbose("Resetting inactive text", e), n.update.text(t)));
                        } },
                        update: { text(e) { const t = n.get.text(); e && e !== t ? (n.debug("Updating text", e), d.selector.text ? T.data(f.storedText, e).find(d.selector.text).text(e) : T.data(f.storedText, e).html(e)) : n.debug("Text is already set, ignoring update", e); } },
                        setting(t, a) { if (n.debug("Changing setting", t, a), e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === a) return d[t]; e.isPlainObject(d[t]) ? e.extend(!0, d[t], a) : d[t] = a; } },
                        internal(t, a) { if (e.isPlainObject(t))e.extend(!0, n, t); else { if (void 0 === a) return n[t]; n[t] = a; } },
                        debug() { !d.silent && d.debug && (d.performance ? n.performance.log(arguments) : (n.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), n.debug.apply(console, arguments))); },
                        verbose() { !d.silent && d.verbose && d.debug && (d.performance ? n.performance.log(arguments) : (n.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), n.verbose.apply(console, arguments))); },
                        error() { d.silent || (n.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), n.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                a,
                                i; d.performance && (t = (new Date()).getTime(), i = s || t, a = t - i, s = t, c.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: y, "Execution Time": a })), clearTimeout(n.performance.timer), n.performance.timer = setTimeout(n.performance.display, 500);
                        },
                            display() {
                                let t = `${d.name}:`,
                                    a = 0; s = !1, clearTimeout(n.performance.timer), e.each(c, (e, t) => { a += t["Execution Time"]; }), t += ` ${a}ms`, o && (t += ` '${o}'`), (void 0 !== console.group || void 0 !== console.table) && c.length > 0 && (console.groupCollapsed(t), console.table ? console.table(c) : e.each(c, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), c = [];
                            } },
                        invoke(t, i, o) {
                            let s,
                                c,
                                r,
                                l = w; return i = i || u, o = y || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), s = t.length - 1, e.each(t, (a, i) => { const o = a != s ? i + t[a + 1].charAt(0).toUpperCase() + t[a + 1].slice(1) : t; if (e.isPlainObject(l[o]) && a != s)l = l[o]; else { if (void 0 !== l[o]) return c = l[o], !1; if (!e.isPlainObject(l[i]) || a == s) return void 0 !== l[i] ? (c = l[i], !1) : (n.error(v.method, t), !1); l = l[i]; } })), e.isFunction(c) ? r = c.apply(o, i) : void 0 !== c && (r = c), e.isArray(a) ? a.push(r) : void 0 !== a ? a = [a, r] : void 0 !== r && (a = r), c;
                        } }, l ? (void 0 === w && n.initialize(), n.invoke(r)) : (void 0 !== w && w.invoke("destroy"), n.initialize());
            }), void 0 !== a ? a : this;
    }, e.fn.state.settings = { name: "State", debug: !1, verbose: !1, namespace: "state", performance: !0, onActivate() {}, onDeactivate() {}, onChange() {}, activateTest() { return !0; }, deactivateTest() { return !0; }, automatic: !0, sync: !1, flashDuration: 1e3, filter: { text: ".loading, .disabled", active: ".disabled" }, context: !1, error: { beforeSend: "The before send function has cancelled state change", method: "The method you called is not defined." }, metadata: { promise: "promise", storedText: "stored-text" }, className: { active: "active", disabled: "disabled", error: "error", loading: "loading", success: "success", warning: "warning" }, selector: { text: !1 }, defaults: { input: { disabled: !0, loading: !0, active: !0 }, button: { disabled: !0, loading: !0, active: !0 }, progress: { active: !0, success: !0, warning: !0, error: !0 } }, states: { active: !0, disabled: !0, error: !0, loading: !0, success: !0, warning: !0 }, text: { disabled: !1, flash: !1, hover: !1, active: !1, inactive: !1, activate: !1, deactivate: !1 } };
}(jQuery, window, document));
