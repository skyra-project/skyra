 /*
 * # Semantic UI - 2.2.9
 * https://github.com/Semantic-Org/Semantic-UI
 * http://www.semantic-ui.com/
 *
 * Copyright 2014 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (e, t, n, i) {
    e.site = e.fn.site = function (i) {
        let o,
            a,
            r = (new Date()).getTime(),
            s = [],
            l = arguments[0],
            c = typeof l === "string",
            u = [].slice.call(arguments, 1),
            d = e.isPlainObject(i) ? e.extend(!0, {}, e.site.settings, i) : e.extend({}, e.site.settings),
            f = d.namespace,
            m = d.error,
            g = `module-${f}`,
            v = e(n),
            p = v,
            h = this,
            b = p.data(g); return o = { initialize() { o.instantiate(); },
                instantiate() { o.verbose("Storing instance of site", o), b = o, p.data(g, o); },
                normalize() { o.fix.console(), o.fix.requestAnimationFrame(); },
                fix: { console() { o.debug("Normalizing window.console"), void 0 !== console && void 0 !== console.log || (o.verbose("Console not available, normalizing events"), o.disable.console()), void 0 !== console.group && void 0 !== console.groupEnd && void 0 !== console.groupCollapsed || (o.verbose("Console group not available, normalizing events"), t.console.group = function () {}, t.console.groupEnd = function () {}, t.console.groupCollapsed = function () {}), void 0 === console.markTimeline && (o.verbose("Mark timeline not available, normalizing events"), t.console.markTimeline = function () {}); }, consoleClear() { o.debug("Disabling programmatic console clearing"), t.console.clear = function () {}; }, requestAnimationFrame() { o.debug("Normalizing requestAnimationFrame"), void 0 === t.requestAnimationFrame && (o.debug("RequestAnimationFrame not available, normalizing event"), t.requestAnimationFrame = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }); } },
                moduleExists(t) { return void 0 !== e.fn[t] && void 0 !== e.fn[t].settings; },
                enabled: { modules(t) { const n = []; return t = t || d.modules, e.each(t, (e, t) => { o.moduleExists(t) && n.push(t); }), n; } },
                disabled: { modules(t) { const n = []; return t = t || d.modules, e.each(t, (e, t) => { o.moduleExists(t) || n.push(t); }), n; } },
                change: { setting(t, n, i, a) {
                    i = typeof i === "string" ? i === "all" ? d.modules : [i] : i || d.modules, a = void 0 === a || a, e.each(i, (i, r) => {
                        let s,
                            l = !o.moduleExists(r) || (e.fn[r].settings.namespace || !1); o.moduleExists(r) && (o.verbose("Changing default setting", t, n, r), e.fn[r].settings[t] = n, a && l && (s = e(`:data(module-${l})`), s.length > 0 && (o.verbose("Modifying existing settings", s), s[r]("setting", t, n))));
                    });
                },
                    settings(t, n, i) { n = typeof n === "string" ? [n] : n || d.modules, i = void 0 === i || i, e.each(n, (n, a) => { let r; o.moduleExists(a) && (o.verbose("Changing default setting", t, a), e.extend(!0, e.fn[a].settings, t), i && f && (r = e(`:data(module-${f})`), r.length > 0 && (o.verbose("Modifying existing settings", r), r[a]("setting", t)))); }); } },
                enable: { console() { o.console(!0); }, debug(e, t) { e = e || d.modules, o.debug("Enabling debug for modules", e), o.change.setting("debug", !0, e, t); }, verbose(e, t) { e = e || d.modules, o.debug("Enabling verbose debug for modules", e), o.change.setting("verbose", !0, e, t); } },
                disable: { console() { o.console(!1); }, debug(e, t) { e = e || d.modules, o.debug("Disabling debug for modules", e), o.change.setting("debug", !1, e, t); }, verbose(e, t) { e = e || d.modules, o.debug("Disabling verbose debug for modules", e), o.change.setting("verbose", !1, e, t); } },
                console(e) { if (e) { if (void 0 === b.cache.console) return void o.error(m.console); o.debug("Restoring console function"), t.console = b.cache.console; } else o.debug("Disabling console function"), b.cache.console = t.console, t.console = { clear() {}, error() {}, group() {}, groupCollapsed() {}, groupEnd() {}, info() {}, log() {}, markTimeline() {}, warn() {} }; },
                destroy() { o.verbose("Destroying previous site for", p), p.removeData(g); },
                cache: {},
                setting(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; d[t] = n; } },
                internal(t, n) { if (e.isPlainObject(t))e.extend(!0, o, t); else { if (void 0 === n) return o[t]; o[t] = n; } },
                debug() { d.debug && (d.performance ? o.performance.log(arguments) : (o.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), o.debug.apply(console, arguments))); },
                verbose() { d.verbose && d.debug && (d.performance ? o.performance.log(arguments) : (o.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), o.verbose.apply(console, arguments))); },
                error() { o.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), o.error.apply(console, arguments); },
                performance: { log(e) {
                    let t,
                        n,
                        i; d.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Element: h, Name: e[0], Arguments: [].slice.call(e, 1) || "", "Execution Time": n })), clearTimeout(o.performance.timer), o.performance.timer = setTimeout(o.performance.display, 500);
                },
                    display() {
                        let t = `${d.name}:`,
                            n = 0; r = !1, clearTimeout(o.performance.timer), e.each(s, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                    } },
                invoke(t, n, i) {
                    let r,
                        s,
                        l,
                        c = b; return n = n || u, i = h || i, typeof t === "string" && void 0 !== c && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, i) => { const a = n != r ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(c[a]) && n != r)c = c[a]; else { if (void 0 !== c[a]) return s = c[a], !1; if (!e.isPlainObject(c[i]) || n == r) return void 0 !== c[i] ? (s = c[i], !1) : (o.error(m.method, t), !1); c = c[i]; } })), e.isFunction(s) ? l = s.apply(i, n) : void 0 !== s && (l = s), e.isArray(a) ? a.push(l) : void 0 !== a ? a = [a, l] : void 0 !== l && (a = l), s;
                } }, c ? (void 0 === b && o.initialize(), o.invoke(l)) : (void 0 !== b && o.destroy(), o.initialize()), void 0 !== a ? a : this;
    }, e.site.settings = { name: "Site", namespace: "site", error: { console: "Console cannot be restored, most likely it was overwritten outside of module", method: "The method you called is not defined." }, debug: !1, verbose: !1, performance: !0, modules: ["accordion", "api", "checkbox", "dimmer", "dropdown", "embed", "form", "modal", "nag", "popup", "rating", "shape", "sidebar", "state", "sticky", "tab", "transition", "visit", "visibility"], siteNamespace: "site", namespaceStub: { cache: {}, config: {}, sections: {}, section: {}, utilities: {} } }, e.extend(e.expr[":"], { data: e.expr.createPseudo ? e.expr.createPseudo(t => function (n) { return !!e.data(n, t); }) : function (t, n, i) { return !!e.data(t, i[3]); } });
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.form = function (t) {
        let i,
            o = e(this),
            a = o.selector || "",
            r = (new Date()).getTime(),
            s = [],
            l = arguments[0],
            c = arguments[1],
            u = typeof l === "string",
            d = [].slice.call(arguments, 1); return o.each(function () {
                let f,
                    m,
                    g,
                    v,
                    p,
                    h,
                    b,
                    y,
                    x,
                    C,
                    w,
                    k,
                    S,
                    T,
                    A,
                    R,
                    P,
                    E,
                    F,
                    O = e(this),
                    D = this,
                    q = [],
                    j = !1; F = { initialize() { F.get.settings(), u ? (void 0 === E && F.instantiate(), F.invoke(l)) : (void 0 !== E && E.invoke("destroy"), F.verbose("Initializing form validation", O, y), F.bindEvents(), F.set.defaults(), F.instantiate()); },
                        instantiate() { F.verbose("Storing instance of module", F), E = F, O.data(R, F); },
                        destroy() { F.verbose("Destroying previous module", E), F.removeEvents(), O.removeData(R); },
                        refresh() { F.verbose("Refreshing selector cache"), f = O.find(w.field), m = O.find(w.group), g = O.find(w.message), v = O.find(w.prompt), p = O.find(w.submit), h = O.find(w.clear), b = O.find(w.reset); },
                        submit() { F.verbose("Submitting form", O), O.submit(); },
                        attachEvents(t, n) { n = n || "submit", e(t).on(`click${P}`, (e) => { F[n](), e.preventDefault(); }); },
                        bindEvents() {
                            F.verbose("Attaching form events"), O.on(`submit${P}`, F.validate.form).on(`blur${P}`, w.field, F.event.field.blur).on(`click${P}`, w.submit, F.submit).on(`click${P}`, w.reset, F.reset).on(`click${P}`, w.clear, F.clear), y.keyboardShortcuts && O.on(`keydown${P}`, w.field, F.event.field.keydown), f.each(function () {
                                let t = e(this),
                                    n = t.prop("type"),
                                    i = F.get.changeEvent(n, t); e(this).on(i + P, F.event.field.change);
                            });
                        },
                        clear() {
                            f.each(function () {
                                let t = e(this),
                                    n = t.parent(),
                                    i = t.closest(m),
                                    o = i.find(w.prompt),
                                    a = t.data(C.defaultValue) || "",
                                    r = n.is(w.uiCheckbox),
                                    s = n.is(w.uiDropdown); i.hasClass(k.error) && (F.verbose("Resetting error on field", i), i.removeClass(k.error), o.remove()), s ? (F.verbose("Resetting dropdown value", n, a), n.dropdown("clear")) : r ? t.prop("checked", !1) : (F.verbose("Resetting field value", t, a), t.val(""));
                            });
                        },
                        reset() {
                            f.each(function () {
                                let t = e(this),
                                    n = t.parent(),
                                    i = t.closest(m),
                                    o = i.find(w.prompt),
                                    a = t.data(C.defaultValue),
                                    r = n.is(w.uiCheckbox),
                                    s = n.is(w.uiDropdown),
                                    l = i.hasClass(k.error); void 0 !== a && (l && (F.verbose("Resetting error on field", i), i.removeClass(k.error), o.remove()), s ? (F.verbose("Resetting dropdown value", n, a), n.dropdown("restore defaults")) : r ? (F.verbose("Resetting checkbox value", n, a), t.prop("checked", a)) : (F.verbose("Resetting field value", t, a), t.val(a)));
                            });
                        },
                        determine: { isValid() { let t = !0; return e.each(x, (e, n) => { F.validate.field(n, e, !0) || (t = !1); }), t; } },
                        is: { bracketedRule(e) { return e.type && e.type.match(y.regExp.bracket); }, empty(e) { return !e || e.length === 0 || (e.is("input[type=\"checkbox\"]") ? !e.is(":checked") : F.is.blank(e)); }, blank(t) { return e.trim(t.val()) === ""; }, valid(t) { let n = !0; return t ? (F.verbose("Checking if field is valid", t), F.validate.field(x[t], t, !1)) : (F.verbose("Checking if form is valid"), e.each(x, (e, t) => { F.is.valid(e) || (n = !1); }), n); } },
                        removeEvents() { O.off(P), f.off(P), p.off(P), f.off(P); },
                        event: { field: { keydown(t) {
                            let n = e(this),
                                i = t.which,
                                o = n.is(w.input),
                                a = n.is(w.checkbox),
                                r = n.closest(w.uiDropdown).length > 0,
                                s = { enter: 13, escape: 27 }; i == s.escape && (F.verbose("Escape key pressed blurring field"), n.blur()), t.ctrlKey || i != s.enter || !o || r || a || (j || (n.one(`keyup${P}`, F.event.field.keyup), F.submit(), F.debug("Enter pressed on input submitting form")), j = !0);
                        },
                            keyup() { j = !1; },
                            blur(t) {
                                let n = e(this),
                                    i = n.closest(m),
                                    o = F.get.validation(n); i.hasClass(k.error) ? (F.debug("Revalidating field", n, o), o && F.validate.field(o)) : y.on != "blur" && y.on != "change" || o && F.validate.field(o);
                            },
                            change(t) {
                                let n = e(this),
                                    i = n.closest(m),
                                    o = F.get.validation(n); o && (y.on == "change" || i.hasClass(k.error) && y.revalidate) && (clearTimeout(F.timer), F.timer = setTimeout(() => { F.debug("Revalidating field", n, F.get.validation(n)), F.validate.field(o); }, y.delay));
                            } } },
                        get: { ancillaryValue(e) { return !(!e.type || !e.value && !F.is.bracketedRule(e)) && (void 0 !== e.value ? e.value : `${e.type.match(y.regExp.bracket)[1]}`); },
                            ruleName(e) { return F.is.bracketedRule(e) ? e.type.replace(e.type.match(y.regExp.bracket)[0], "") : e.type; },
                            changeEvent(e, t) { return e == "checkbox" || e == "radio" || e == "hidden" || t.is("select") ? "change" : F.get.inputEvent(); },
                            inputEvent() { return void 0 !== n.createElement("input").oninput ? "input" : void 0 !== n.createElement("input").onpropertychange ? "propertychange" : "keyup"; },
                            prompt(e, t) {
                                let n,
                                    i,
                                    o,
                                    a = F.get.ruleName(e),
                                    r = F.get.ancillaryValue(e),
                                    s = e.prompt || y.prompt[a] || y.text.unspecifiedRule,
                                    l = s.search("{value}") !== -1,
                                    c = s.search("{name}") !== -1; return (c || l) && (i = F.get.field(t.identifier)), l && (s = s.replace("{value}", i.val())), c && (n = i.closest(w.group).find("label").eq(0), o = n.length == 1 ? n.text() : i.prop("placeholder") || y.text.unspecifiedField, s = s.replace("{name}", o)), s = s.replace("{identifier}", t.identifier), s = s.replace("{ruleValue}", r), e.prompt || F.verbose("Using default validation prompt for type", s, a), s;
                            },
                            settings() {
                                if (e.isPlainObject(t)) {
                                    let n,
                                        i = Object.keys(t),
                                        o = i.length > 0 && (void 0 !== t[i[0]].identifier && void 0 !== t[i[0]].rules); o ? (y = e.extend(!0, {}, e.fn.form.settings, c), x = e.extend({}, e.fn.form.settings.defaults, t), F.error(y.error.oldSyntax, D), F.verbose("Extending settings from legacy parameters", x, y)) : (t.fields && (n = Object.keys(t.fields), (typeof t.fields[n[0]] === "string" || e.isArray(t.fields[n[0]])) && e.each(t.fields, (n, i) => { typeof i === "string" && (i = [i]), t.fields[n] = { rules: [] }, e.each(i, (e, i) => { t.fields[n].rules.push({ type: i }); }); })), y = e.extend(!0, {}, e.fn.form.settings, t), x = e.extend({}, e.fn.form.settings.defaults, y.fields), F.verbose("Extending settings", x, y));
                                } else y = e.fn.form.settings, x = e.fn.form.settings.defaults, F.verbose("Using default form validation", x, y); A = y.namespace, C = y.metadata, w = y.selector, k = y.className, S = y.regExp, T = y.error, R = `module-${A}`, P = `.${A}`, E = O.data(R), F.refresh();
                            },
                            field(t) { return F.verbose("Finding field with identifier", t), t = F.escape.string(t), f.filter(`#${t}`).length > 0 ? f.filter(`#${t}`) : f.filter(`[name="${t}"]`).length > 0 ? f.filter(`[name="${t}"]`) : f.filter(`[name="${t}[]"]`).length > 0 ? f.filter(`[name="${t}[]"]`) : f.filter(`[data-${C.validate}="${t}"]`).length > 0 ? f.filter(`[data-${C.validate}="${t}"]`) : e("<input/>"); },
                            fields(t) { let n = e(); return e.each(t, (e, t) => { n = n.add(F.get.field(t)); }), n; },
                            validation(t) {
                                let n,
                                    i; return !!x && (e.each(x, (e, o) => { i = o.identifier || e, F.get.field(i)[0] == t[0] && (o.identifier = i, n = o); }), n || !1);
                            },
                            value(e) {
                                let t,
                                    n = []; return n.push(e), t = F.get.values.call(D, n), t[e];
                            },
                            values(t) {
                                let n = e.isArray(t) ? F.get.fields(t) : f,
                                    i = {}; return n.each((t, n) => {
                                        let o = e(n),
                                            a = (o.prop("type"), o.prop("name")),
                                            r = o.val(),
                                            s = o.is(w.checkbox),
                                            l = o.is(w.radio),
                                            c = a.indexOf("[]") !== -1,
                                            u = !!s && o.is(":checked"); a && (c ? (a = a.replace("[]", ""), i[a] || (i[a] = []), s ? u ? i[a].push(r || !0) : i[a].push(!1) : i[a].push(r)) : l ? u && (i[a] = r) : i[a] = s ? !!u && (r || !0) : r);
                                    }), i;
                            } },
                        has: { field(e) { return F.verbose("Checking for existence of a field with identifier", e), e = F.escape.string(e), typeof e !== "string" && F.error(T.identifier, e), f.filter(`#${e}`).length > 0 || (f.filter(`[name="${e}"]`).length > 0 || f.filter(`[data-${C.validate}="${e}"]`).length > 0); } },
                        escape: { string(e) { return e = String(e), e.replace(S.escape, "\\$&"); } },
                        add: { prompt(t, n) {
                            let i = F.get.field(t),
                                o = i.closest(m),
                                a = o.children(w.prompt),
                                r = a.length !== 0; n = typeof n === "string" ? [n] : n, F.verbose("Adding field error state", t), o.addClass(k.error), y.inline && (r || (a = y.templates.prompt(n), a.appendTo(o)), a.html(n[0]), r ? F.verbose("Inline errors are disabled, no inline error added", t) : y.transition && void 0 !== e.fn.transition && O.transition("is supported") ? (F.verbose("Displaying error with css transition", y.transition), a.transition(`${y.transition} in`, y.duration)) : (F.verbose("Displaying error with fallback javascript animation"), a.fadeIn(y.duration)));
                        },
                            errors(e) { F.debug("Adding form error messages", e), F.set.error(), g.html(y.templates.error(e)); } },
                        remove: { prompt(t) {
                            let n = F.get.field(t),
                                i = n.closest(m),
                                o = i.children(w.prompt); i.removeClass(k.error), y.inline && o.is(":visible") && (F.verbose("Removing prompt for field", t), y.transition && void 0 !== e.fn.transition && O.transition("is supported") ? o.transition(`${y.transition} out`, y.duration, () => { o.remove(); }) : o.fadeOut(y.duration, () => { o.remove(); }));
                        } },
                        set: { success() { O.removeClass(k.error).addClass(k.success); },
                            defaults() {
                                f.each(function () {
                                    let t = e(this),
                                        n = t.filter(w.checkbox).length > 0,
                                        i = n ? t.is(":checked") : t.val(); t.data(C.defaultValue, i);
                                });
                            },
                            error() { O.removeClass(k.success).addClass(k.error); },
                            value(e, t) { const n = {}; return n[e] = t, F.set.values.call(D, n); },
                            values(t) {
                                e.isEmptyObject(t) || e.each(t, (t, n) => {
                                    let i,
                                        o = F.get.field(t),
                                        a = o.parent(),
                                        r = e.isArray(n),
                                        s = a.is(w.uiCheckbox),
                                        l = a.is(w.uiDropdown),
                                        c = o.is(w.radio) && s,
                                        u = o.length > 0; u && (r && s ? (F.verbose("Selecting multiple", n, o), a.checkbox("uncheck"), e.each(n, (e, t) => { i = o.filter(`[value="${t}"]`), a = i.parent(), i.length > 0 && a.checkbox("check"); })) : c ? (F.verbose("Selecting radio value", n, o), o.filter(`[value="${n}"]`).parent(w.uiCheckbox).checkbox("check")) : s ? (F.verbose("Setting checkbox value", n, a), n === !0 ? a.checkbox("check") : a.checkbox("uncheck")) : l ? (F.verbose("Setting dropdown value", n, a), a.dropdown("set selected", n)) : (F.verbose("Setting field value", n, o), o.val(n)));
                                });
                            } },
                        validate: { form(e, t) { const n = F.get.values(); if (j) return !1; if (q = [], F.determine.isValid()) { if (F.debug("Form has no validation errors, submitting"), F.set.success(), t !== !0) return y.onSuccess.call(D, e, n); } else if (F.debug("Form has errors"), F.set.error(), y.inline || F.add.errors(q), void 0 !== O.data("moduleApi") && e.stopImmediatePropagation(), t !== !0) return y.onFailure.call(D, q, n); },
                            field(t, n, i) {
                                i = void 0 === i || i, typeof t === "string" && (F.verbose("Validating field", t), n = t, t = x[t]); let o = t.identifier || n,
                                    a = F.get.field(o),
                                    r = !!t.depends && F.get.field(t.depends),
                                    s = !0,
                                    l = []; return t.identifier || (F.debug("Using field name as identifier", o), t.identifier = o), a.prop("disabled") ? (F.debug("Field is disabled. Skipping", o), s = !0) : t.optional && F.is.blank(a) ? (F.debug("Field is optional and blank. Skipping", o), s = !0) : t.depends && F.is.empty(r) ? (F.debug("Field depends on another value that is not present or empty. Skipping", r), s = !0) : void 0 !== t.rules && e.each(t.rules, (e, n) => { F.has.field(o) && !F.validate.rule(t, n) && (F.debug("Field is invalid", o, n.type), l.push(F.get.prompt(n, t)), s = !1); }), s ? (i && (F.remove.prompt(o, l), y.onValid.call(a)), !0) : (i && (q = q.concat(l), F.add.prompt(o, l), y.onInvalid.call(a, l)), !1);
                            },
                            rule(t, n) {
                                let i = F.get.field(t.identifier),
                                    o = (n.type, i.val()),
                                    a = F.get.ancillaryValue(n),
                                    r = F.get.ruleName(n),
                                    s = y.rules[r]; return e.isFunction(s) ? (o = void 0 === o || o === "" || o === null ? "" : e.trim(`${o}`), s.call(i, o, a)) : void F.error(T.noRule, r);
                            } },
                        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, y, t); else { if (void 0 === n) return y[t]; y[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, F, t); else { if (void 0 === n) return F[t]; F[t] = n; } },
                        debug() { !y.silent && y.debug && (y.performance ? F.performance.log(arguments) : (F.debug = Function.prototype.bind.call(console.info, console, `${y.name}:`), F.debug.apply(console, arguments))); },
                        verbose() { !y.silent && y.verbose && y.debug && (y.performance ? F.performance.log(arguments) : (F.verbose = Function.prototype.bind.call(console.info, console, `${y.name}:`), F.verbose.apply(console, arguments))); },
                        error() { y.silent || (F.error = Function.prototype.bind.call(console.error, console, `${y.name}:`), F.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; y.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: D, "Execution Time": n })), clearTimeout(F.performance.timer), F.performance.timer = setTimeout(F.performance.display, 500);
                        },
                            display() {
                                let t = `${y.name}:`,
                                    n = 0; r = !1, clearTimeout(F.performance.timer), e.each(s, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, a && (t += ` '${a}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, n, o) {
                            let a,
                                r,
                                s,
                                l = E; return n = n || d, o = D || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r;
                        } }, F.initialize();
            }), void 0 !== i ? i : this;
    }, e.fn.form.settings = { name: "Form",
        namespace: "form",
        debug: !1,
        verbose: !1,
        performance: !0,
        fields: !1,
        keyboardShortcuts: !0,
        on: "submit",
        inline: !1,
        delay: 200,
        revalidate: !0,
        transition: "scale",
        duration: 200,
        onValid() {},
        onInvalid() {},
        onSuccess() { return !0; },
        onFailure() { return !1; },
        metadata: { defaultValue: "default", validate: "validate" },
        regExp: { htmlID: /^[a-zA-Z][\w:.-]*$/g, bracket: /\[(.*)\]/i, decimal: /^\d+\.?\d*$/, email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, flags: /^\/(.*)\/(.*)?/, integer: /^\-?\d+$/, number: /^\-?\d*(\.\d+)?$/, url: /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i },
        text: { unspecifiedRule: "Please enter a valid value", unspecifiedField: "This field" },
        prompt: { empty: "{name} must have a value", checked: "{name} must be checked", email: "{name} must be a valid e-mail", url: "{name} must be a valid url", regExp: "{name} is not formatted correctly", integer: "{name} must be an integer", decimal: "{name} must be a decimal number", number: "{name} must be set to a number", is: "{name} must be \"{ruleValue}\"", isExactly: "{name} must be exactly \"{ruleValue}\"", not: "{name} cannot be set to \"{ruleValue}\"", notExactly: "{name} cannot be set to exactly \"{ruleValue}\"", contain: "{name} cannot contain \"{ruleValue}\"", containExactly: "{name} cannot contain exactly \"{ruleValue}\"", doesntContain: "{name} must contain  \"{ruleValue}\"", doesntContainExactly: "{name} must contain exactly \"{ruleValue}\"", minLength: "{name} must be at least {ruleValue} characters", length: "{name} must be at least {ruleValue} characters", exactLength: "{name} must be exactly {ruleValue} characters", maxLength: "{name} cannot be longer than {ruleValue} characters", match: "{name} must match {ruleValue} field", different: "{name} must have a different value than {ruleValue} field", creditCard: "{name} must be a valid credit card number", minCount: "{name} must have at least {ruleValue} choices", exactCount: "{name} must have exactly {ruleValue} choices", maxCount: "{name} must have {ruleValue} or less choices" },
        selector: { checkbox: "input[type=\"checkbox\"], input[type=\"radio\"]", clear: ".clear", field: "input, textarea, select", group: ".field", input: "input", message: ".error.message", prompt: ".prompt.label", radio: "input[type=\"radio\"]", reset: ".reset:not([type=\"reset\"])", submit: ".submit:not([type=\"submit\"])", uiCheckbox: ".ui.checkbox", uiDropdown: ".ui.dropdown" },
        className: { error: "error", label: "ui prompt label", pressed: "down", success: "success" },
        error: { identifier: "You must specify a string identifier for each field", method: "The method you called is not defined.", noRule: "There is no rule matching the one you specified", oldSyntax: "Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically." },
        templates: { error(t) { let n = "<ul class=\"list\">"; return e.each(t, (e, t) => { n += `<li>${t}</li>`; }), n += "</ul>", e(n); }, prompt(t) { return e("<div/>").addClass("ui basic red pointing prompt label").html(t[0]); } },
        rules: { empty(t) { return !(void 0 === t || t === "" || e.isArray(t) && t.length === 0); },
            checked() { return e(this).filter(":checked").length > 0; },
            email(t) { return e.fn.form.settings.regExp.email.test(t); },
            url(t) { return e.fn.form.settings.regExp.url.test(t); },
            regExp(t, n) {
                if (n instanceof RegExp) return t.match(n); let i,
                    o = n.match(e.fn.form.settings.regExp.flags); return o && (n = o.length >= 2 ? o[1] : n, i = o.length >= 3 ? o[2] : ""), t.match(new RegExp(n, i));
            },
            integer(t, n) {
                let i,
                    o,
                    a,
                    r = e.fn.form.settings.regExp.integer; return n && ["", ".."].indexOf(n) === -1 && (n.indexOf("..") == -1 ? r.test(n) && (i = o = n - 0) : (a = n.split("..", 2), r.test(a[0]) && (i = a[0] - 0), r.test(a[1]) && (o = a[1] - 0))), r.test(t) && (void 0 === i || t >= i) && (void 0 === o || t <= o);
            },
            decimal(t) { return e.fn.form.settings.regExp.decimal.test(t); },
            number(t) { return e.fn.form.settings.regExp.number.test(t); },
            is(e, t) { return t = typeof t === "string" ? t.toLowerCase() : t, (e = typeof e === "string" ? e.toLowerCase() : e) == t; },
            isExactly(e, t) { return e == t; },
            not(e, t) { return e = typeof e === "string" ? e.toLowerCase() : e, t = typeof t === "string" ? t.toLowerCase() : t, e != t; },
            notExactly(e, t) { return e != t; },
            contains(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, "\\$&"), t.search(new RegExp(n, "i")) !== -1; },
            containsExactly(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, "\\$&"), t.search(new RegExp(n)) !== -1; },
            doesntContain(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, "\\$&"), t.search(new RegExp(n, "i")) === -1; },
            doesntContainExactly(t, n) { return n = n.replace(e.fn.form.settings.regExp.escape, "\\$&"), t.search(new RegExp(n)) === -1; },
            minLength(e, t) { return void 0 !== e && e.length >= t; },
            length(e, t) { return void 0 !== e && e.length >= t; },
            exactLength(e, t) { return void 0 !== e && e.length == t; },
            maxLength(e, t) { return void 0 !== e && e.length <= t; },
            match(t, n) { let i; e(this); return e(`[data-validate="${n}"]`).length > 0 ? i = e(`[data-validate="${n}"]`).val() : e(`#${n}`).length > 0 ? i = e(`#${n}`).val() : e(`[name="${n}"]`).length > 0 ? i = e(`[name="${n}"]`).val() : e(`[name="${n}[]"]`).length > 0 && (i = e(`[name="${n}[]"]`)), void 0 !== i && t.toString() == i.toString(); },
            different(t, n) { let i; e(this); return e(`[data-validate="${n}"]`).length > 0 ? i = e(`[data-validate="${n}"]`).val() : e(`#${n}`).length > 0 ? i = e(`#${n}`).val() : e(`[name="${n}"]`).length > 0 ? i = e(`[name="${n}"]`).val() : e(`[name="${n}[]"]`).length > 0 && (i = e(`[name="${n}[]"]`)), void 0 !== i && t.toString() !== i.toString(); },
            creditCard(t, n) {
                let i,
                    o,
                    a = { visa: { pattern: /^4/, length: [16] }, amex: { pattern: /^3[47]/, length: [15] }, mastercard: { pattern: /^5[1-5]/, length: [16] }, discover: { pattern: /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/, length: [16] }, unionPay: { pattern: /^(62|88)/, length: [16, 17, 18, 19] }, jcb: { pattern: /^35(2[89]|[3-8][0-9])/, length: [16] }, maestro: { pattern: /^(5018|5020|5038|6304|6759|676[1-3])/, length: [12, 13, 14, 15, 16, 17, 18, 19] }, dinersClub: { pattern: /^(30[0-5]|^36)/, length: [14] }, laser: { pattern: /^(6304|670[69]|6771)/, length: [16, 17, 18, 19] }, visaElectron: { pattern: /^(4026|417500|4508|4844|491(3|7))/, length: [16] } },
                    r = {},
                    s = !1,
                    l = typeof n === "string" && n.split(","); if (typeof t === "string" && t.length !== 0) { if (l && (e.each(l, (n, i) => { (o = a[i]) && (r = { length: e.inArray(t.length, o.length) !== -1, pattern: t.search(o.pattern) !== -1 }, r.length && r.pattern && (s = !0)); }), !s)) return !1; if (i = { number: e.inArray(t.length, a.unionPay.length) !== -1, pattern: t.search(a.unionPay.pattern) !== -1 }, i.number && i.pattern) return !0; for (var c = t.length, u = 0, d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]], f = 0; c--;)f += d[u][parseInt(t.charAt(c), 10)], u ^= 1; return f % 10 == 0 && f > 0; }
            },
            minCount(e, t) { return t == 0 || (t == 1 ? e !== "" : e.split(",").length >= t); },
            exactCount(e, t) { return t == 0 ? e === "" : t == 1 ? e !== "" && e.search(",") === -1 : e.split(",").length == t; },
            maxCount(e, t) { return t != 0 && (t == 1 ? e.search(",") === -1 : e.split(",").length <= t); } } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.accordion = function (n) {
        let i,
            o = e(this),
            a = (new Date()).getTime(),
            r = [],
            s = arguments[0],
            l = typeof s === "string",
            c = [].slice.call(arguments, 1); t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame; return o.each(function () {
                let u,
                    d,
                    f = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.accordion.settings, n) : e.extend({}, e.fn.accordion.settings),
                    m = f.className,
                    g = f.namespace,
                    v = f.selector,
                    p = f.error,
                    h = `.${g}`,
                    b = `module-${g}`,
                    y = o.selector || "",
                    x = e(this),
                    C = x.find(v.title),
                    w = x.find(v.content),
                    k = this,
                    S = x.data(b); d = { initialize() { d.debug("Initializing", x), d.bind.events(), f.observeChanges && d.observeChanges(), d.instantiate(); },
                        instantiate() { S = d, x.data(b, d); },
                        destroy() { d.debug("Destroying previous instance", x), x.off(h).removeData(b); },
                        refresh() { C = x.find(v.title), w = x.find(v.content); },
                        observeChanges() { "MutationObserver" in t && (u = new MutationObserver((e) => { d.debug("DOM tree modified, updating selector cache"), d.refresh(); }), u.observe(k, { childList: !0, subtree: !0 }), d.debug("Setting up mutation observer", u)); },
                        bind: { events() { d.debug("Binding delegated events"), x.on(f.on + h, v.trigger, d.event.click); } },
                        event: { click() { d.toggle.call(this); } },
                        toggle(t) {
                            let n = void 0 !== t ? typeof t === "number" ? C.eq(t) : e(t).closest(v.title) : e(this).closest(v.title),
                                i = n.next(w),
                                o = i.hasClass(m.animating),
                                a = i.hasClass(m.active),
                                r = a && !o,
                                s = !a && o; d.debug("Toggling visibility of content", n), r || s ? f.collapsible ? d.close.call(n) : d.debug("Cannot close accordion content collapsing is disabled") : d.open.call(n);
                        },
                        open(t) {
                            let n = void 0 !== t ? typeof t === "number" ? C.eq(t) : e(t).closest(v.title) : e(this).closest(v.title),
                                i = n.next(w),
                                o = i.hasClass(m.animating); if (i.hasClass(m.active) || o) return void d.debug("Accordion already open, skipping", i); d.debug("Opening accordion content", n), f.onOpening.call(i), f.exclusive && d.closeOthers.call(n), n.addClass(m.active), i.stop(!0, !0).addClass(m.animating), f.animateChildren && (void 0 !== e.fn.transition && x.transition("is supported") ? i.children().transition({ animation: "fade in", queue: !1, useFailSafe: !0, debug: f.debug, verbose: f.verbose, duration: f.duration }) : i.children().stop(!0, !0).animate({ opacity: 1 }, f.duration, d.resetOpacity)), i.slideDown(f.duration, f.easing, function () { i.removeClass(m.animating).addClass(m.active), d.reset.display.call(this), f.onOpen.call(this), f.onChange.call(this); });
                        },
                        close(t) {
                            let n = void 0 !== t ? typeof t === "number" ? C.eq(t) : e(t).closest(v.title) : e(this).closest(v.title),
                                i = n.next(w),
                                o = i.hasClass(m.animating),
                                a = i.hasClass(m.active),
                                r = !a && o,
                                s = a && o; !a && !r || s || (d.debug("Closing accordion content", i), f.onClosing.call(i), n.removeClass(m.active), i.stop(!0, !0).addClass(m.animating), f.animateChildren && (void 0 !== e.fn.transition && x.transition("is supported") ? i.children().transition({ animation: "fade out", queue: !1, useFailSafe: !0, debug: f.debug, verbose: f.verbose, duration: f.duration }) : i.children().stop(!0, !0).animate({ opacity: 0 }, f.duration, d.resetOpacity)), i.slideUp(f.duration, f.easing, function () { i.removeClass(m.animating).removeClass(m.active), d.reset.display.call(this), f.onClose.call(this), f.onChange.call(this); }));
                        },
                        closeOthers(t) {
                            let n,
                                i,
                                o,
                                a = void 0 !== t ? C.eq(t) : e(this).closest(v.title),
                                r = a.parents(v.content).prev(v.title),
                                s = a.closest(v.accordion),
                                l = `${v.title}.${m.active}:visible`,
                                c = `${v.content}.${m.active}:visible`; f.closeNested ? (n = s.find(l).not(r), o = n.next(w)) : (n = s.find(l).not(r), i = s.find(c).find(l).not(r), n = n.not(i), o = n.next(w)), n.length > 0 && (d.debug("Exclusive enabled, closing other content", n), n.removeClass(m.active), o.removeClass(m.animating).stop(!0, !0), f.animateChildren && (void 0 !== e.fn.transition && x.transition("is supported") ? o.children().transition({ animation: "fade out", useFailSafe: !0, debug: f.debug, verbose: f.verbose, duration: f.duration }) : o.children().stop(!0, !0).animate({ opacity: 0 }, f.duration, d.resetOpacity)), o.slideUp(f.duration, f.easing, function () { e(this).removeClass(m.active), d.reset.display.call(this); }));
                        },
                        reset: { display() { d.verbose("Removing inline display from element", this), e(this).css("display", ""), e(this).attr("style") === "" && e(this).attr("style", "").removeAttr("style"); }, opacity() { d.verbose("Removing inline opacity from element", this), e(this).css("opacity", ""), e(this).attr("style") === "" && e(this).attr("style", "").removeAttr("style"); } },
                        setting(t, n) { if (d.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                        internal(t, n) { if (d.debug("Changing internal", t, n), void 0 === n) return d[t]; e.isPlainObject(t) ? e.extend(!0, d, t) : d[t] = n; },
                        debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
                        verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
                        error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; f.performance && (t = (new Date()).getTime(), i = a || t, n = t - i, a = t, r.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: k, "Execution Time": n })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
                        },
                            display() {
                                let t = `${f.name}:`,
                                    n = 0; a = !1, clearTimeout(d.performance.timer), e.each(r, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, y && (t += ` '${y}'`), (void 0 !== console.group || void 0 !== console.table) && r.length > 0 && (console.groupCollapsed(t), console.table ? console.table(r) : e.each(r, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), r = [];
                            } },
                        invoke(t, n, o) {
                            let a,
                                r,
                                s,
                                l = S; return n = n || c, o = k || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => {
                                    const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (d.error(p.method, t), !1); l = l[i]; }
                                })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r;
                        } }, l ? (void 0 === S && d.initialize(), d.invoke(s)) : (void 0 !== S && S.invoke("destroy"), d.initialize());
            }), void 0 !== i ? i : this;
    }, e.fn.accordion.settings = { name: "Accordion", namespace: "accordion", silent: !1, debug: !1, verbose: !1, performance: !0, on: "click", observeChanges: !0, exclusive: !0, collapsible: !0, closeNested: !1, animateChildren: !0, duration: 350, easing: "easeOutQuad", onOpening() {}, onOpen() {}, onClosing() {}, onClose() {}, onChange() {}, error: { method: "The method you called is not defined" }, className: { active: "active", animating: "animating" }, selector: { accordion: ".accordion", title: ".title", trigger: ".title", content: ".content" } }, e.extend(e.easing, { easeOutQuad(e, t, n, i, o) { return -i * (t /= o) * (t - 2) + n; } });
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.checkbox = function (i) {
        let o,
            a = e(this),
            r = a.selector || "",
            s = (new Date()).getTime(),
            l = [],
            c = arguments[0],
            u = typeof c === "string",
            d = [].slice.call(arguments, 1); return a.each(function () {
                let a,
                    f,
                    m = e.extend(!0, {}, e.fn.checkbox.settings, i),
                    g = m.className,
                    v = m.namespace,
                    p = m.selector,
                    h = m.error,
                    b = `.${v}`,
                    y = `module-${v}`,
                    x = e(this),
                    C = e(this).children(p.label),
                    w = e(this).children(p.input),
                    k = w[0],
                    S = !1,
                    T = !1,
                    A = x.data(y),
                    R = this; f = { initialize() { f.verbose("Initializing checkbox", m), f.create.label(), f.bind.events(), f.set.tabbable(), f.hide.input(), f.observeChanges(), f.instantiate(), f.setup(); },
                        instantiate() { f.verbose("Storing instance of module", f), A = f, x.data(y, f); },
                        destroy() { f.verbose("Destroying module"), f.unbind.events(), f.show.input(), x.removeData(y); },
                        fix: { reference() { x.is(p.input) && (f.debug("Behavior called on <input> adjusting invoked element"), x = x.closest(p.checkbox), f.refresh()); } },
                        setup() { f.set.initialLoad(), f.is.indeterminate() ? (f.debug("Initial value is indeterminate"), f.indeterminate()) : f.is.checked() ? (f.debug("Initial value is checked"), f.check()) : (f.debug("Initial value is unchecked"), f.uncheck()), f.remove.initialLoad(); },
                        refresh() { C = x.children(p.label), w = x.children(p.input), k = w[0]; },
                        hide: { input() { f.verbose("Modifying <input> z-index to be unselectable"), w.addClass(g.hidden); } },
                        show: { input() { f.verbose("Modifying <input> z-index to be selectable"), w.removeClass(g.hidden); } },
                        observeChanges() { "MutationObserver" in t && (a = new MutationObserver((e) => { f.debug("DOM tree modified, updating selector cache"), f.refresh(); }), a.observe(R, { childList: !0, subtree: !0 }), f.debug("Setting up mutation observer", a)); },
                        attachEvents(t, n) { const i = e(t); n = e.isFunction(f[n]) ? f[n] : f.toggle, i.length > 0 ? (f.debug("Attaching checkbox events to element", t, n), i.on(`click${b}`, n)) : f.error(h.notFound); },
                        event: { click(t) { const n = e(t.target); return n.is(p.input) ? void f.verbose("Using default check action on initialized checkbox") : n.is(p.link) ? void f.debug("Clicking link inside checkbox, skipping toggle") : (f.toggle(), w.focus(), void t.preventDefault()); },
                            keydown(e) {
                                let t = e.which,
                                    n = { enter: 13, space: 32, escape: 27 }; t == n.escape ? (f.verbose("Escape key pressed blurring field"), w.blur(), T = !0) : e.ctrlKey || t != n.space && t != n.enter ? T = !1 : (f.verbose("Enter/space key pressed, toggling checkbox"), f.toggle(), T = !0);
                            },
                            keyup(e) { T && e.preventDefault(); } },
                        check() { f.should.allowCheck() && (f.debug("Checking checkbox", w), f.set.checked(), f.should.ignoreCallbacks() || (m.onChecked.call(k), m.onChange.call(k))); },
                        uncheck() { f.should.allowUncheck() && (f.debug("Unchecking checkbox"), f.set.unchecked(), f.should.ignoreCallbacks() || (m.onUnchecked.call(k), m.onChange.call(k))); },
                        indeterminate() { if (f.should.allowIndeterminate()) return void f.debug("Checkbox is already indeterminate"); f.debug("Making checkbox indeterminate"), f.set.indeterminate(), f.should.ignoreCallbacks() || (m.onIndeterminate.call(k), m.onChange.call(k)); },
                        determinate() { if (f.should.allowDeterminate()) return void f.debug("Checkbox is already determinate"); f.debug("Making checkbox determinate"), f.set.determinate(), f.should.ignoreCallbacks() || (m.onDeterminate.call(k), m.onChange.call(k)); },
                        enable() { if (f.is.enabled()) return void f.debug("Checkbox is already enabled"); f.debug("Enabling checkbox"), f.set.enabled(), m.onEnable.call(k), m.onEnabled.call(k); },
                        disable() { if (f.is.disabled()) return void f.debug("Checkbox is already disabled"); f.debug("Disabling checkbox"), f.set.disabled(), m.onDisable.call(k), m.onDisabled.call(k); },
                        get: { radios() { return e(`input[name="${f.get.name()}"]`).closest(p.checkbox); }, otherRadios() { return f.get.radios().not(x); }, name() { return w.attr("name"); } },
                        is: { initialLoad() { return S; }, radio() { return w.hasClass(g.radio) || w.attr("type") == "radio"; }, indeterminate() { return void 0 !== w.prop("indeterminate") && w.prop("indeterminate"); }, checked() { return void 0 !== w.prop("checked") && w.prop("checked"); }, disabled() { return void 0 !== w.prop("disabled") && w.prop("disabled"); }, enabled() { return !f.is.disabled(); }, determinate() { return !f.is.indeterminate(); }, unchecked() { return !f.is.checked(); } },
                        should: { allowCheck() { return f.is.determinate() && f.is.checked() && !f.should.forceCallbacks() ? (f.debug("Should not allow check, checkbox is already checked"), !1) : m.beforeChecked.apply(k) !== !1 || (f.debug("Should not allow check, beforeChecked cancelled"), !1); }, allowUncheck() { return f.is.determinate() && f.is.unchecked() && !f.should.forceCallbacks() ? (f.debug("Should not allow uncheck, checkbox is already unchecked"), !1) : m.beforeUnchecked.apply(k) !== !1 || (f.debug("Should not allow uncheck, beforeUnchecked cancelled"), !1); }, allowIndeterminate() { return f.is.indeterminate() && !f.should.forceCallbacks() ? (f.debug("Should not allow indeterminate, checkbox is already indeterminate"), !1) : m.beforeIndeterminate.apply(k) !== !1 || (f.debug("Should not allow indeterminate, beforeIndeterminate cancelled"), !1); }, allowDeterminate() { return f.is.determinate() && !f.should.forceCallbacks() ? (f.debug("Should not allow determinate, checkbox is already determinate"), !1) : m.beforeDeterminate.apply(k) !== !1 || (f.debug("Should not allow determinate, beforeDeterminate cancelled"), !1); }, forceCallbacks() { return f.is.initialLoad() && m.fireOnInit; }, ignoreCallbacks() { return S && !m.fireOnInit; } },
                        can: { change() { return !(x.hasClass(g.disabled) || x.hasClass(g.readOnly) || w.prop("disabled") || w.prop("readonly")); }, uncheck() { return typeof m.uncheckable === "boolean" ? m.uncheckable : !f.is.radio(); } },
                        set: { initialLoad() { S = !0; }, checked() { if (f.verbose("Setting class to checked"), x.removeClass(g.indeterminate).addClass(g.checked), f.is.radio() && f.uncheckOthers(), !f.is.indeterminate() && f.is.checked()) return void f.debug("Input is already checked, skipping input property change"); f.verbose("Setting state to checked", k), w.prop("indeterminate", !1).prop("checked", !0), f.trigger.change(); }, unchecked() { if (f.verbose("Removing checked class"), x.removeClass(g.indeterminate).removeClass(g.checked), !f.is.indeterminate() && f.is.unchecked()) return void f.debug("Input is already unchecked"); f.debug("Setting state to unchecked"), w.prop("indeterminate", !1).prop("checked", !1), f.trigger.change(); }, indeterminate() { if (f.verbose("Setting class to indeterminate"), x.addClass(g.indeterminate), f.is.indeterminate()) return void f.debug("Input is already indeterminate, skipping input property change"); f.debug("Setting state to indeterminate"), w.prop("indeterminate", !0), f.trigger.change(); }, determinate() { if (f.verbose("Removing indeterminate class"), x.removeClass(g.indeterminate), f.is.determinate()) return void f.debug("Input is already determinate, skipping input property change"); f.debug("Setting state to determinate"), w.prop("indeterminate", !1); }, disabled() { if (f.verbose("Setting class to disabled"), x.addClass(g.disabled), f.is.disabled()) return void f.debug("Input is already disabled, skipping input property change"); f.debug("Setting state to disabled"), w.prop("disabled", "disabled"), f.trigger.change(); }, enabled() { if (f.verbose("Removing disabled class"), x.removeClass(g.disabled), f.is.enabled()) return void f.debug("Input is already enabled, skipping input property change"); f.debug("Setting state to enabled"), w.prop("disabled", !1), f.trigger.change(); }, tabbable() { f.verbose("Adding tabindex to checkbox"), void 0 === w.attr("tabindex") && w.attr("tabindex", 0); } },
                        remove: { initialLoad() { S = !1; } },
                        trigger: { change() {
                            let e = n.createEvent("HTMLEvents"),
                                t = w[0]; t && (f.verbose("Triggering native change event"), e.initEvent("change", !0, !1), t.dispatchEvent(e));
                        } },
                        create: { label() { w.prevAll(p.label).length > 0 ? (w.prev(p.label).detach().insertAfter(w), f.debug("Moving existing label", C)) : f.has.label() || (C = e("<label>").insertAfter(w), f.debug("Creating label", C)); } },
                        has: { label() { return C.length > 0; } },
                        bind: { events() { f.verbose("Attaching checkbox events"), x.on(`click${b}`, f.event.click).on(`keydown${b}`, p.input, f.event.keydown).on(`keyup${b}`, p.input, f.event.keyup); } },
                        unbind: { events() { f.debug("Removing events"), x.off(b); } },
                        uncheckOthers() { const e = f.get.otherRadios(); f.debug("Unchecking other radios", e), e.removeClass(g.checked); },
                        toggle() { if (!f.can.change()) return void (f.is.radio() || f.debug("Checkbox is read-only or disabled, ignoring toggle")); f.is.indeterminate() || f.is.unchecked() ? (f.debug("Currently unchecked"), f.check()) : f.is.checked() && f.can.uncheck() && (f.debug("Currently checked"), f.uncheck()); },
                        setting(t, n) { if (f.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (void 0 === n) return m[t]; e.isPlainObject(m[t]) ? e.extend(!0, m[t], n) : m[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; f[t] = n; } },
                        debug() { !m.silent && m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
                        verbose() { !m.silent && m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
                        error() { m.silent || (f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: R, "Execution Time": n })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
                        },
                            display() {
                                let t = `${m.name}:`,
                                    n = 0; s = !1, clearTimeout(f.performance.timer), e.each(l, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), l = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = A; return n = n || d, i = R || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (f.error(h.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, u ? (void 0 === A && f.initialize(), f.invoke(c)) : (void 0 !== A && A.invoke("destroy"), f.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.checkbox.settings = { name: "Checkbox", namespace: "checkbox", silent: !1, debug: !1, verbose: !0, performance: !0, uncheckable: "auto", fireOnInit: !1, onChange() {}, beforeChecked() {}, beforeUnchecked() {}, beforeDeterminate() {}, beforeIndeterminate() {}, onChecked() {}, onUnchecked() {}, onDeterminate() {}, onIndeterminate() {}, onEnable() {}, onDisable() {}, onEnabled() {}, onDisabled() {}, className: { checked: "checked", indeterminate: "indeterminate", disabled: "disabled", hidden: "hidden", radio: "radio", readOnly: "read-only" }, error: { method: "The method you called is not defined" }, selector: { checkbox: ".ui.checkbox", label: "label, .box", input: "input[type=\"checkbox\"], input[type=\"radio\"]", link: "a[href]" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.dimmer = function (t) {
        let i,
            o = e(this),
            a = (new Date()).getTime(),
            r = [],
            s = arguments[0],
            l = typeof s === "string",
            c = [].slice.call(arguments, 1); return o.each(function () {
                let u,
                    d,
                    f,
                    m = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.dimmer.settings, t) : e.extend({}, e.fn.dimmer.settings),
                    g = m.selector,
                    v = m.namespace,
                    p = m.className,
                    h = m.error,
                    b = `.${v}`,
                    y = `module-${v}`,
                    x = o.selector || "",
                    C = "ontouchstart" in n.documentElement ? "touchstart" : "click",
                    w = e(this),
                    k = this,
                    S = w.data(y); f = { preinitialize() { f.is.dimmer() ? (d = w.parent(), u = w) : (d = w, u = f.has.dimmer() ? m.dimmerName ? d.find(g.dimmer).filter(`.${m.dimmerName}`) : d.find(g.dimmer) : f.create(), f.set.variation()); },
                        initialize() { f.debug("Initializing dimmer", m), f.bind.events(), f.set.dimmable(), f.instantiate(); },
                        instantiate() { f.verbose("Storing instance of module", f), S = f, w.data(y, S); },
                        destroy() { f.verbose("Destroying previous module", u), f.unbind.events(), f.remove.variation(), d.off(b); },
                        bind: { events() { m.on == "hover" ? d.on(`mouseenter${b}`, f.show).on(`mouseleave${b}`, f.hide) : m.on == "click" && d.on(C + b, f.toggle), f.is.page() && (f.debug("Setting as a page dimmer", d), f.set.pageDimmer()), f.is.closable() && (f.verbose("Adding dimmer close event", u), d.on(C + b, g.dimmer, f.event.click)); } },
                        unbind: { events() { w.removeData(y), d.off(b); } },
                        event: { click(t) { f.verbose("Determining if event occured on dimmer", t), (u.find(t.target).length === 0 || e(t.target).is(g.content)) && (f.hide(), t.stopImmediatePropagation()); } },
                        addContent(t) { const n = e(t); f.debug("Add content to dimmer", n), n.parent()[0] !== u[0] && n.detach().appendTo(u); },
                        create() { const t = e(m.template.dimmer()); return m.dimmerName && (f.debug("Creating named dimmer", m.dimmerName), t.addClass(m.dimmerName)), t.appendTo(d), t; },
                        show(t) { t = e.isFunction(t) ? t : function () {}, f.debug("Showing dimmer", u, m), f.is.dimmed() && !f.is.animating() || !f.is.enabled() ? f.debug("Dimmer is already shown or disabled") : (f.animate.show(t), m.onShow.call(k), m.onChange.call(k)); },
                        hide(t) { t = e.isFunction(t) ? t : function () {}, f.is.dimmed() || f.is.animating() ? (f.debug("Hiding dimmer", u), f.animate.hide(t), m.onHide.call(k), m.onChange.call(k)) : f.debug("Dimmer is not visible"); },
                        toggle() { f.verbose("Toggling dimmer visibility", u), f.is.dimmed() ? f.hide() : f.show(); },
                        animate: { show(t) { t = e.isFunction(t) ? t : function () {}, m.useCSS && void 0 !== e.fn.transition && u.transition("is supported") ? (m.opacity !== "auto" && f.set.opacity(), u.transition({ animation: `${m.transition} in`, queue: !1, duration: f.get.duration(), useFailSafe: !0, onStart() { f.set.dimmed(); }, onComplete() { f.set.active(), t(); } })) : (f.verbose("Showing dimmer animation with javascript"), f.set.dimmed(), m.opacity == "auto" && (m.opacity = 0.8), u.stop().css({ opacity: 0, width: "100%", height: "100%" }).fadeTo(f.get.duration(), m.opacity, () => { u.removeAttr("style"), f.set.active(), t(); })); }, hide(t) { t = e.isFunction(t) ? t : function () {}, m.useCSS && void 0 !== e.fn.transition && u.transition("is supported") ? (f.verbose("Hiding dimmer with css"), u.transition({ animation: `${m.transition} out`, queue: !1, duration: f.get.duration(), useFailSafe: !0, onStart() { f.remove.dimmed(); }, onComplete() { f.remove.active(), t(); } })) : (f.verbose("Hiding dimmer with javascript"), f.remove.dimmed(), u.stop().fadeOut(f.get.duration(), () => { f.remove.active(), u.removeAttr("style"), t(); })); } },
                        get: { dimmer() { return u; }, duration() { return typeof m.duration === "object" ? f.is.active() ? m.duration.hide : m.duration.show : m.duration; } },
                        has: { dimmer() { return m.dimmerName ? w.find(g.dimmer).filter(`.${m.dimmerName}`).length > 0 : w.find(g.dimmer).length > 0; } },
                        is: { active() { return u.hasClass(p.active); }, animating() { return u.is(":animated") || u.hasClass(p.animating); }, closable() { return m.closable == "auto" ? m.on != "hover" : m.closable; }, dimmer() { return w.hasClass(p.dimmer); }, dimmable() { return w.hasClass(p.dimmable); }, dimmed() { return d.hasClass(p.dimmed); }, disabled() { return d.hasClass(p.disabled); }, enabled() { return !f.is.disabled(); }, page() { return d.is("body"); }, pageDimmer() { return u.hasClass(p.pageDimmer); } },
                        can: { show() { return !u.hasClass(p.disabled); } },
                        set: { opacity(e) {
                            let t = u.css("background-color"),
                                n = t.split(","),
                                i = n && n.length == 3,
                                o = n && n.length == 4; e = m.opacity === 0 ? 0 : m.opacity || e, i || o ? (n[3] = `${e})`, t = n.join(",")) : t = `rgba(0, 0, 0, ${e})`, f.debug("Setting opacity to", e), u.css("background-color", t);
                        },
                            active() { u.addClass(p.active); },
                            dimmable() { d.addClass(p.dimmable); },
                            dimmed() { d.addClass(p.dimmed); },
                            pageDimmer() { u.addClass(p.pageDimmer); },
                            disabled() { u.addClass(p.disabled); },
                            variation(e) { (e = e || m.variation) && u.addClass(e); } },
                        remove: { active() { u.removeClass(p.active); }, dimmed() { d.removeClass(p.dimmed); }, disabled() { u.removeClass(p.disabled); }, variation(e) { (e = e || m.variation) && u.removeClass(e); } },
                        setting(t, n) { if (f.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, m, t); else { if (void 0 === n) return m[t]; e.isPlainObject(m[t]) ? e.extend(!0, m[t], n) : m[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; f[t] = n; } },
                        debug() { !m.silent && m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
                        verbose() { !m.silent && m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
                        error() { m.silent || (f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; m.performance && (t = (new Date()).getTime(), i = a || t, n = t - i, a = t, r.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: k, "Execution Time": n })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
                        },
                            display() {
                                let t = `${m.name}:`,
                                    n = 0; a = !1, clearTimeout(f.performance.timer), e.each(r, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, x && (t += ` '${x}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && r.length > 0 && (console.groupCollapsed(t), console.table ? console.table(r) : e.each(r, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), r = [];
                            } },
                        invoke(t, n, o) {
                            let a,
                                r,
                                s,
                                l = S; return n = n || c, o = k || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (f.error(h.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r;
                        } }, f.preinitialize(), l ? (void 0 === S && f.initialize(), f.invoke(s)) : (void 0 !== S && S.invoke("destroy"), f.initialize());
            }), void 0 !== i ? i : this;
    }, e.fn.dimmer.settings = { name: "Dimmer", namespace: "dimmer", silent: !1, debug: !1, verbose: !1, performance: !0, dimmerName: !1, variation: !1, closable: "auto", useCSS: !0, transition: "fade", on: !1, opacity: "auto", duration: { show: 500, hide: 500 }, onChange() {}, onShow() {}, onHide() {}, error: { method: "The method you called is not defined." }, className: { active: "active", animating: "animating", dimmable: "dimmable", dimmed: "dimmed", dimmer: "dimmer", disabled: "disabled", hide: "hide", pageDimmer: "page", show: "show" }, selector: { dimmer: "> .ui.dimmer", content: ".ui.dimmer > .content, .ui.dimmer > .content > .center" }, template: { dimmer() { return e("<div />").attr("class", "ui dimmer"); } } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.dropdown = function (i) {
        let o,
            a = e(this),
            r = e(n),
            s = a.selector || "",
            l = "ontouchstart" in n.documentElement,
            c = (new Date()).getTime(),
            u = [],
            d = arguments[0],
            f = typeof d === "string",
            m = [].slice.call(arguments, 1); return a.each(function (g) {
                let v,
                    p,
                    h,
                    b,
                    y,
                    x,
                    C,
                    w,
                    k = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.dropdown.settings, i) : e.extend({}, e.fn.dropdown.settings),
                    S = k.className,
                    T = k.message,
                    A = k.fields,
                    R = k.keys,
                    P = k.metadata,
                    E = k.namespace,
                    F = k.regExp,
                    O = k.selector,
                    D = k.error,
                    q = k.templates,
                    j = `.${E}`,
                    z = `module-${E}`,
                    I = e(this),
                    M = e(k.context),
                    L = I.find(O.text),
                    V = I.find(O.search),
                    N = I.find(O.sizer),
                    H = I.find(O.input),
                    U = I.find(O.icon),
                    W = I.prev().find(O.text).length > 0 ? I.prev().find(O.text) : I.prev(),
                    B = I.children(O.menu),
                    Q = B.find(O.item),
                    X = !1,
                    $ = !1,
                    Y = !1,
                    Z = this,
                    K = I.data(z); w = { initialize() { w.debug("Initializing dropdown", k), w.is.alreadySetup() ? w.setup.reference() : (w.setup.layout(), w.refreshData(), w.save.defaults(), w.restore.selected(), w.create.id(), w.bind.events(), w.observeChanges(), w.instantiate()); },
                        instantiate() { w.verbose("Storing instance of dropdown", w), K = w, I.data(z, w); },
                        destroy() { w.verbose("Destroying previous dropdown", I), w.remove.tabbable(), I.off(j).removeData(z), B.off(j), r.off(b), w.disconnect.menuObserver(), w.disconnect.selectObserver(); },
                        observeChanges() { "MutationObserver" in t && (x = new MutationObserver(w.event.select.mutation), C = new MutationObserver(w.event.menu.mutation), w.debug("Setting up mutation observer", x, C), w.observe.select(), w.observe.menu()); },
                        disconnect: { menuObserver() { C && C.disconnect(); }, selectObserver() { x && x.disconnect(); } },
                        observe: { select() { w.has.input() && x.observe(H[0], { childList: !0, subtree: !0 }); }, menu() { w.has.menu() && C.observe(B[0], { childList: !0, subtree: !0 }); } },
                        create: { id() { y = (`${Math.random().toString(16)}000000000`).substr(2, 8), b = `.${y}`, w.verbose("Creating unique id for element", y); },
                            userChoice(t) {
                                let n,
                                    i,
                                    o; return !!(t = t || w.get.userValues()) && (t = e.isArray(t) ? t : [t], e.each(t, (t, a) => { w.get.item(a) === !1 && (o = k.templates.addition(w.add.variables(T.addResult, a)), i = e("<div />").html(o).attr(`data-${P.value}`, a).attr(`data-${P.text}`, a).addClass(S.addition).addClass(S.item), k.hideAdditions && i.addClass(S.hidden), n = void 0 === n ? i : n.add(i), w.verbose("Creating user choices for value", a, i)); }), n);
                            },
                            userLabels(t) { const n = w.get.userValues(); n && (w.debug("Adding user labels", n), e.each(n, (e, t) => { w.verbose("Adding custom user value"), w.add.label(t, t); })); },
                            menu() { B = e("<div />").addClass(S.menu).appendTo(I); },
                            sizer() { N = e("<span />").addClass(S.sizer).insertAfter(V); } },
                        search(e) { e = void 0 !== e ? e : w.get.query(), w.verbose("Searching for query", e), w.has.minCharacters(e) ? w.filter(e) : w.hide(); },
                        select: { firstUnfiltered() { w.verbose("Selecting first non-filtered element"), w.remove.selectedItem(), Q.not(O.unselectable).not(O.addition + O.hidden).eq(0).addClass(S.selected); },
                            nextAvailable(e) {
                                e = e.eq(0); let t = e.nextAll(O.item).not(O.unselectable).eq(0),
                                    n = e.prevAll(O.item).not(O.unselectable).eq(0); t.length > 0 ? (w.verbose("Moving selection to", t), t.addClass(S.selected)) : (w.verbose("Moving selection to", n), n.addClass(S.selected));
                            } },
                        setup: { api() { const e = { debug: k.debug, urlData: { value: w.get.value(), query: w.get.query() }, on: !1 }; w.verbose("First request, initializing API"), I.api(e); },
                            layout() { I.is("select") && (w.setup.select(), w.setup.returnedObject()), w.has.menu() || w.create.menu(), w.is.search() && !w.has.search() && (w.verbose("Adding search input"), V = e("<input />").addClass(S.search).prop("autocomplete", "off").insertBefore(L)), w.is.multiple() && w.is.searchSelection() && !w.has.sizer() && w.create.sizer(), k.allowTab && w.set.tabbable(); },
                            select() { const t = w.get.selectValues(); w.debug("Dropdown initialized on a select", t), I.is("select") && (H = I), H.parent(O.dropdown).length > 0 ? (w.debug("UI dropdown already exists. Creating dropdown menu only"), I = H.closest(O.dropdown), w.has.menu() || w.create.menu(), B = I.children(O.menu), w.setup.menu(t)) : (w.debug("Creating entire dropdown from select"), I = e("<div />").attr("class", H.attr("class")).addClass(S.selection).addClass(S.dropdown).html(q.dropdown(t)).insertBefore(H), H.hasClass(S.multiple) && H.prop("multiple") === !1 && (w.error(D.missingMultiple), H.prop("multiple", !0)), H.is("[multiple]") && w.set.multiple(), H.prop("disabled") && (w.debug("Disabling dropdown"), I.addClass(S.disabled)), H.removeAttr("class").detach().prependTo(I)), w.refresh(); },
                            menu(e) { B.html(q.menu(e, A)), Q = B.find(O.item); },
                            reference() { w.debug("Dropdown behavior was called on select, replacing with closest dropdown"), I = I.parent(O.dropdown), w.refresh(), w.setup.returnedObject(), f && (K = w, w.invoke(d)); },
                            returnedObject() {
                                let e = a.slice(0, g),
                                    t = a.slice(g + 1); a = e.add(I).add(t);
                            } },
                        refresh() { w.refreshSelectors(), w.refreshData(); },
                        refreshItems() { Q = B.find(O.item); },
                        refreshSelectors() { w.verbose("Refreshing selector cache"), L = I.find(O.text), V = I.find(O.search), H = I.find(O.input), U = I.find(O.icon), W = I.prev().find(O.text).length > 0 ? I.prev().find(O.text) : I.prev(), B = I.children(O.menu), Q = B.find(O.item); },
                        refreshData() { w.verbose("Refreshing cached metadata"), Q.removeData(P.text).removeData(P.value); },
                        clearData() { w.verbose("Clearing metadata"), Q.removeData(P.text).removeData(P.value), I.removeData(P.defaultText).removeData(P.defaultValue).removeData(P.placeholderText); },
                        toggle() { w.verbose("Toggling menu visibility"), w.is.active() ? w.hide() : w.show(); },
                        show(t) { if (t = e.isFunction(t) ? t : function () {}, !w.can.show() && w.is.remote() && (w.debug("No API results retrieved, searching before show"), w.queryRemote(w.get.query(), w.show)), w.can.show() && !w.is.active()) { if (w.debug("Showing dropdown"), !w.has.message() || w.has.maxSelections() || w.has.allResultsFiltered() || w.remove.message(), w.is.allFiltered()) return !0; k.onShow.call(Z) !== !1 && w.animate.show(() => { w.can.click() && w.bind.intent(), w.has.menuSearch() && w.focusSearch(), w.set.visible(), t.call(Z); }); } },
                        hide(t) { t = e.isFunction(t) ? t : function () {}, w.is.active() && (w.debug("Hiding dropdown"), k.onHide.call(Z) !== !1 && w.animate.hide(() => { w.remove.visible(), t.call(Z); })); },
                        hideOthers() { w.verbose("Finding other dropdowns to hide"), a.not(I).has(`${O.menu}.${S.visible}`).dropdown("hide"); },
                        hideMenu() { w.verbose("Hiding menu  instantaneously"), w.remove.active(), w.remove.visible(), B.transition("hide"); },
                        hideSubMenus() { const e = B.children(O.item).find(O.menu); w.verbose("Hiding sub menus", e), e.transition("hide"); },
                        bind: { events() { l && w.bind.touchEvents(), w.bind.keyboardEvents(), w.bind.inputEvents(), w.bind.mouseEvents(); }, touchEvents() { w.debug("Touch device detected binding additional touch events"), w.is.searchSelection() || w.is.single() && I.on(`touchstart${j}`, w.event.test.toggle), B.on(`touchstart${j}`, O.item, w.event.item.mouseenter); }, keyboardEvents() { w.verbose("Binding keyboard events"), I.on(`keydown${j}`, w.event.keydown), w.has.search() && I.on(w.get.inputEvent() + j, O.search, w.event.input), w.is.multiple() && r.on(`keydown${b}`, w.event.document.keydown); }, inputEvents() { w.verbose("Binding input change events"), I.on(`change${j}`, O.input, w.event.change); }, mouseEvents() { w.verbose("Binding mouse events"), w.is.multiple() && I.on(`click${j}`, O.label, w.event.label.click).on(`click${j}`, O.remove, w.event.remove.click), w.is.searchSelection() ? (I.on(`mousedown${j}`, w.event.mousedown).on(`mouseup${j}`, w.event.mouseup).on(`mousedown${j}`, O.menu, w.event.menu.mousedown).on(`mouseup${j}`, O.menu, w.event.menu.mouseup).on(`click${j}`, O.icon, w.event.icon.click).on(`focus${j}`, O.search, w.event.search.focus).on(`click${j}`, O.search, w.event.search.focus).on(`blur${j}`, O.search, w.event.search.blur).on(`click${j}`, O.text, w.event.text.focus), w.is.multiple() && I.on(`click${j}`, w.event.click)) : (k.on == "click" ? I.on(`click${j}`, O.icon, w.event.icon.click).on(`click${j}`, w.event.test.toggle) : k.on == "hover" ? I.on(`mouseenter${j}`, w.delay.show).on(`mouseleave${j}`, w.delay.hide) : I.on(k.on + j, w.toggle), I.on(`mousedown${j}`, w.event.mousedown).on(`mouseup${j}`, w.event.mouseup).on(`focus${j}`, w.event.focus), w.has.menuSearch() ? I.on(`blur${j}`, O.search, w.event.search.blur) : I.on(`blur${j}`, w.event.blur)), B.on(`mouseenter${j}`, O.item, w.event.item.mouseenter).on(`mouseleave${j}`, O.item, w.event.item.mouseleave).on(`click${j}`, O.item, w.event.item.click); }, intent() { w.verbose("Binding hide intent event to document"), l && r.on(`touchstart${b}`, w.event.test.touch).on(`touchmove${b}`, w.event.test.touch), r.on(`click${b}`, w.event.test.hide); } },
                        unbind: { intent() { w.verbose("Removing hide intent event from document"), l && r.off(`touchstart${b}`).off(`touchmove${b}`), r.off(`click${b}`); } },
                        filter(e) {
                            let t = void 0 !== e ? e : w.get.query(),
                                n = function () { w.is.multiple() && w.filterActive(), w.select.firstUnfiltered(), w.has.allResultsFiltered() ? k.onNoResults.call(Z, t) ? k.allowAdditions ? k.hideAdditions && (w.verbose("User addition with no menu, setting empty style"), w.set.empty(), w.hideMenu()) : (w.verbose("All items filtered, showing message", t), w.add.message(T.noResults)) : (w.verbose("All items filtered, hiding dropdown", t), w.hideMenu()) : (w.remove.empty(), w.remove.message()), k.allowAdditions && w.add.userSuggestion(e), w.is.searchSelection() && w.can.show() && w.is.focusedOnSearch() && w.show(); }; k.useLabels && w.has.maxSelections() || (k.apiSettings ? w.can.useAPI() ? w.queryRemote(t, () => { k.filterRemoteData && w.filterItems(t), n(); }) : w.error(D.noAPI) : (w.filterItems(t), n()));
                        },
                        queryRemote(t, n) { let i = { errorDuration: !1, cache: "local", throttle: k.throttle, urlData: { query: t }, onError() { w.add.message(T.serverError), n(); }, onFailure() { w.add.message(T.serverError), n(); }, onSuccess(e) { w.remove.message(), w.setup.menu({ values: e[A.remoteValues] }), n(); } }; I.api("get request") || w.setup.api(), i = e.extend(!0, {}, i, k.apiSettings), I.api("setting", i).api("query"); },
                        filterItems(t) {
                            let n = void 0 !== t ? t : w.get.query(),
                                i = null,
                                o = w.escape.string(n),
                                a = new RegExp(`^${o}`, "igm"); w.has.query() && (i = [], w.verbose("Searching for matching values", n), Q.each(function () {
                                    let t,
                                        o,
                                        r = e(this); if (k.match == "both" || k.match == "text") { if (t = String(w.get.choiceText(r, !1)), t.search(a) !== -1) return i.push(this), !0; if (k.fullTextSearch === "exact" && w.exactSearch(n, t)) return i.push(this), !0; if (k.fullTextSearch === !0 && w.fuzzySearch(n, t)) return i.push(this), !0; } if (k.match == "both" || k.match == "value") { if (o = String(w.get.choiceValue(r, t)), o.search(a) !== -1) return i.push(this), !0; if (k.fullTextSearch === "exact" && w.exactSearch(n, o)) return i.push(this), !0; if (k.fullTextSearch === !0 && w.fuzzySearch(n, o)) return i.push(this), !0; }
                                })), w.debug("Showing only matched items", n), w.remove.filteredItem(), i && Q.not(i).addClass(S.filtered);
                        },
                        fuzzySearch(e, t) {
                            let n = t.length,
                                i = e.length; if (e = e.toLowerCase(), t = t.toLowerCase(), i > n) return !1; if (i === n) return e === t; e:for (let o = 0, a = 0; o < i; o++) { for (let r = e.charCodeAt(o); a < n;) if (t.charCodeAt(a++) === r) continue e; return !1; } return !0;
                        },
                        exactSearch(e, t) { return e = e.toLowerCase(), t = t.toLowerCase(), t.indexOf(e) > -1; },
                        filterActive() { k.useLabels && Q.filter(`.${S.active}`).addClass(S.filtered); },
                        focusSearch(e) { w.has.search() && !w.is.focusedOnSearch() && (e ? (I.off(`focus${j}`, O.search), V.focus(), I.on(`focus${j}`, O.search, w.event.search.focus)) : V.focus()); },
                        forceSelection() {
                            let e = Q.not(S.filtered).filter(`.${S.selected}`).eq(0),
                                t = Q.not(S.filtered).filter(`.${S.active}`).eq(0),
                                n = e.length > 0 ? e : t; if (n.length > 0 && !w.is.multiple()) return w.debug("Forcing partial selection to selected item", n), void w.event.item.click.call(n, {}, !0); k.allowAdditions ? (w.set.selected(w.get.query()), w.remove.searchTerm()) : w.remove.searchTerm();
                        },
                        event: { change() { Y || (w.debug("Input changed, updating selection"), w.set.selected()); },
                            focus() { k.showOnFocus && !X && w.is.hidden() && !p && w.show(); },
                            blur(e) { p = n.activeElement === this, X || p || (w.remove.activeLabel(), w.hide()); },
                            mousedown() { w.is.searchSelection() ? h = !0 : X = !0; },
                            mouseup() { w.is.searchSelection() ? h = !1 : X = !1; },
                            click(t) { e(t.target).is(I) && (w.is.focusedOnSearch() ? w.show() : w.focusSearch()); },
                            search: { focus() { X = !0, w.is.multiple() && w.remove.activeLabel(), k.showOnFocus && w.search(); }, blur(e) { p = n.activeElement === this, h || $ || p || (k.forceSelection && w.forceSelection(), w.hide()), h = !1; } },
                            icon: { click(e) { w.toggle(); } },
                            text: { focus(e) { X = !0, w.focusSearch(); } },
                            input(e) { (w.is.multiple() || w.is.searchSelection()) && w.set.filtered(), clearTimeout(w.timer), w.timer = setTimeout(w.search, k.delay.search); },
                            label: { click(t) {
                                let n = e(this),
                                    i = I.find(O.label),
                                    o = i.filter(`.${S.active}`),
                                    a = n.nextAll(`.${S.active}`),
                                    r = n.prevAll(`.${S.active}`),
                                    s = a.length > 0 ? n.nextUntil(a).add(o).add(n) : n.prevUntil(r).add(o).add(n); t.shiftKey ? (o.removeClass(S.active), s.addClass(S.active)) : t.ctrlKey ? n.toggleClass(S.active) : (o.removeClass(S.active), n.addClass(S.active)), k.onLabelSelect.apply(this, i.filter(`.${S.active}`));
                            } },
                            remove: { click() { const t = e(this).parent(); t.hasClass(S.active) ? w.remove.activeLabels() : w.remove.activeLabels(t); } },
                            test: { toggle(e) { const t = w.is.multiple() ? w.show : w.toggle; w.is.bubbledLabelClick(e) || w.is.bubbledIconClick(e) || w.determine.eventOnElement(e, t) && e.preventDefault(); }, touch(e) { w.determine.eventOnElement(e, () => { e.type == "touchstart" ? w.timer = setTimeout(() => { w.hide(); }, k.delay.touch) : e.type == "touchmove" && clearTimeout(w.timer); }), e.stopPropagation(); }, hide(e) { w.determine.eventInModule(e, w.hide); } },
                            select: { mutation(e) { w.debug("<select> modified, recreating menu"), w.setup.select(); } },
                            menu: { mutation(t) {
                                let n = t[0],
                                    i = e(n.addedNodes ? n.addedNodes[0] : !1),
                                    o = e(n.removedNodes ? n.removedNodes[0] : !1),
                                    a = i.add(o),
                                    r = a.is(O.addition) || a.closest(O.addition).length > 0,
                                    s = a.is(O.message) || a.closest(O.message).length > 0; r || s ? (w.debug("Updating item selector cache"), w.refreshItems()) : (w.debug("Menu modified, updating selector cache"), w.refresh());
                            },
                                mousedown() { $ = !0; },
                                mouseup() { $ = !1; } },
                            item: { mouseenter(t) {
                                let n = e(t.target),
                                    i = e(this),
                                    o = i.children(O.menu),
                                    a = i.siblings(O.item).children(O.menu),
                                    r = o.length > 0; !(o.find(n).length > 0) && r && (clearTimeout(w.itemTimer), w.itemTimer = setTimeout(() => { w.verbose("Showing sub-menu", o), e.each(a, function () { w.animate.hide(!1, e(this)); }), w.animate.show(!1, o); }, k.delay.show), t.preventDefault());
                            },
                                mouseleave(t) { const n = e(this).children(O.menu); n.length > 0 && (clearTimeout(w.itemTimer), w.itemTimer = setTimeout(() => { w.verbose("Hiding sub-menu", n), w.animate.hide(!1, n); }, k.delay.hide)); },
                                click(t, n) {
                                    let i = e(this),
                                        o = e(t ? t.target : ""),
                                        a = i.find(O.menu),
                                        r = w.get.choiceText(i),
                                        s = w.get.choiceValue(i, r),
                                        l = a.length > 0; a.find(o).length > 0 || l && !k.allowCategorySelection || (w.is.searchSelection() && (k.allowAdditions && w.remove.userAddition(), w.remove.searchTerm(), w.is.focusedOnSearch() || n == 1 || w.focusSearch(!0)), k.useLabels || (w.remove.filteredItem(), w.set.scrollPosition(i)), w.determine.selectAction.call(this, r, s));
                                } },
                            document: { keydown(e) {
                                const t = e.which; if (w.is.inObject(t, R)) {
                                    let n = I.find(O.label),
                                        i = n.filter(`.${S.active}`),
                                        o = (i.data(P.value), n.index(i)),
                                        a = n.length,
                                        r = i.length > 0,
                                        s = i.length > 1,
                                        l = o === 0,
                                        c = o + 1 == a,
                                        u = w.is.searchSelection(),
                                        d = w.is.focusedOnSearch(),
                                        f = w.is.focused(),
                                        m = d && w.get.caretPosition() === 0; if (u && !r && !d) return; t == R.leftArrow ? !f && !m || r ? r && (e.shiftKey ? w.verbose("Adding previous label to selection") : (w.verbose("Selecting previous label"), n.removeClass(S.active)), l && !s ? i.addClass(S.active) : i.prev(O.siblingLabel).addClass(S.active).end(), e.preventDefault()) : (w.verbose("Selecting previous label"), n.last().addClass(S.active)) : t == R.rightArrow ? (f && !r && n.first().addClass(S.active), r && (e.shiftKey ? w.verbose("Adding next label to selection") : (w.verbose("Selecting next label"), n.removeClass(S.active)), c ? u ? d ? n.removeClass(S.active) : w.focusSearch() : s ? i.next(O.siblingLabel).addClass(S.active) : i.addClass(S.active) : i.next(O.siblingLabel).addClass(S.active), e.preventDefault())) : t == R.deleteKey || t == R.backspace ? r ? (w.verbose("Removing active labels"), c && u && !d && w.focusSearch(), i.last().next(O.siblingLabel).addClass(S.active), w.remove.activeLabels(i), e.preventDefault()) : m && !r && t == R.backspace && (w.verbose("Removing last label on input backspace"), i = n.last().addClass(S.active), w.remove.activeLabels(i)) : i.removeClass(S.active);
                                }
                            } },
                            keydown(e) {
                                let t = e.which; if (w.is.inObject(t, R)) {
                                    let n,
                                        i = Q.not(O.unselectable).filter(`.${S.selected}`).eq(0),
                                        o = B.children(`.${S.active}`).eq(0),
                                        a = i.length > 0 ? i : o,
                                        r = a.length > 0 ? a.siblings(`:not(.${S.filtered})`).addBack() : B.children(`:not(.${S.filtered})`),
                                        s = a.children(O.menu),
                                        l = a.closest(O.menu),
                                        c = l.hasClass(S.visible) || l.hasClass(S.animating) || l.parent(O.menu).length > 0,
                                        u = s.length > 0,
                                        d = a.length > 0,
                                        f = a.not(O.unselectable).length > 0,
                                        m = t == R.delimiter && k.allowAdditions && w.is.multiple(),
                                        g = k.allowAdditions && k.hideAdditions && (t == R.enter || m) && f; if (g && (w.verbose("Selecting item from keyboard shortcut", a), w.event.item.click.call(a, e), w.is.searchSelection() && w.remove.searchTerm()), w.is.visible()) { if ((t == R.enter || m) && (t == R.enter && d && u && !k.allowCategorySelection ? (w.verbose("Pressed enter on unselectable category, opening sub menu"), t = R.rightArrow) : f && (w.verbose("Selecting item from keyboard shortcut", a), w.event.item.click.call(a, e), w.is.searchSelection() && w.remove.searchTerm()), e.preventDefault()), d && (t == R.leftArrow && l[0] !== B[0] && (w.verbose("Left key pressed, closing sub-menu"), w.animate.hide(!1, l), a.removeClass(S.selected), l.closest(O.item).addClass(S.selected), e.preventDefault()), t == R.rightArrow && u && (w.verbose("Right key pressed, opening sub-menu"), w.animate.show(!1, s), a.removeClass(S.selected), s.find(O.item).eq(0).addClass(S.selected), e.preventDefault())), t == R.upArrow) { if (n = d && c ? a.prevAll(`${O.item}:not(${O.unselectable})`).eq(0) : Q.eq(0), r.index(n) < 0) return w.verbose("Up key pressed but reached top of current menu"), void e.preventDefault(); w.verbose("Up key pressed, changing active item"), a.removeClass(S.selected), n.addClass(S.selected), w.set.scrollPosition(n), k.selectOnKeydown && w.is.single() && w.set.selectedItem(n), e.preventDefault(); } if (t == R.downArrow) { if (n = d && c ? n = a.nextAll(`${O.item}:not(${O.unselectable})`).eq(0) : Q.eq(0), n.length === 0) return w.verbose("Down key pressed but reached bottom of current menu"), void e.preventDefault(); w.verbose("Down key pressed, changing active item"), Q.removeClass(S.selected), n.addClass(S.selected), w.set.scrollPosition(n), k.selectOnKeydown && w.is.single() && w.set.selectedItem(n), e.preventDefault(); }t == R.pageUp && (w.scrollPage("up"), e.preventDefault()), t == R.pageDown && (w.scrollPage("down"), e.preventDefault()), t == R.escape && (w.verbose("Escape key pressed, closing dropdown"), w.hide()); } else m && e.preventDefault(), t != R.downArrow || w.is.visible() || (w.verbose("Down key pressed, showing dropdown"), w.select.firstUnfiltered(), w.show(), e.preventDefault());
                                } else w.has.search() || w.set.selectedLetter(String.fromCharCode(t));
                            } },
                        trigger: { change() {
                            let e = n.createEvent("HTMLEvents"),
                                t = H[0]; t && (w.verbose("Triggering native change event"), e.initEvent("change", !0, !1), t.dispatchEvent(e));
                        } },
                        determine: { selectAction(t, n) { w.verbose("Determining action", k.action), e.isFunction(w.action[k.action]) ? (w.verbose("Triggering preset action", k.action, t, n), w.action[k.action].call(Z, t, n, this)) : e.isFunction(k.action) ? (w.verbose("Triggering user action", k.action, t, n), k.action.call(Z, t, n, this)) : w.error(D.action, k.action); },
                            eventInModule(t, i) {
                                let o = e(t.target),
                                    a = o.closest(n.documentElement).length > 0,
                                    r = o.closest(I).length > 0; return i = e.isFunction(i) ? i : function () {}, a && !r ? (w.verbose("Triggering event", i), i(), !0) : (w.verbose("Event occurred in dropdown, canceling callback"), !1);
                            },
                            eventOnElement(t, i) {
                                let o = e(t.target),
                                    a = o.closest(O.siblingLabel),
                                    r = n.body.contains(t.target),
                                    s = I.find(a).length === 0,
                                    l = o.closest(B).length === 0; return i = e.isFunction(i) ? i : function () {}, r && s && l ? (w.verbose("Triggering event", i), i(), !0) : (w.verbose("Event occurred in dropdown menu, canceling callback"), !1);
                            } },
                        action: { nothing() {}, activate(t, n, i) { if (n = void 0 !== n ? n : t, w.can.activate(e(i))) { if (w.set.selected(n, e(i)), w.is.multiple() && !w.is.allFiltered()) return; w.hideAndClear(); } }, select(t, n, i) { if (n = void 0 !== n ? n : t, w.can.activate(e(i))) { if (w.set.value(n, e(i)), w.is.multiple() && !w.is.allFiltered()) return; w.hideAndClear(); } }, combo(t, n, i) { n = void 0 !== n ? n : t, w.set.selected(n, e(i)), w.hideAndClear(); }, hide(e, t, n) { w.set.value(t, e), w.hideAndClear(); } },
                        get: { id() { return y; },
                            defaultText() { return I.data(P.defaultText); },
                            defaultValue() { return I.data(P.defaultValue); },
                            placeholderText() { return I.data(P.placeholderText) || ""; },
                            text() { return L.text(); },
                            query() { return e.trim(V.val()); },
                            searchWidth(e) { return e = void 0 !== e ? e : V.val(), N.text(e), Math.ceil(N.width() + 1); },
                            selectionCount() { const t = w.get.values(); return w.is.multiple() ? e.isArray(t) ? t.length : 0 : w.get.value() !== "" ? 1 : 0; },
                            transition(e) { return k.transition == "auto" ? w.is.upward(e) ? "slide up" : "slide down" : k.transition; },
                            userValues() { let t = w.get.values(); return !!t && (t = e.isArray(t) ? t : [t], e.grep(t, e => w.get.item(e) === !1)); },
                            uniqueArray(t) { return e.grep(t, (n, i) => e.inArray(n, t) === i); },
                            caretPosition() {
                                let e,
                                    t,
                                    i = V.get(0); return "selectionStart" in i ? i.selectionStart : n.selection ? (i.focus(), e = n.selection.createRange(), t = e.text.length, e.moveStart("character", -i.value.length), e.text.length - t) : void 0;
                            },
                            value() {
                                let t = H.length > 0 ? H.val() : I.data(P.value),
                                    n = e.isArray(t) && t.length === 1 && t[0] === ""; return void 0 === t || n ? "" : t;
                            },
                            values() { const e = w.get.value(); return e === "" ? "" : !w.has.selectInput() && w.is.multiple() ? typeof e === "string" ? e.split(k.delimiter) : "" : e; },
                            remoteValues() {
                                let t = w.get.values(),
                                    n = !1; return t && (typeof t === "string" && (t = [t]), e.each(t, (e, t) => { const i = w.read.remoteData(t); w.verbose("Restoring value from session data", i, t), i && (n || (n = {}), n[t] = i); })), n;
                            },
                            choiceText(t, n) { if (n = void 0 !== n ? n : k.preserveHTML, t) return t.find(O.menu).length > 0 && (w.verbose("Retrieving text of element with sub-menu"), t = t.clone(), t.find(O.menu).remove(), t.find(O.menuIcon).remove()), void 0 !== t.data(P.text) ? t.data(P.text) : n ? e.trim(t.html()) : e.trim(t.text()); },
                            choiceValue(t, n) { return n = n || w.get.choiceText(t), !!t && (void 0 !== t.data(P.value) ? String(t.data(P.value)) : typeof n === "string" ? e.trim(n.toLowerCase()) : String(n)); },
                            inputEvent() { const e = V[0]; return !!e && (void 0 !== e.oninput ? "input" : void 0 !== e.onpropertychange ? "propertychange" : "keyup"); },
                            selectValues() {
                                const t = {}; return t.values = [], I.find("option").each(function () {
                                    let n = e(this),
                                        i = n.html(),
                                        o = n.attr("disabled"),
                                        a = void 0 !== n.attr("value") ? n.attr("value") : i; k.placeholder === "auto" && a === "" ? t.placeholder = i : t.values.push({ name: i, value: a, disabled: o });
                                }), k.placeholder && k.placeholder !== "auto" && (w.debug("Setting placeholder value to", k.placeholder), t.placeholder = k.placeholder), k.sortSelect ? (t.values.sort((e, t) => e.name > t.name ? 1 : -1), w.debug("Retrieved and sorted values from select", t)) : w.debug("Retrieved values from select", t), t;
                            },
                            activeItem() { return Q.filter(`.${S.active}`); },
                            selectedItem() { const e = Q.not(O.unselectable).filter(`.${S.selected}`); return e.length > 0 ? e : Q.eq(0); },
                            itemWithAdditions(e) {
                                let t = w.get.item(e),
                                    n = w.create.userChoice(e); return n && n.length > 0 && (t = t.length > 0 ? t.add(n) : n), t;
                            },
                            item(t, n) {
                                let i,
                                    o,
                                    a = !1; return t = void 0 !== t ? t : void 0 !== w.get.values() ? w.get.values() : w.get.text(), i = o ? t.length > 0 : void 0 !== t && t !== null, o = w.is.multiple() && e.isArray(t), n = t === "" || t === 0 || (n || !1), i && Q.each(function () {
                                        let i = e(this),
                                            r = w.get.choiceText(i),
                                            s = w.get.choiceValue(i, r); if (s !== null && void 0 !== s) if (o)e.inArray(String(s), t) === -1 && e.inArray(r, t) === -1 || (a = a ? a.add(i) : i); else if (n) { if (w.verbose("Ambiguous dropdown value using strict type check", i, t), s === t || r === t) return a = i, !0; } else if (String(s) == String(t) || r == t) return w.verbose("Found select item by value", s, t), a = i, !0;
                                    }), a;
                            } },
                        check: { maxSelections(e) { return !k.maxSelections || (e = void 0 !== e ? e : w.get.selectionCount(), e >= k.maxSelections ? (w.debug("Maximum selection count reached"), k.useLabels && (Q.addClass(S.filtered), w.add.message(T.maxSelections)), !0) : (w.verbose("No longer at maximum selection count"), w.remove.message(), w.remove.filteredItem(), w.is.searchSelection() && w.filterItems(), !1)); } },
                        restore: { defaults() { w.clear(), w.restore.defaultText(), w.restore.defaultValue(); }, defaultText() { const e = w.get.defaultText(); e === w.get.placeholderText ? (w.debug("Restoring default placeholder text", e), w.set.placeholderText(e)) : (w.debug("Restoring default text", e), w.set.text(e)); }, placeholderText() { w.set.placeholderText(); }, defaultValue() { const e = w.get.defaultValue(); void 0 !== e && (w.debug("Restoring default value", e), e !== "" ? (w.set.value(e), w.set.selected()) : (w.remove.activeItem(), w.remove.selectedItem())); }, labels() { k.allowAdditions && (k.useLabels || (w.error(D.labels), k.useLabels = !0), w.debug("Restoring selected values"), w.create.userLabels()), w.check.maxSelections(); }, selected() { w.restore.values(), w.is.multiple() ? (w.debug("Restoring previously selected values and labels"), w.restore.labels()) : w.debug("Restoring previously selected values"); }, values() { w.set.initialLoad(), k.apiSettings && k.saveRemoteData && w.get.remoteValues() ? w.restore.remoteValues() : w.set.selected(), w.remove.initialLoad(); }, remoteValues() { const t = w.get.remoteValues(); w.debug("Recreating selected from session data", t), t && (w.is.single() ? e.each(t, (e, t) => { w.set.text(t); }) : e.each(t, (e, t) => { w.add.label(e, t); })); } },
                        read: { remoteData(e) { let n; return void 0 === t.Storage ? void w.error(D.noStorage) : void 0 !== (n = sessionStorage.getItem(e)) && n; } },
                        save: { defaults() { w.save.defaultText(), w.save.placeholderText(), w.save.defaultValue(); }, defaultValue() { const e = w.get.value(); w.verbose("Saving default value as", e), I.data(P.defaultValue, e); }, defaultText() { const e = w.get.text(); w.verbose("Saving default text as", e), I.data(P.defaultText, e); }, placeholderText() { let e; k.placeholder !== !1 && L.hasClass(S.placeholder) && (e = w.get.text(), w.verbose("Saving placeholder text as", e), I.data(P.placeholderText, e)); }, remoteData(e, n) { if (void 0 === t.Storage) return void w.error(D.noStorage); w.verbose("Saving remote data to session storage", n, e), sessionStorage.setItem(n, e); } },
                        clear() { w.is.multiple() && k.useLabels ? w.remove.labels() : (w.remove.activeItem(), w.remove.selectedItem()), w.set.placeholderText(), w.clearValue(); },
                        clearValue() { w.set.value(""); },
                        scrollPage(e, t) {
                            let n,
                                i,
                                o,
                                a = t || w.get.selectedItem(),
                                r = a.closest(O.menu),
                                s = r.outerHeight(),
                                l = r.scrollTop(),
                                c = Q.eq(0).outerHeight(),
                                u = Math.floor(s / c),
                                d = (r.prop("scrollHeight"), e == "up" ? l - c * u : l + c * u),
                                f = Q.not(O.unselectable); o = e == "up" ? f.index(a) - u : f.index(a) + u, n = e == "up" ? o >= 0 : o < f.length, i = n ? f.eq(o) : e == "up" ? f.first() : f.last(), i.length > 0 && (w.debug("Scrolling page", e, i), a.removeClass(S.selected), i.addClass(S.selected), k.selectOnKeydown && w.is.single() && w.set.selectedItem(i), r.scrollTop(d));
                        },
                        set: { filtered() {
                            let e = w.is.multiple(),
                                t = w.is.searchSelection(),
                                n = e && t,
                                i = t ? w.get.query() : "",
                                o = typeof i === "string" && i.length > 0,
                                a = w.get.searchWidth(),
                                r = i !== ""; e && o && (w.verbose("Adjusting input width", a, k.glyphWidth), V.css("width", a)), o || n && r ? (w.verbose("Hiding placeholder text"), L.addClass(S.filtered)) : (!e || n && !r) && (w.verbose("Showing placeholder text"), L.removeClass(S.filtered));
                        },
                            empty() { I.addClass(S.empty); },
                            loading() { I.addClass(S.loading); },
                            placeholderText(e) { e = e || w.get.placeholderText(), w.debug("Setting placeholder text", e), w.set.text(e), L.addClass(S.placeholder); },
                            tabbable() { w.is.searchSelection() ? (w.debug("Added tabindex to searchable dropdown"), V.val("").attr("tabindex", 0), B.attr("tabindex", -1)) : (w.debug("Added tabindex to dropdown"), void 0 === I.attr("tabindex") && (I.attr("tabindex", 0), B.attr("tabindex", -1))); },
                            initialLoad() { w.verbose("Setting initial load"), v = !0; },
                            activeItem(e) { k.allowAdditions && e.filter(O.addition).length > 0 ? e.addClass(S.filtered) : e.addClass(S.active); },
                            partialSearch(e) { const t = w.get.query().length; V.val(e.substr(0, t)); },
                            scrollPosition(e, t) {
                                let n,
                                    i,
                                    o,
                                    a,
                                    r,
                                    s,
                                    l,
                                    c,
                                    u; e = e || w.get.selectedItem(), n = e.closest(O.menu), i = e && e.length > 0, t = void 0 !== t && t, e && n.length > 0 && i && (a = e.position().top, n.addClass(S.loading), s = n.scrollTop(), r = n.offset().top, a = e.offset().top, o = s - r + a, t || (l = n.height(), u = s + l < o + 5, c = o - 5 < s), w.debug("Scrolling to active item", o), (t || c || u) && n.scrollTop(o), n.removeClass(S.loading));
                            },
                            text(e) { k.action !== "select" && (k.action == "combo" ? (w.debug("Changing combo button text", e, W), k.preserveHTML ? W.html(e) : W.text(e)) : (e !== w.get.placeholderText() && L.removeClass(S.placeholder), w.debug("Changing text", e, L), L.removeClass(S.filtered), k.preserveHTML ? L.html(e) : L.text(e))); },
                            selectedItem(e) {
                                let t = w.get.choiceValue(e),
                                    n = w.get.choiceText(e, !1),
                                    i = w.get.choiceText(e, !0); w.debug("Setting user selection to item", e), w.remove.activeItem(), w.set.partialSearch(n), w.set.activeItem(e), w.set.selected(t, e), w.set.text(i);
                            },
                            selectedLetter(t) {
                                let n,
                                    i = Q.filter(`.${S.selected}`),
                                    o = i.length > 0 && w.has.firstLetter(i, t),
                                    a = !1; o && (n = i.nextAll(Q).eq(0), w.has.firstLetter(n, t) && (a = n)), a || Q.each(function () { if (w.has.firstLetter(e(this), t)) return a = e(this), !1; }), a && (w.verbose("Scrolling to next value with letter", t), w.set.scrollPosition(a), i.removeClass(S.selected), a.addClass(S.selected), k.selectOnKeydown && w.is.single() && w.set.selectedItem(a));
                            },
                            direction(e) { k.direction == "auto" ? w.is.onScreen(e) ? w.remove.upward(e) : w.set.upward(e) : k.direction == "upward" && w.set.upward(e); },
                            upward(e) { (e || I).addClass(S.upward); },
                            value(e, t, n) {
                                let i = w.escape.value(e),
                                    o = H.length > 0,
                                    a = (w.has.value(e), w.get.values()),
                                    r = void 0 !== e ? String(e) : e; if (o) { if (!k.allowReselection && r == a && (w.verbose("Skipping value update already same value", e, a), !w.is.initialLoad())) return; w.is.single() && w.has.selectInput() && w.can.extendSelect() && (w.debug("Adding user option", e), w.add.optionValue(e)), w.debug("Updating input value", i, a), Y = !0, H.val(i), k.fireOnInit === !1 && w.is.initialLoad() ? w.debug("Input native change event ignored on initial load") : w.trigger.change(), Y = !1; } else w.verbose("Storing value in metadata", i, H), i !== a && I.data(P.value, r); k.fireOnInit === !1 && w.is.initialLoad() ? w.verbose("No callback on initial load", k.onChange) : k.onChange.call(Z, e, t, n);
                            },
                            active() { I.addClass(S.active); },
                            multiple() { I.addClass(S.multiple); },
                            visible() { I.addClass(S.visible); },
                            exactly(e, t) { w.debug("Setting selected to exact values"), w.clear(), w.set.selected(e, t); },
                            selected(t, n) {
                                const i = w.is.multiple(); (n = k.allowAdditions ? n || w.get.itemWithAdditions(t) : n || w.get.item(t)) && (w.debug("Setting selected menu item to", n), w.is.multiple() && w.remove.searchWidth(), w.is.single() ? (w.remove.activeItem(), w.remove.selectedItem()) : k.useLabels && w.remove.selectedItem(), n.each(function () {
                                    let t = e(this),
                                        o = w.get.choiceText(t),
                                        a = w.get.choiceValue(t, o),
                                        r = t.hasClass(S.filtered),
                                        s = t.hasClass(S.active),
                                        l = t.hasClass(S.addition),
                                        c = i && n.length == 1; i ? !s || l ? (k.apiSettings && k.saveRemoteData && w.save.remoteData(o, a), k.useLabels ? (w.add.value(a, o, t), w.add.label(a, o, c), w.set.activeItem(t), w.filterActive(), w.select.nextAvailable(n)) : (w.add.value(a, o, t), w.set.text(w.add.variables(T.count)), w.set.activeItem(t))) : r || (w.debug("Selected active value, removing label"), w.remove.selected(a)) : (k.apiSettings && k.saveRemoteData && w.save.remoteData(o, a), w.set.text(o), w.set.value(a, o, t), t.addClass(S.active).addClass(S.selected));
                                }));
                            } },
                        add: { label(t, n, i) {
                            let o,
                                a = w.is.searchSelection() ? V : L,
                                r = w.escape.value(t); if (o = e("<a />").addClass(S.label).attr(`data-${P.value}`, r).html(q.label(r, n)), o = k.onLabelCreate.call(o, r, n), w.has.label(t)) return void w.debug("Label already exists, skipping", r); k.label.variation && o.addClass(k.label.variation), i === !0 ? (w.debug("Animating in label", o), o.addClass(S.hidden).insertBefore(a).transition(k.label.transition, k.label.duration)) : (w.debug("Adding selection label", o), o.insertBefore(a));
                        },
                            message(t) {
                                let n = B.children(O.message),
                                    i = k.templates.message(w.add.variables(t)); n.length > 0 ? n.html(i) : n = e("<div/>").html(i).addClass(S.message).appendTo(B);
                            },
                            optionValue(t) { const n = w.escape.value(t); H.find(`option[value="${w.escape.string(n)}"]`).length > 0 || (w.disconnect.selectObserver(), w.is.single() && (w.verbose("Removing previous user addition"), H.find(`option.${S.addition}`).remove()), e("<option/>").prop("value", n).addClass(S.addition).html(t).appendTo(H), w.verbose("Adding user addition as an <option>", t), w.observe.select()); },
                            userSuggestion(e) {
                                let t,
                                    n = B.children(O.addition),
                                    i = w.get.item(e),
                                    o = i && i.not(O.addition).length,
                                    a = n.length > 0; if (!k.useLabels || !w.has.maxSelections()) { if (e === "" || o) return void n.remove(); a ? (n.data(P.value, e).data(P.text, e).attr(`data-${P.value}`, e).attr(`data-${P.text}`, e).removeClass(S.filtered), k.hideAdditions || (t = k.templates.addition(w.add.variables(T.addResult, e)), n.html(t)), w.verbose("Replacing user suggestion with new value", n)) : (n = w.create.userChoice(e), n.prependTo(B), w.verbose("Adding item choice to menu corresponding with user choice addition", n)), k.hideAdditions && !w.is.allFiltered() || n.addClass(S.selected).siblings().removeClass(S.selected), w.refreshItems(); }
                            },
                            variables(e, t) {
                                let n,
                                    i,
                                    o = e.search("{count}") !== -1,
                                    a = e.search("{maxCount}") !== -1,
                                    r = e.search("{term}") !== -1; return w.verbose("Adding templated variables to message", e), o && (n = w.get.selectionCount(), e = e.replace("{count}", n)), a && (n = w.get.selectionCount(), e = e.replace("{maxCount}", k.maxSelections)), r && (i = t || w.get.query(), e = e.replace("{term}", i)), e;
                            },
                            value(t, n, i) {
                                let o,
                                    a = w.get.values(); if (t === "") return void w.debug("Cannot select blank values from multiselect"); e.isArray(a) ? (o = a.concat([t]), o = w.get.uniqueArray(o)) : o = [t], w.has.selectInput() ? w.can.extendSelect() && (w.debug("Adding value to select", t, o, H), w.add.optionValue(t)) : (o = o.join(k.delimiter), w.debug("Setting hidden input to delimited value", o, H)), k.fireOnInit === !1 && w.is.initialLoad() ? w.verbose("Skipping onadd callback on initial load", k.onAdd) : k.onAdd.call(Z, t, n, i), w.set.value(o, t, n, i), w.check.maxSelections();
                            } },
                        remove: { active() { I.removeClass(S.active); },
                            activeLabel() { I.find(O.label).removeClass(S.active); },
                            empty() { I.removeClass(S.empty); },
                            loading() { I.removeClass(S.loading); },
                            initialLoad() { v = !1; },
                            upward(e) { (e || I).removeClass(S.upward); },
                            visible() { I.removeClass(S.visible); },
                            activeItem() { Q.removeClass(S.active); },
                            filteredItem() { k.useLabels && w.has.maxSelections() || (k.useLabels && w.is.multiple() ? Q.not(`.${S.active}`).removeClass(S.filtered) : Q.removeClass(S.filtered), w.remove.empty()); },
                            optionValue(e) {
                                let t = w.escape.value(e),
                                    n = H.find(`option[value="${w.escape.string(t)}"]`); n.length > 0 && n.hasClass(S.addition) && (x && (x.disconnect(), w.verbose("Temporarily disconnecting mutation observer")), n.remove(), w.verbose("Removing user addition as an <option>", t), x && x.observe(H[0], { childList: !0, subtree: !0 }));
                            },
                            message() { B.children(O.message).remove(); },
                            searchWidth() { V.css("width", ""); },
                            searchTerm() { w.verbose("Cleared search term"), V.val(""), w.set.filtered(); },
                            userAddition() { Q.filter(O.addition).remove(); },
                            selected(t, n) {
                                if (!(n = k.allowAdditions ? n || w.get.itemWithAdditions(t) : n || w.get.item(t))) return !1; n.each(function () {
                                    let t = e(this),
                                        n = w.get.choiceText(t),
                                        i = w.get.choiceValue(t, n); w.is.multiple() ? k.useLabels ? (w.remove.value(i, n, t), w.remove.label(i)) : (w.remove.value(i, n, t), w.get.selectionCount() === 0 ? w.set.placeholderText() : w.set.text(w.add.variables(T.count))) : w.remove.value(i, n, t), t.removeClass(S.filtered).removeClass(S.active), k.useLabels && t.removeClass(S.selected);
                                });
                            },
                            selectedItem() { Q.removeClass(S.selected); },
                            value(e, t, n) {
                                let i,
                                    o = w.get.values(); w.has.selectInput() ? (w.verbose("Input is <select> removing selected option", e), i = w.remove.arrayValue(e, o), w.remove.optionValue(e)) : (w.verbose("Removing from delimited values", e), i = w.remove.arrayValue(e, o), i = i.join(k.delimiter)), k.fireOnInit === !1 && w.is.initialLoad() ? w.verbose("No callback on initial load", k.onRemove) : k.onRemove.call(Z, e, t, n), w.set.value(i, t, n), w.check.maxSelections();
                            },
                            arrayValue(t, n) { return e.isArray(n) || (n = [n]), n = e.grep(n, e => t != e), w.verbose("Removed value from delimited string", t, n), n; },
                            label(e, t) {
                                let n = I.find(O.label),
                                    i = n.filter(`[data-${P.value}="${w.escape.string(e)}"]`); w.verbose("Removing label", i), i.remove();
                            },
                            activeLabels(e) { e = e || I.find(O.label).filter(`.${S.active}`), w.verbose("Removing active label selections", e), w.remove.labels(e); },
                            labels(t) {
                                t = t || I.find(O.label), w.verbose("Removing labels", t), t.each(function () {
                                    let t = e(this),
                                        n = t.data(P.value),
                                        i = void 0 !== n ? String(n) : n,
                                        o = w.is.userValue(i); if (k.onLabelRemove.call(t, n) === !1) return void w.debug("Label remove callback cancelled removal"); w.remove.message(), o ? (w.remove.value(i), w.remove.label(i)) : w.remove.selected(i);
                                });
                            },
                            tabbable() { w.is.searchSelection() ? (w.debug("Searchable dropdown initialized"), V.removeAttr("tabindex"), B.removeAttr("tabindex")) : (w.debug("Simple selection dropdown initialized"), I.removeAttr("tabindex"), B.removeAttr("tabindex")); } },
                        has: { menuSearch() { return w.has.search() && V.closest(B).length > 0; },
                            search() { return V.length > 0; },
                            sizer() { return N.length > 0; },
                            selectInput() { return H.is("select"); },
                            minCharacters(e) { return !k.minCharacters || (e = void 0 !== e ? String(e) : String(w.get.query()), e.length >= k.minCharacters); },
                            firstLetter(e, t) {
                                let n,
                                    i; return !(!e || e.length === 0 || typeof t !== "string") && (n = w.get.choiceText(e, !1), t = t.toLowerCase(), i = String(n).charAt(0).toLowerCase(), t == i);
                            },
                            input() { return H.length > 0; },
                            items() { return Q.length > 0; },
                            menu() { return B.length > 0; },
                            message() { return B.children(O.message).length !== 0; },
                            label(e) { const t = w.escape.value(e); return I.find(O.label).filter(`[data-${P.value}="${w.escape.string(t)}"]`).length > 0; },
                            maxSelections() { return k.maxSelections && w.get.selectionCount() >= k.maxSelections; },
                            allResultsFiltered() { const e = Q.not(O.addition); return e.filter(O.unselectable).length === e.length; },
                            userSuggestion() { return B.children(O.addition).length > 0; },
                            query() { return w.get.query() !== ""; },
                            value(t) { const n = w.get.values(); return !!(e.isArray(n) ? n && e.inArray(t, n) !== -1 : n == t); } },
                        is: { active() { return I.hasClass(S.active); },
                            bubbledLabelClick(t) { return e(t.target).is("select, input") && I.closest("label").length > 0; },
                            bubbledIconClick(t) { return e(t.target).closest(U).length > 0; },
                            alreadySetup() { return I.is("select") && I.parent(O.dropdown).length > 0 && I.prev().length === 0; },
                            animating(e) { return e ? e.transition && e.transition("is animating") : B.transition && B.transition("is animating"); },
                            disabled() { return I.hasClass(S.disabled); },
                            focused() { return n.activeElement === I[0]; },
                            focusedOnSearch() { return n.activeElement === V[0]; },
                            allFiltered() { return (w.is.multiple() || w.has.search()) && !(k.hideAdditions == 0 && w.has.userSuggestion()) && !w.has.message() && w.has.allResultsFiltered(); },
                            hidden(e) { return !w.is.visible(e); },
                            initialLoad() { return v; },
                            onScreen(e) {
                                let t,
                                    n = e || B,
                                    i = !0,
                                    o = {}; return n.addClass(S.loading), t = { context: { scrollTop: M.scrollTop(), height: M.outerHeight() }, menu: { offset: n.offset(), height: n.outerHeight() } }, o = { above: t.context.scrollTop <= t.menu.offset.top - t.menu.height, below: t.context.scrollTop + t.context.height >= t.menu.offset.top + t.menu.height }, o.below ? (w.verbose("Dropdown can fit in context downward", o), i = !0) : o.below || o.above ? (w.verbose("Dropdown cannot fit below, opening upward", o), i = !1) : (w.verbose("Dropdown cannot fit in either direction, favoring downward", o), i = !0), n.removeClass(S.loading), i;
                            },
                            inObject(t, n) { let i = !1; return e.each(n, (e, n) => { if (n == t) return i = !0, !0; }), i; },
                            multiple() { return I.hasClass(S.multiple); },
                            remote() { return k.apiSettings && w.can.useAPI(); },
                            single() { return !w.is.multiple(); },
                            selectMutation(t) { let n = !1; return e.each(t, (t, i) => { if (i.target && e(i.target).is("select")) return n = !0, !0; }), n; },
                            search() { return I.hasClass(S.search); },
                            searchSelection() { return w.has.search() && V.parent(O.dropdown).length === 1; },
                            selection() { return I.hasClass(S.selection); },
                            userValue(t) { return e.inArray(t, w.get.userValues()) !== -1; },
                            upward(e) { return (e || I).hasClass(S.upward); },
                            visible(e) { return e ? e.hasClass(S.visible) : B.hasClass(S.visible); } },
                        can: { activate(e) { return !!k.useLabels || (!w.has.maxSelections() || !(!w.has.maxSelections() || !e.hasClass(S.active))); }, click() { return l || k.on == "click"; }, extendSelect() { return k.allowAdditions || k.apiSettings; }, show() { return !w.is.disabled() && (w.has.items() || w.has.message()); }, useAPI() { return void 0 !== e.fn.api; } },
                        animate: { show(t, n) {
                            let i,
                                o = n || B,
                                a = n ? function () {} : function () { w.hideSubMenus(), w.hideOthers(), w.set.active(); }; t = e.isFunction(t) ? t : function () {}, w.verbose("Doing menu show animation", o), w.set.direction(n), i = w.get.transition(n), w.is.selection() && w.set.scrollPosition(w.get.selectedItem(), !0), (w.is.hidden(o) || w.is.animating(o)) && (i == "none" ? (a(), o.transition("show"), t.call(Z)) : void 0 !== e.fn.transition && I.transition("is supported") ? o.transition({ animation: `${i} in`, debug: k.debug, verbose: k.verbose, duration: k.duration, queue: !0, onStart: a, onComplete() { t.call(Z); } }) : w.error(D.noTransition, i));
                        },
                            hide(t, n) {
                                let i = n || B,
                                    o = (n ? k.duration : k.duration, n ? function () {} : function () { w.can.click() && w.unbind.intent(), w.remove.active(); }),
                                    a = w.get.transition(n); t = e.isFunction(t) ? t : function () {}, (w.is.visible(i) || w.is.animating(i)) && (w.verbose("Doing menu hide animation", i), a == "none" ? (o(), i.transition("hide"), t.call(Z)) : void 0 !== e.fn.transition && I.transition("is supported") ? i.transition({ animation: `${a} out`, duration: k.duration, debug: k.debug, verbose: k.verbose, queue: !0, onStart: o, onComplete() { k.direction == "auto" && w.remove.upward(n), t.call(Z); } }) : w.error(D.transition));
                            } },
                        hideAndClear() { w.remove.searchTerm(), w.has.maxSelections() || (w.has.search() ? w.hide(() => { w.remove.filteredItem(); }) : w.hide()); },
                        delay: { show() { w.verbose("Delaying show event to ensure user intent"), clearTimeout(w.timer), w.timer = setTimeout(w.show, k.delay.show); }, hide() { w.verbose("Delaying hide event to ensure user intent"), clearTimeout(w.timer), w.timer = setTimeout(w.hide, k.delay.hide); } },
                        escape: { value(t) {
                            let n = e.isArray(t),
                                i = typeof t === "string",
                                o = !i && !n,
                                a = i && t.search(F.quote) !== -1,
                                r = []; return o || !a ? t : (w.debug("Encoding quote values for use in select", t), n ? (e.each(t, (e, t) => { r.push(t.replace(F.quote, "&quot;")); }), r) : t.replace(F.quote, "&quot;"));
                        },
                            string(e) { return e = String(e), e.replace(F.escape, "\\$&"); } },
                        setting(t, n) { if (w.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, k, t); else { if (void 0 === n) return k[t]; e.isPlainObject(k[t]) ? e.extend(!0, k[t], n) : k[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, w, t); else { if (void 0 === n) return w[t]; w[t] = n; } },
                        debug() { !k.silent && k.debug && (k.performance ? w.performance.log(arguments) : (w.debug = Function.prototype.bind.call(console.info, console, `${k.name}:`), w.debug.apply(console, arguments))); },
                        verbose() {
                            !k.silent && k.verbose && k.debug && (k.performance ? w.performance.log(arguments) : (w.verbose = Function.prototype.bind.call(console.info, console, `${k.name}:`), w.verbose.apply(console, arguments)));
                        },
                        error() { k.silent || (w.error = Function.prototype.bind.call(console.error, console, `${k.name}:`), w.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; k.performance && (t = (new Date()).getTime(), i = c || t, n = t - i, c = t, u.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: Z, "Execution Time": n })), clearTimeout(w.performance.timer), w.performance.timer = setTimeout(w.performance.display, 500);
                        },
                            display() {
                                let t = `${k.name}:`,
                                    n = 0; c = !1, clearTimeout(w.performance.timer), e.each(u, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, s && (t += ` '${s}'`), (void 0 !== console.group || void 0 !== console.table) && u.length > 0 && (console.groupCollapsed(t), console.table ? console.table(u) : e.each(u, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), u = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = K; return n = n || m, i = Z || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (w.error(D.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, f ? (void 0 === K && w.initialize(), w.invoke(d)) : (void 0 !== K && K.invoke("destroy"), w.initialize());
            }), void 0 !== o ? o : a;
    }, e.fn.dropdown.settings = { silent: !1, debug: !1, verbose: !1, performance: !0, on: "click", action: "activate", apiSettings: !1, selectOnKeydown: !0, minCharacters: 0, filterRemoteData: !1, saveRemoteData: !0, throttle: 200, context: t, direction: "auto", keepOnScreen: !0, match: "both", fullTextSearch: !1, placeholder: "auto", preserveHTML: !0, sortSelect: !1, forceSelection: !0, allowAdditions: !1, hideAdditions: !0, maxSelections: !1, useLabels: !0, delimiter: ",", showOnFocus: !0, allowReselection: !1, allowTab: !0, allowCategorySelection: !1, fireOnInit: !1, transition: "auto", duration: 200, glyphWidth: 1.037, label: { transition: "scale", duration: 200, variation: !1 }, delay: { hide: 300, show: 200, search: 20, touch: 50 }, onChange(e, t, n) {}, onAdd(e, t, n) {}, onRemove(e, t, n) {}, onLabelSelect(e) {}, onLabelCreate(t, n) { return e(this); }, onLabelRemove(e) { return !0; }, onNoResults(e) { return !0; }, onShow() {}, onHide() {}, name: "Dropdown", namespace: "dropdown", message: { addResult: "Add <b>{term}</b>", count: "{count} selected", maxSelections: "Max {maxCount} selections", noResults: "No results found.", serverError: "There was an error contacting the server" }, error: { action: "You called a dropdown action that was not defined", alreadySetup: "Once a select has been initialized behaviors must be called on the created ui dropdown", labels: "Allowing user additions currently requires the use of labels.", missingMultiple: "<select> requires multiple property to be set to correctly preserve multiple values", method: "The method you called is not defined.", noAPI: "The API module is required to load resources remotely", noStorage: "Saving remote data requires session storage", noTransition: "This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>" }, regExp: { escape: /[-[\]{}()*+?.,\\^$|#\s]/g, quote: /"/g }, metadata: { defaultText: "defaultText", defaultValue: "defaultValue", placeholderText: "placeholder", text: "text", value: "value" }, fields: { remoteValues: "results", values: "values", disabled: "disabled", name: "name", value: "value", text: "text" }, keys: { backspace: 8, delimiter: 188, deleteKey: 46, enter: 13, escape: 27, pageUp: 33, pageDown: 34, leftArrow: 37, upArrow: 38, rightArrow: 39, downArrow: 40 }, selector: { addition: ".addition", dropdown: ".ui.dropdown", hidden: ".hidden", icon: "> .dropdown.icon", input: "> input[type=\"hidden\"], > select", item: ".item", label: "> .label", remove: "> .label > .delete.icon", siblingLabel: ".label", menu: ".menu", message: ".message", menuIcon: ".dropdown.icon", search: "input.search, .menu > .search > input, .menu input.search", sizer: "> input.sizer", text: "> .text:not(.icon)", unselectable: ".disabled, .filtered" }, className: { active: "active", addition: "addition", animating: "animating", disabled: "disabled", empty: "empty", dropdown: "ui dropdown", filtered: "filtered", hidden: "hidden transition", item: "item", label: "ui label", loading: "loading", menu: "menu", message: "message", multiple: "multiple", placeholder: "default", sizer: "sizer", search: "search", selected: "selected", selection: "selection", upward: "upward", visible: "visible" } }, e.fn.dropdown.settings.templates = { dropdown(t) {
        let n = t.placeholder || !1,
            i = (t.values, ""); return i += "<i class=\"dropdown icon\"></i>", i += t.placeholder ? `<div class="default text">${n}</div>` : "<div class=\"text\"></div>", i += "<div class=\"menu\">", e.each(t.values, (e, t) => { i += t.disabled ? `<div class="disabled item" data-value="${t.value}">${t.name}</div>` : `<div class="item" data-value="${t.value}">${t.name}</div>`; }), i += "</div>";
    },
        menu(t, n) {
            let i = t[n.values] || {},
                o = ""; return e.each(i, (e, t) => { const i = t[n.text] ? `data-text="${t[n.text]}"` : ""; o += `<div class="${t[n.disabled] ? "disabled " : ""}item" data-value="${t[n.value]}"${i}>`, o += t[n.name], o += "</div>"; }), o;
        },
        label(e, t) { return `${t}<i class="delete icon"></i>`; },
        message(e) { return e; },
        addition(e) { return e; } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.embed = function (n) {
        let i,
            o = e(this),
            a = o.selector || "",
            r = (new Date()).getTime(),
            s = [],
            l = arguments[0],
            c = typeof l === "string",
            u = [].slice.call(arguments, 1); return o.each(function () {
                let d,
                    f = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.embed.settings, n) : e.extend({}, e.fn.embed.settings),
                    m = f.selector,
                    g = f.className,
                    v = f.sources,
                    p = f.error,
                    h = f.metadata,
                    b = f.namespace,
                    y = f.templates,
                    x = `.${b}`,
                    C = `module-${b}`,
                    w = (e(t), e(this)),
                    k = w.find(m.placeholder),
                    S = w.find(m.icon),
                    T = w.find(m.embed),
                    A = this,
                    R = w.data(C); d = { initialize() { d.debug("Initializing embed"), d.determine.autoplay(), d.create(), d.bind.events(), d.instantiate(); },
                        instantiate() { d.verbose("Storing instance of module", d), R = d, w.data(C, d); },
                        destroy() { d.verbose("Destroying previous instance of embed"), d.reset(), w.removeData(C).off(x); },
                        refresh() { d.verbose("Refreshing selector cache"), k = w.find(m.placeholder), S = w.find(m.icon), T = w.find(m.embed); },
                        bind: { events() { d.has.placeholder() && (d.debug("Adding placeholder events"), w.on(`click${x}`, m.placeholder, d.createAndShow).on(`click${x}`, m.icon, d.createAndShow)); } },
                        create() { d.get.placeholder() ? d.createPlaceholder() : d.createAndShow(); },
                        createPlaceholder(e) {
                            let t = d.get.icon(),
                                n = d.get.url(); d.generate.embed(n); e = e || d.get.placeholder(), w.html(y.placeholder(e, t)), d.debug("Creating placeholder for embed", e, t);
                        },
                        createEmbed(t) { d.refresh(), t = t || d.get.url(), T = e("<div/>").addClass(g.embed).html(d.generate.embed(t)).appendTo(w), f.onCreate.call(A, t), d.debug("Creating embed object", T); },
                        changeEmbed(e) { T.html(d.generate.embed(e)); },
                        createAndShow() { d.createEmbed(), d.show(); },
                        change(e, t, n) { d.debug("Changing video to ", e, t, n), w.data(h.source, e).data(h.id, t), n ? w.data(h.url, n) : w.removeData(h.url), d.has.embed() ? d.changeEmbed() : d.create(); },
                        reset() { d.debug("Clearing embed and showing placeholder"), d.remove.active(), d.remove.embed(), d.showPlaceholder(), f.onReset.call(A); },
                        show() { d.debug("Showing embed"), d.set.active(), f.onDisplay.call(A); },
                        hide() { d.debug("Hiding embed"), d.showPlaceholder(); },
                        showPlaceholder() { d.debug("Showing placeholder image"), d.remove.active(), f.onPlaceholderDisplay.call(A); },
                        get: { id() { return f.id || w.data(h.id); }, placeholder() { return f.placeholder || w.data(h.placeholder); }, icon() { return f.icon ? f.icon : void 0 !== w.data(h.icon) ? w.data(h.icon) : d.determine.icon(); }, source(e) { return f.source ? f.source : void 0 !== w.data(h.source) ? w.data(h.source) : d.determine.source(); }, type() { const e = d.get.source(); return void 0 !== v[e] && v[e].type; }, url() { return f.url ? f.url : void 0 !== w.data(h.url) ? w.data(h.url) : d.determine.url(); } },
                        determine: { autoplay() { d.should.autoplay() && (f.autoplay = !0); },
                            source(t) { let n = !1; return t = t || d.get.url(), t && e.each(v, (e, i) => { if (t.search(i.domain) !== -1) return n = e, !1; }), n; },
                            icon() { const e = d.get.source(); return void 0 !== v[e] && v[e].icon; },
                            url() {
                                let e,
                                    t = f.id || w.data(h.id),
                                    n = f.source || w.data(h.source); return e = void 0 !== v[n] && v[n].url.replace("{id}", t), e && w.data(h.url, e), e;
                            } },
                        set: { active() { w.addClass(g.active); } },
                        remove: { active() { w.removeClass(g.active); }, embed() { T.empty(); } },
                        encode: { parameters(e) {
                            let t,
                                n = []; for (t in e)n.push(`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`); return n.join("&amp;");
                        } },
                        generate: { embed(e) {
                            d.debug("Generating embed html"); let t,
                                n,
                                i = d.get.source(); return e = d.get.url(e), e ? (n = d.generate.parameters(i), t = y.iframe(e, n)) : d.error(p.noURL, w), t;
                        },
                            parameters(t, n) { let i = v[t] && void 0 !== v[t].parameters ? v[t].parameters(f) : {}; return n = n || f.parameters, n && (i = e.extend({}, i, n)), i = f.onEmbed(i), d.encode.parameters(i); } },
                        has: { embed() { return T.length > 0; }, placeholder() { return f.placeholder || w.data(h.placeholder); } },
                        should: { autoplay() { return f.autoplay === "auto" ? f.placeholder || void 0 !== w.data(h.placeholder) : f.autoplay; } },
                        is: { video() { return d.get.type() == "video"; } },
                        setting(t, n) { if (d.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; d[t] = n; } },
                        debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
                        verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
                        error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; f.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: A, "Execution Time": n })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
                        },
                            display() {
                                let t = `${f.name}:`,
                                    n = 0; r = !1, clearTimeout(d.performance.timer), e.each(s, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, a && (t += ` '${a}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, n, o) {
                            let a,
                                r,
                                s,
                                l = R; return n = n || u, o = A || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (d.error(p.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r;
                        } }, c ? (void 0 === R && d.initialize(), d.invoke(l)) : (void 0 !== R && R.invoke("destroy"), d.initialize());
            }), void 0 !== i ? i : this;
    }, e.fn.embed.settings = { name: "Embed", namespace: "embed", silent: !1, debug: !1, verbose: !1, performance: !0, icon: !1, source: !1, url: !1, id: !1, autoplay: "auto", color: "#444444", hd: !0, brandedUI: !1, parameters: !1, onDisplay() {}, onPlaceholderDisplay() {}, onReset() {}, onCreate(e) {}, onEmbed(e) { return e; }, metadata: { id: "id", icon: "icon", placeholder: "placeholder", source: "source", url: "url" }, error: { noURL: "No URL specified", method: "The method you called is not defined" }, className: { active: "active", embed: "embed" }, selector: { embed: ".embed", placeholder: ".placeholder", icon: ".icon" }, sources: { youtube: { name: "youtube", type: "video", icon: "video play", domain: "youtube.com", url: "//www.youtube.com/embed/{id}", parameters(e) { return { autohide: !e.brandedUI, autoplay: e.autoplay, color: e.color || void 0, hq: e.hd, jsapi: e.api, modestbranding: !e.brandedUI }; } }, vimeo: { name: "vimeo", type: "video", icon: "video play", domain: "vimeo.com", url: "//player.vimeo.com/video/{id}", parameters(e) { return { api: e.api, autoplay: e.autoplay, byline: e.brandedUI, color: e.color || void 0, portrait: e.brandedUI, title: e.brandedUI }; } } }, templates: { iframe(e, t) { let n = e; return t && (n += `?${t}`), `<iframe src="${n}" width="100%" height="100%" frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>`; }, placeholder(e, t) { let n = ""; return t && (n += `<i class="${t} icon"></i>`), e && (n += `<img class="placeholder" src="${e}">`), n; } }, api: !1, onPause() {}, onPlay() {}, onStop() {} };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.modal = function (i) {
        let o,
            a = e(this),
            r = e(t),
            s = e(n),
            l = e("body"),
            c = a.selector || "",
            u = (new Date()).getTime(),
            d = [],
            f = arguments[0],
            m = typeof f === "string",
            g = [].slice.call(arguments, 1),
            v = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return a.each(function () {
                let a,
                    p,
                    h,
                    b,
                    y,
                    x,
                    C,
                    w,
                    k,
                    S = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.modal.settings, i) : e.extend({}, e.fn.modal.settings),
                    T = S.selector,
                    A = S.className,
                    R = S.namespace,
                    P = S.error,
                    E = `.${R}`,
                    F = `module-${R}`,
                    O = e(this),
                    D = e(S.context),
                    q = O.find(T.close),
                    j = this,
                    z = O.data(F); k = { initialize() { k.verbose("Initializing dimmer", D), k.create.id(), k.create.dimmer(), k.refreshModals(), k.bind.events(), S.observeChanges && k.observeChanges(), k.instantiate(); },
                        instantiate() { k.verbose("Storing instance of modal"), z = k, O.data(F, z); },
                        create: { dimmer() {
                            let t = { debug: S.debug, dimmerName: "modals", duration: { show: S.duration, hide: S.duration } },
                                n = e.extend(!0, t, S.dimmerSettings); if (S.inverted && (n.variation = void 0 !== n.variation ? `${n.variation} inverted` : "inverted"), void 0 === e.fn.dimmer) return void k.error(P.dimmer); k.debug("Creating dimmer with settings", n), b = D.dimmer(n), S.detachable ? (k.verbose("Modal is detachable, moving content into dimmer"), b.dimmer("add content", O)) : k.set.undetached(), S.blurring && b.addClass(A.blurring), y = b.dimmer("get dimmer");
                        },
                            id() { C = (`${Math.random().toString(16)}000000000`).substr(2, 8), x = `.${C}`, k.verbose("Creating unique id for element", C); } },
                        destroy() { k.verbose("Destroying previous modal"), O.removeData(F).off(E), r.off(x), y.off(x), q.off(E), D.dimmer("destroy"); },
                        observeChanges() { "MutationObserver" in t && (w = new MutationObserver((e) => { k.debug("DOM tree modified, refreshing"), k.refresh(); }), w.observe(j, { childList: !0, subtree: !0 }), k.debug("Setting up mutation observer", w)); },
                        refresh() { k.remove.scrolling(), k.cacheSizes(), k.set.screenHeight(), k.set.type(), k.set.position(); },
                        refreshModals() { p = O.siblings(T.modal), a = p.add(O); },
                        attachEvents(t, n) { const i = e(t); n = e.isFunction(k[n]) ? k[n] : k.toggle, i.length > 0 ? (k.debug("Attaching modal events to element", t, n), i.off(E).on(`click${E}`, n)) : k.error(P.notFound, t); },
                        bind: { events() { k.verbose("Attaching events"), O.on(`click${E}`, T.close, k.event.close).on(`click${E}`, T.approve, k.event.approve).on(`click${E}`, T.deny, k.event.deny), r.on(`resize${x}`, k.event.resize); } },
                        get: { id() { return (`${Math.random().toString(16)}000000000`).substr(2, 8); } },
                        event: { approve() { if (S.onApprove.call(j, e(this)) === !1) return void k.verbose("Approve callback returned false cancelling hide"); k.hide(); },
                            deny() { if (S.onDeny.call(j, e(this)) === !1) return void k.verbose("Deny callback returned false cancelling hide"); k.hide(); },
                            close() { k.hide(); },
                            click(t) {
                                let i = e(t.target),
                                    o = i.closest(T.modal).length > 0,
                                    a = e.contains(n.documentElement, t.target); !o && a && (k.debug("Dimmer clicked, hiding all modals"), k.is.active() && (k.remove.clickaway(), S.allowMultiple ? k.hide() : k.hideAll()));
                            },
                            debounce(e, t) { clearTimeout(k.timer), k.timer = setTimeout(e, t); },
                            keyboard(e) { e.which == 27 && (S.closable ? (k.debug("Escape key pressed hiding modal"), k.hide()) : k.debug("Escape key pressed, but closable is set to false"), e.preventDefault()); },
                            resize() { b.dimmer("is active") && v(k.refresh); } },
                        toggle() { k.is.active() || k.is.animating() ? k.hide() : k.show(); },
                        show(t) { t = e.isFunction(t) ? t : function () {}, k.refreshModals(), k.showModal(t); },
                        hide(t) { t = e.isFunction(t) ? t : function () {}, k.refreshModals(), k.hideModal(t); },
                        showModal(t) { t = e.isFunction(t) ? t : function () {}, k.is.animating() || !k.is.active() ? (k.showDimmer(), k.cacheSizes(), k.set.position(), k.set.screenHeight(), k.set.type(), k.set.clickaway(), !S.allowMultiple && k.others.active() ? k.hideOthers(k.showModal) : (S.onShow.call(j), S.transition && void 0 !== e.fn.transition && O.transition("is supported") ? (k.debug("Showing modal with css animations"), O.transition({ debug: S.debug, animation: `${S.transition} in`, queue: S.queue, duration: S.duration, useFailSafe: !0, onComplete() { S.onVisible.apply(j), S.keyboardShortcuts && k.add.keyboardShortcuts(), k.save.focus(), k.set.active(), S.autofocus && k.set.autofocus(), t(); } })) : k.error(P.noTransition))) : k.debug("Modal is already visible"); },
                        hideModal(t, n) { if (t = e.isFunction(t) ? t : function () {}, k.debug("Hiding modal"), S.onHide.call(j, e(this)) === !1) return void k.verbose("Hide callback returned false cancelling hide"); (k.is.animating() || k.is.active()) && (S.transition && void 0 !== e.fn.transition && O.transition("is supported") ? (k.remove.active(), O.transition({ debug: S.debug, animation: `${S.transition} out`, queue: S.queue, duration: S.duration, useFailSafe: !0, onStart() { k.others.active() || n || k.hideDimmer(), S.keyboardShortcuts && k.remove.keyboardShortcuts(); }, onComplete() { S.onHidden.call(j), k.restore.focus(), t(); } })) : k.error(P.noTransition)); },
                        showDimmer() { b.dimmer("is animating") || !b.dimmer("is active") ? (k.debug("Showing dimmer"), b.dimmer("show")) : k.debug("Dimmer already visible"); },
                        hideDimmer() { if (!b.dimmer("is animating") && !b.dimmer("is active")) return void k.debug("Dimmer is not visible cannot hide"); b.dimmer("hide", () => { k.remove.clickaway(), k.remove.screenHeight(); }); },
                        hideAll(t) { const n = a.filter(`.${A.active}, .${A.animating}`); t = e.isFunction(t) ? t : function () {}, n.length > 0 && (k.debug("Hiding all visible modals"), k.hideDimmer(), n.modal("hide modal", t)); },
                        hideOthers(t) { const n = p.filter(`.${A.active}, .${A.animating}`); t = e.isFunction(t) ? t : function () {}, n.length > 0 && (k.debug("Hiding other modals", p), n.modal("hide modal", t, !0)); },
                        others: { active() { return p.filter(`.${A.active}`).length > 0; }, animating() { return p.filter(`.${A.animating}`).length > 0; } },
                        add: { keyboardShortcuts() { k.verbose("Adding keyboard shortcuts"), s.on(`keyup${E}`, k.event.keyboard); } },
                        save: { focus() { h = e(n.activeElement).blur(); } },
                        restore: { focus() { h && h.length > 0 && h.focus(); } },
                        remove: { active() { O.removeClass(A.active); }, clickaway() { S.closable && y.off(`click${x}`); }, bodyStyle() { l.attr("style") === "" && (k.verbose("Removing style attribute"), l.removeAttr("style")); }, screenHeight() { k.debug("Removing page height"), l.css("height", ""); }, keyboardShortcuts() { k.verbose("Removing keyboard shortcuts"), s.off(`keyup${E}`); }, scrolling() { b.removeClass(A.scrolling), O.removeClass(A.scrolling); } },
                        cacheSizes() { const i = O.outerHeight(); void 0 !== k.cache && i === 0 || (k.cache = { pageHeight: e(n).outerHeight(), height: i + S.offset, contextHeight: S.context == "body" ? e(t).height() : b.height() }), k.debug("Caching modal and container sizes", k.cache); },
                        can: { fit() { return k.cache.height + 2 * S.padding < k.cache.contextHeight; } },
                        is: { active() { return O.hasClass(A.active); }, animating() { return O.transition("is supported") ? O.transition("is animating") : O.is(":visible"); }, scrolling() { return b.hasClass(A.scrolling); }, modernBrowser() { return !(t.ActiveXObject || "ActiveXObject" in t); } },
                        set: { autofocus() {
                            let e = O.find("[tabindex], :input").filter(":visible"),
                                t = e.filter("[autofocus]"),
                                n = t.length > 0 ? t.first() : e.first(); n.length > 0 && n.focus();
                        },
                            clickaway() { S.closable && y.on(`click${x}`, k.event.click); },
                            screenHeight() { k.can.fit() ? l.css("height", "") : (k.debug("Modal is taller than page content, resizing page height"), l.css("height", k.cache.height + 2 * S.padding)); },
                            active() { O.addClass(A.active); },
                            scrolling() { b.addClass(A.scrolling), O.addClass(A.scrolling); },
                            type() { k.can.fit() ? (k.verbose("Modal fits on screen"), k.others.active() || k.others.animating() || k.remove.scrolling()) : (k.verbose("Modal cannot fit on screen setting to scrolling"), k.set.scrolling()); },
                            position() { k.verbose("Centering modal on page", k.cache), k.can.fit() ? O.css({ top: "", marginTop: -(k.cache.height / 2) }) : O.css({ marginTop: "", top: s.scrollTop() }); },
                            undetached() { b.addClass(A.undetached); } },
                        setting(t, n) { if (k.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, S, t); else { if (void 0 === n) return S[t]; e.isPlainObject(S[t]) ? e.extend(!0, S[t], n) : S[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, k, t); else { if (void 0 === n) return k[t]; k[t] = n; } },
                        debug() { !S.silent && S.debug && (S.performance ? k.performance.log(arguments) : (k.debug = Function.prototype.bind.call(console.info, console, `${S.name}:`), k.debug.apply(console, arguments))); },
                        verbose() { !S.silent && S.verbose && S.debug && (S.performance ? k.performance.log(arguments) : (k.verbose = Function.prototype.bind.call(console.info, console, `${S.name}:`), k.verbose.apply(console, arguments))); },
                        error() { S.silent || (k.error = Function.prototype.bind.call(console.error, console, `${S.name}:`), k.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; S.performance && (t = (new Date()).getTime(), i = u || t, n = t - i, u = t, d.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: j, "Execution Time": n })), clearTimeout(k.performance.timer), k.performance.timer = setTimeout(k.performance.display, 500);
                        },
                            display() {
                                let t = `${S.name}:`,
                                    n = 0; u = !1, clearTimeout(k.performance.timer), e.each(d, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, c && (t += ` '${c}'`), (void 0 !== console.group || void 0 !== console.table) && d.length > 0 && (console.groupCollapsed(t), console.table ? console.table(d) : e.each(d, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), d = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = z; return n = n || g, i = j || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, m ? (void 0 === z && k.initialize(), k.invoke(f)) : (void 0 !== z && z.invoke("destroy"), k.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.modal.settings = { name: "Modal", namespace: "modal", silent: !1, debug: !1, verbose: !1, performance: !0, observeChanges: !1, allowMultiple: !1, detachable: !0, closable: !0, autofocus: !0, inverted: !1, blurring: !1, dimmerSettings: { closable: !1, useCSS: !0 }, keyboardShortcuts: !0, context: "body", queue: !1, duration: 500, offset: 0, transition: "scale", padding: 50, onShow() {}, onVisible() {}, onHide() { return !0; }, onHidden() {}, onApprove() { return !0; }, onDeny() { return !0; }, selector: { close: "> .close", approve: ".actions .positive, .actions .approve, .actions .ok", deny: ".actions .negative, .actions .deny, .actions .cancel", modal: ".ui.modal" }, error: { dimmer: "UI Dimmer, a required component is not included in this page", method: "The method you called is not defined.", notFound: "The element you specified could not be found" }, className: { active: "active", animating: "animating", blurring: "blurring", scrolling: "scrolling", undetached: "undetached" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.nag = function (n) {
        let i,
            o = e(this),
            a = o.selector || "",
            r = (new Date()).getTime(),
            s = [],
            l = arguments[0],
            c = typeof l === "string",
            u = [].slice.call(arguments, 1); return o.each(function () {
                let o,
                    d = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.nag.settings, n) : e.extend({}, e.fn.nag.settings),
                    f = (d.className, d.selector),
                    m = d.error,
                    g = d.namespace,
                    v = `.${g}`,
                    p = `${g}-module`,
                    h = e(this),
                    b = (h.find(f.close), e(d.context ? d.context : "body")),
                    y = this,
                    x = h.data(p); t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame; o = { initialize() { o.verbose("Initializing element"), h.on(`click${v}`, f.close, o.dismiss).data(p, o), d.detachable && h.parent()[0] !== b[0] && h.detach().prependTo(b), d.displayTime > 0 && setTimeout(o.hide, d.displayTime), o.show(); },
                        destroy() { o.verbose("Destroying instance"), h.removeData(p).off(v); },
                        show() { o.should.show() && !h.is(":visible") && (o.debug("Showing nag", d.animation.show), d.animation.show == "fade" ? h.fadeIn(d.duration, d.easing) : h.slideDown(d.duration, d.easing)); },
                        hide() { o.debug("Showing nag", d.animation.hide), d.animation.show == "fade" ? h.fadeIn(d.duration, d.easing) : h.slideUp(d.duration, d.easing); },
                        onHide() { o.debug("Removing nag", d.animation.hide), h.remove(), d.onHide && d.onHide(); },
                        dismiss(e) { d.storageMethod && o.storage.set(d.key, d.value), o.hide(), e.stopImmediatePropagation(), e.preventDefault(); },
                        should: { show() { return d.persist ? (o.debug("Persistent nag is set, can show nag"), !0) : o.storage.get(d.key) != d.value.toString() ? (o.debug("Stored value is not set, can show nag", o.storage.get(d.key)), !0) : (o.debug("Stored value is set, cannot show nag", o.storage.get(d.key)), !1); } },
                        get: { storageOptions() { const e = {}; return d.expires && (e.expires = d.expires), d.domain && (e.domain = d.domain), d.path && (e.path = d.path), e; } },
                        clear() { o.storage.remove(d.key); },
                        storage: { set(n, i) { const a = o.get.storageOptions(); if (d.storageMethod == "localstorage" && void 0 !== t.localStorage)t.localStorage.setItem(n, i), o.debug("Value stored using local storage", n, i); else if (d.storageMethod == "sessionstorage" && void 0 !== t.sessionStorage)t.sessionStorage.setItem(n, i), o.debug("Value stored using session storage", n, i); else { if (void 0 === e.cookie) return void o.error(m.noCookieStorage); e.cookie(n, i, a), o.debug("Value stored using cookie", n, i, a); } }, get(n, i) { let a; return d.storageMethod == "localstorage" && void 0 !== t.localStorage ? a = t.localStorage.getItem(n) : d.storageMethod == "sessionstorage" && void 0 !== t.sessionStorage ? a = t.sessionStorage.getItem(n) : void 0 !== e.cookie ? a = e.cookie(n) : o.error(m.noCookieStorage), a != "undefined" && a != "null" && void 0 !== a && a !== null || (a = void 0), a; }, remove(n) { const i = o.get.storageOptions(); d.storageMethod == "localstorage" && void 0 !== t.localStorage ? t.localStorage.removeItem(n) : d.storageMethod == "sessionstorage" && void 0 !== t.sessionStorage ? t.sessionStorage.removeItem(n) : void 0 !== e.cookie ? e.removeCookie(n, i) : o.error(m.noStorage); } },
                        setting(t, n) { if (o.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; e.isPlainObject(d[t]) ? e.extend(!0, d[t], n) : d[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, o, t); else { if (void 0 === n) return o[t]; o[t] = n; } },
                        debug() { !d.silent && d.debug && (d.performance ? o.performance.log(arguments) : (o.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), o.debug.apply(console, arguments))); },
                        verbose() { !d.silent && d.verbose && d.debug && (d.performance ? o.performance.log(arguments) : (o.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), o.verbose.apply(console, arguments))); },
                        error() { d.silent || (o.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), o.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; d.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: y, "Execution Time": n })), clearTimeout(o.performance.timer), o.performance.timer = setTimeout(o.performance.display, 500);
                        },
                            display() {
                                let t = `${d.name}:`,
                                    n = 0; r = !1, clearTimeout(o.performance.timer), e.each(s, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, a && (t += ` '${a}'`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, n, a) {
                            let r,
                                s,
                                l,
                                c = x; return n = n || u, a = y || a, typeof t === "string" && void 0 !== c && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (n, i) => { const a = n != r ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(c[a]) && n != r)c = c[a]; else { if (void 0 !== c[a]) return s = c[a], !1; if (!e.isPlainObject(c[i]) || n == r) return void 0 !== c[i] ? (s = c[i], !1) : (o.error(m.method, t), !1); c = c[i]; } })), e.isFunction(s) ? l = s.apply(a, n) : void 0 !== s && (l = s), e.isArray(i) ? i.push(l) : void 0 !== i ? i = [i, l] : void 0 !== l && (i = l), s;
                        } }, c ? (void 0 === x && o.initialize(), o.invoke(l)) : (void 0 !== x && x.invoke("destroy"), o.initialize());
            }), void 0 !== i ? i : this;
    }, e.fn.nag.settings = { name: "Nag", silent: !1, debug: !1, verbose: !1, performance: !0, namespace: "Nag", persist: !1, displayTime: 0, animation: { show: "slide", hide: "slide" }, context: !1, detachable: !1, expires: 30, domain: !1, path: "/", storageMethod: "cookie", key: "nag", value: "dismiss", error: { noCookieStorage: "$.cookie is not included. A storage solution is required.", noStorage: "Neither $.cookie or store is defined. A storage solution is required for storing state", method: "The method you called is not defined." }, className: { bottom: "bottom", fixed: "fixed" }, selector: { close: ".close.icon" }, speed: 500, easing: "easeOutQuad", onHide() {} }, e.extend(e.easing, { easeOutQuad(e, t, n, i, o) { return -i * (t /= o) * (t - 2) + n; } });
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.popup = function (i) {
        let o,
            a = e(this),
            r = e(n),
            s = e(t),
            l = e("body"),
            c = a.selector || "",
            u = (new Date()).getTime(),
            d = [],
            f = arguments[0],
            m = typeof f === "string",
            g = [].slice.call(arguments, 1); return a.each(function () {
                let a,
                    v,
                    p,
                    h,
                    b,
                    y,
                    x = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.popup.settings, i) : e.extend({}, e.fn.popup.settings),
                    C = x.selector,
                    w = x.className,
                    k = x.error,
                    S = x.metadata,
                    T = x.namespace,
                    A = `.${x.namespace}`,
                    R = `module-${T}`,
                    P = e(this),
                    E = e(x.context),
                    F = e(x.scrollContext),
                    O = e(x.boundary),
                    D = x.target ? e(x.target) : P,
                    q = 0,
                    j = !1,
                    z = !1,
                    I = this,
                    M = P.data(R); y = { initialize() { y.debug("Initializing", P), y.createID(), y.bind.events(), !y.exists() && x.preserve && y.create(), x.observeChanges && y.observeChanges(), y.instantiate(); },
                        instantiate() { y.verbose("Storing instance", y), M = y, P.data(R, M); },
                        observeChanges() { "MutationObserver" in t && (p = new MutationObserver(y.event.documentChanged), p.observe(n, { childList: !0, subtree: !0 }), y.debug("Setting up mutation observer", p)); },
                        refresh() { x.popup ? a = e(x.popup).eq(0) : x.inline && (a = D.nextAll(C.popup).eq(0), x.popup = a), x.popup ? (a.addClass(w.loading), v = y.get.offsetParent(), a.removeClass(w.loading), x.movePopup && y.has.popup() && y.get.offsetParent(a)[0] !== v[0] && (y.debug("Moving popup to the same offset parent as activating element"), a.detach().appendTo(v))) : v = x.inline ? y.get.offsetParent(D) : y.has.popup() ? y.get.offsetParent(a) : l, v.is("html") && v[0] !== l[0] && (y.debug("Setting page as offset parent"), v = l), y.get.variation() && y.set.variation(); },
                        reposition() { y.refresh(), y.set.position(); },
                        destroy() { y.debug("Destroying previous module"), p && p.disconnect(), a && !x.preserve && y.removePopup(), clearTimeout(y.hideTimer), clearTimeout(y.showTimer), y.unbind.close(), y.unbind.events(), P.removeData(R); },
                        event: { start(t) {
                            const n = e.isPlainObject(x.delay) ? x.delay.show : x.delay
;clearTimeout(y.hideTimer), z || (y.showTimer = setTimeout(y.show, n));
                        },
                            end() { const t = e.isPlainObject(x.delay) ? x.delay.hide : x.delay; clearTimeout(y.showTimer), y.hideTimer = setTimeout(y.hide, t); },
                            touchstart(e) { z = !0, y.show(); },
                            resize() { y.is.visible() && y.set.position(); },
                            documentChanged(t) { [].forEach.call(t, (t) => { t.removedNodes && [].forEach.call(t.removedNodes, (t) => { (t == I || e(t).find(I).length > 0) && (y.debug("Element removed from DOM, tearing down events"), y.destroy()); }); }); },
                            hideGracefully(t) {
                                let i = e(t.target),
                                    o = e.contains(n.documentElement, t.target),
                                    a = i.closest(C.popup).length > 0; t && !a && o ? (y.debug("Click occurred outside popup hiding popup"), y.hide()) : y.debug("Click was inside popup, keeping popup open");
                            } },
                        create() {
                            let t = y.get.html(),
                                n = y.get.title(),
                                i = y.get.content(); t || i || n ? (y.debug("Creating pop-up html"), t || (t = x.templates.popup({ title: n, content: i })), a = e("<div/>").addClass(w.popup).data(S.activator, P).html(t), x.inline ? (y.verbose("Inserting popup element inline", a), a.insertAfter(P)) : (y.verbose("Appending popup element to body", a), a.appendTo(E)), y.refresh(), y.set.variation(), x.hoverable && y.bind.popup(), x.onCreate.call(a, I)) : D.next(C.popup).length !== 0 ? (y.verbose("Pre-existing popup found"), x.inline = !0, x.popup = D.next(C.popup).data(S.activator, P), y.refresh(), x.hoverable && y.bind.popup()) : x.popup ? (e(x.popup).data(S.activator, P), y.verbose("Used popup specified in settings"), y.refresh(), x.hoverable && y.bind.popup()) : y.debug("No content specified skipping display", I);
                        },
                        createID() { b = (`${Math.random().toString(16)}000000000`).substr(2, 8), h = `.${b}`, y.verbose("Creating unique id for element", b); },
                        toggle() { y.debug("Toggling pop-up"), y.is.hidden() ? (y.debug("Popup is hidden, showing pop-up"), y.unbind.close(), y.show()) : (y.debug("Popup is visible, hiding pop-up"), y.hide()); },
                        show(e) { if (e = e || function () {}, y.debug("Showing pop-up", x.transition), y.is.hidden() && (!y.is.active() || !y.is.dropdown())) { if (y.exists() || y.create(), x.onShow.call(a, I) === !1) return void y.debug("onShow callback returned false, cancelling popup animation"); x.preserve || x.popup || y.refresh(), a && y.set.position() && (y.save.conditions(), x.exclusive && y.hideAll(), y.animate.show(e)); } },
                        hide(e) { if (e = e || function () {}, y.is.visible() || y.is.animating()) { if (x.onHide.call(a, I) === !1) return void y.debug("onHide callback returned false, cancelling popup animation"); y.remove.visible(), y.unbind.close(), y.restore.conditions(), y.animate.hide(e); } },
                        hideAll() { e(C.popup).filter(`.${w.visible}`).each(function () { e(this).data(S.activator).popup("hide"); }); },
                        exists() { return !!a && (x.inline || x.popup ? y.has.popup() : a.closest(E).length >= 1); },
                        removePopup() { y.has.popup() && !x.popup && (y.debug("Removing popup", a), a.remove(), a = void 0, x.onRemove.call(a, I)); },
                        save: { conditions() { y.cache = { title: P.attr("title") }, y.cache.title && P.removeAttr("title"), y.verbose("Saving original attributes", y.cache.title); } },
                        restore: { conditions() { return y.cache && y.cache.title && (P.attr("title", y.cache.title), y.verbose("Restoring original attributes", y.cache.title)), !0; } },
                        supports: { svg() { return void 0 === typeof SVGGraphicsElement; } },
                        animate: { show(t) { t = e.isFunction(t) ? t : function () {}, x.transition && void 0 !== e.fn.transition && P.transition("is supported") ? (y.set.visible(), a.transition({ animation: `${x.transition} in`, queue: !1, debug: x.debug, verbose: x.verbose, duration: x.duration, onComplete() { y.bind.close(), t.call(a, I), x.onVisible.call(a, I); } })) : y.error(k.noTransition); }, hide(t) { if (t = e.isFunction(t) ? t : function () {}, y.debug("Hiding pop-up"), x.onHide.call(a, I) === !1) return void y.debug("onHide callback returned false, cancelling popup animation"); x.transition && void 0 !== e.fn.transition && P.transition("is supported") ? a.transition({ animation: `${x.transition} out`, queue: !1, duration: x.duration, debug: x.debug, verbose: x.verbose, onComplete() { y.reset(), t.call(a, I), x.onHidden.call(a, I); } }) : y.error(k.noTransition); } },
                        change: { content(e) { a.html(e); } },
                        get: { html() { return P.removeData(S.html), P.data(S.html) || x.html; },
                            title() { return P.removeData(S.title), P.data(S.title) || x.title; },
                            content() { return P.removeData(S.content), P.data(S.content) || P.attr("title") || x.content; },
                            variation() { return P.removeData(S.variation), P.data(S.variation) || x.variation; },
                            popup() { return a; },
                            popupOffset() { return a.offset(); },
                            calculations() {
                                let e,
                                    n = D[0],
                                    i = O[0] == t,
                                    o = x.inline || x.popup && x.movePopup ? D.position() : D.offset(),
                                    r = i ? { top: 0, left: 0 } : O.offset(),
                                    l = {},
                                    c = i ? { top: s.scrollTop(), left: s.scrollLeft() } : { top: 0, left: 0 }; return l = { target: { element: D[0], width: D.outerWidth(), height: D.outerHeight(), top: o.top, left: o.left, margin: {} }, popup: { width: a.outerWidth(), height: a.outerHeight() }, parent: { width: v.outerWidth(), height: v.outerHeight() }, screen: { top: r.top, left: r.left, scroll: { top: c.top, left: c.left }, width: O.width(), height: O.height() } }, x.setFluidWidth && y.is.fluid() && (l.container = { width: a.parent().outerWidth() }, l.popup.width = l.container.width), l.target.margin.top = x.inline ? parseInt(t.getComputedStyle(n).getPropertyValue("margin-top"), 10) : 0, l.target.margin.left = x.inline ? y.is.rtl() ? parseInt(t.getComputedStyle(n).getPropertyValue("margin-right"), 10) : parseInt(t.getComputedStyle(n).getPropertyValue("margin-left"), 10) : 0, e = l.screen, l.boundary = { top: e.top + e.scroll.top, bottom: e.top + e.scroll.top + e.height, left: e.left + e.scroll.left, right: e.left + e.scroll.left + e.width }, l;
                            },
                            id() { return b; },
                            startEvent() { return x.on == "hover" ? "mouseenter" : x.on == "focus" && "focus"; },
                            scrollEvent() { return "scroll"; },
                            endEvent() { return x.on == "hover" ? "mouseleave" : x.on == "focus" && "blur"; },
                            distanceFromBoundary(e, t) {
                                let n,
                                    i,
                                    o = {}; return t = t || y.get.calculations(), n = t.popup, i = t.boundary, e && (o = { top: e.top - i.top, left: e.left - i.left, right: i.right - (e.left + n.width), bottom: i.bottom - (e.top + n.height) }, y.verbose("Distance from boundaries determined", e, o)), o;
                            },
                            offsetParent(t) {
                                let n = void 0 !== t ? t[0] : P[0],
                                    i = n.parentNode,
                                    o = e(i); if (i) for (let a = o.css("transform") === "none", r = o.css("position") === "static", s = o.is("html"); i && !s && r && a;)i = i.parentNode, o = e(i), a = o.css("transform") === "none", r = o.css("position") === "static", s = o.is("html"); return o && o.length > 0 ? o : e();
                            },
                            positions() { return { "top left": !1, "top center": !1, "top right": !1, "bottom left": !1, "bottom center": !1, "bottom right": !1, "left center": !1, "right center": !1 }; },
                            nextPosition(e) {
                                let t = e.split(" "),
                                    n = t[0],
                                    i = t[1],
                                    o = { top: "bottom", bottom: "top", left: "right", right: "left" },
                                    a = { left: "center", center: "right", right: "left" },
                                    r = { "top left": "top center", "top center": "top right", "top right": "right center", "right center": "bottom right", "bottom right": "bottom center", "bottom center": "bottom left", "bottom left": "left center", "left center": "top left" },
                                    s = n == "top" || n == "bottom",
                                    l = !1,
                                    c = !1,
                                    u = !1; return j || (y.verbose("All available positions available"), j = y.get.positions()), y.debug("Recording last position tried", e), j[e] = !0, x.prefer === "opposite" && (u = [o[n], i], u = u.join(" "), l = j[u] === !0, y.debug("Trying opposite strategy", u)), x.prefer === "adjacent" && s && (u = [n, a[i]], u = u.join(" "), c = j[u] === !0, y.debug("Trying adjacent strategy", u)), (c || l) && (y.debug("Using backup position", u), u = r[e]), u;
                            } },
                        set: { position(e, t) {
                            if (D.length === 0 || a.length === 0) return void y.error(k.notFound); let n,
                                i,
                                o,
                                r,
                                s,
                                l,
                                c,
                                u; if (t = t || y.get.calculations(), e = e || P.data(S.position) || x.position, n = P.data(S.offset) || x.offset, i = x.distanceAway, o = t.target, r = t.popup, s = t.parent, o.width === 0 && o.height === 0 && !y.is.svg(o.element)) return y.debug("Popup target is hidden, no action taken"), !1; switch (x.inline && (y.debug("Adding margin to calculation", o.margin), e == "left center" || e == "right center" ? (n += o.margin.top, i += -o.margin.left) : e == "top left" || e == "top center" || e == "top right" ? (n += o.margin.left, i -= o.margin.top) : (n += o.margin.left, i += o.margin.top)), y.debug("Determining popup position from calculations", e, t), y.is.rtl() && (e = e.replace(/left|right/g, e => e == "left" ? "right" : "left"), y.debug("RTL: Popup position updated", e)), q == x.maxSearchDepth && typeof x.lastResort === "string" && (e = x.lastResort), e) { case "top left":l = { top: "auto", bottom: s.height - o.top + i, left: o.left + n, right: "auto" }; break; case "top center":l = { bottom: s.height - o.top + i, left: o.left + o.width / 2 - r.width / 2 + n, top: "auto", right: "auto" }; break; case "top right":l = { bottom: s.height - o.top + i, right: s.width - o.left - o.width - n, top: "auto", left: "auto" }; break; case "left center":l = { top: o.top + o.height / 2 - r.height / 2 + n, right: s.width - o.left + i, left: "auto", bottom: "auto" }; break; case "right center":l = { top: o.top + o.height / 2 - r.height / 2 + n, left: o.left + o.width + i, bottom: "auto", right: "auto" }; break; case "bottom left":l = { top: o.top + o.height + i, left: o.left + n, bottom: "auto", right: "auto" }; break; case "bottom center":l = { top: o.top + o.height + i, left: o.left + o.width / 2 - r.width / 2 + n, bottom: "auto", right: "auto" }; break; case "bottom right":l = { top: o.top + o.height + i, right: s.width - o.left - o.width - n, left: "auto", bottom: "auto" }; } if (void 0 === l && y.error(k.invalidPosition, e), y.debug("Calculated popup positioning values", l), a.css(l).removeClass(w.position).addClass(e).addClass(w.loading), c = y.get.popupOffset(), u = y.get.distanceFromBoundary(c, t), y.is.offstage(u, e)) { if (y.debug("Position is outside viewport", e), q < x.maxSearchDepth) return q++, e = y.get.nextPosition(e), y.debug("Trying new position", e), !!a && y.set.position(e, t); if (!x.lastResort) return y.debug("Popup could not find a position to display", a), y.error(k.cannotPlace, I), y.remove.attempts(), y.remove.loading(), y.reset(), x.onUnplaceable.call(a, I), !1; y.debug("No position found, showing with last position"); } return y.debug("Position is on stage", e), y.remove.attempts(), y.remove.loading(), x.setFluidWidth && y.is.fluid() && y.set.fluidWidth(t), !0;
                        },
                            fluidWidth(e) { e = e || y.get.calculations(), y.debug("Automatically setting element width to parent width", e.parent.width), a.css("width", e.container.width); },
                            variation(e) { (e = e || y.get.variation()) && y.has.popup() && (y.verbose("Adding variation to popup", e), a.addClass(e)); },
                            visible() { P.addClass(w.visible); } },
                        remove: { loading() { a.removeClass(w.loading); }, variation(e) { (e = e || y.get.variation()) && (y.verbose("Removing variation", e), a.removeClass(e)); }, visible() { P.removeClass(w.visible); }, attempts() { y.verbose("Resetting all searched positions"), q = 0, j = !1; } },
                        bind: { events() { y.debug("Binding popup events to module"), x.on == "click" && P.on(`click${A}`, y.toggle), x.on == "hover" && P.on(`touchstart${A}`, y.event.touchstart), y.get.startEvent() && P.on(y.get.startEvent() + A, y.event.start).on(y.get.endEvent() + A, y.event.end), x.target && y.debug("Target set to element", D), s.on(`resize${h}`, y.event.resize); }, popup() { y.verbose("Allowing hover events on popup to prevent closing"), a && y.has.popup() && a.on(`mouseenter${A}`, y.event.start).on(`mouseleave${A}`, y.event.end); }, close() { (x.hideOnScroll === !0 || x.hideOnScroll == "auto" && x.on != "click") && F.one(y.get.scrollEvent() + h, y.event.hideGracefully), x.on == "hover" && z && (y.verbose("Binding popup close event to document"), r.on(`touchstart${h}`, (e) => { y.verbose("Touched away from popup"), y.event.hideGracefully.call(I, e); })), x.on == "click" && x.closable && (y.verbose("Binding popup close event to document"), r.on(`click${h}`, (e) => { y.verbose("Clicked away from popup"), y.event.hideGracefully.call(I, e); })); } },
                        unbind: { events() { s.off(h), P.off(A); }, close() { r.off(h), F.off(h); } },
                        has: { popup() { return a && a.length > 0; } },
                        is: { offstage(t, n) { const i = []; return e.each(t, (e, t) => { t < -x.jitter && (y.debug("Position exceeds allowable distance from edge", e, t, n), i.push(e)); }), i.length > 0; }, svg(e) { return y.supports.svg() && e instanceof SVGGraphicsElement; }, active() { return P.hasClass(w.active); }, animating() { return void 0 !== a && a.hasClass(w.animating); }, fluid() { return void 0 !== a && a.hasClass(w.fluid); }, visible() { return void 0 !== a && a.hasClass(w.visible); }, dropdown() { return P.hasClass(w.dropdown); }, hidden() { return !y.is.visible(); }, rtl() { return P.css("direction") == "rtl"; } },
                        reset() { y.remove.visible(), x.preserve ? void 0 !== e.fn.transition && a.transition("remove transition") : y.removePopup(); },
                        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, x, t); else { if (void 0 === n) return x[t]; x[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, y, t); else { if (void 0 === n) return y[t]; y[t] = n; } },
                        debug() { !x.silent && x.debug && (x.performance ? y.performance.log(arguments) : (y.debug = Function.prototype.bind.call(console.info, console, `${x.name}:`), y.debug.apply(console, arguments))); },
                        verbose() { !x.silent && x.verbose && x.debug && (x.performance ? y.performance.log(arguments) : (y.verbose = Function.prototype.bind.call(console.info, console, `${x.name}:`), y.verbose.apply(console, arguments))); },
                        error() { x.silent || (y.error = Function.prototype.bind.call(console.error, console, `${x.name}:`), y.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; x.performance && (t = (new Date()).getTime(), i = u || t, n = t - i, u = t, d.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: I, "Execution Time": n })), clearTimeout(y.performance.timer), y.performance.timer = setTimeout(y.performance.display, 500);
                        },
                            display() {
                                let t = `${x.name}:`,
                                    n = 0; u = !1, clearTimeout(y.performance.timer), e.each(d, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, c && (t += ` '${c}'`), (void 0 !== console.group || void 0 !== console.table) && d.length > 0 && (console.groupCollapsed(t), console.table ? console.table(d) : e.each(d, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), d = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = M; return n = n || g, i = I || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, m ? (void 0 === M && y.initialize(), y.invoke(f)) : (void 0 !== M && M.invoke("destroy"), y.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.popup.settings = { name: "Popup",
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        namespace: "popup",
        observeChanges: !0,
        onCreate() {},
        onRemove() {},
        onShow() {},
        onVisible() {},
        onHide() {},
        onUnplaceable() {},
        onHidden() {},
        on: "hover",
        boundary: t,
        addTouchEvents: !0,
        position: "top left",
        variation: "",
        movePopup: !0,
        target: !1,
        popup: !1,
        inline: !1,
        preserve: !1,
        hoverable: !1,
        content: !1,
        html: !1,
        title: !1,
        closable: !0,
        hideOnScroll: "auto",
        exclusive: !1,
        context: "body",
        scrollContext: t,
        prefer: "opposite",
        lastResort: !1,
        delay: { show: 50, hide: 70 },
        setFluidWidth: !0,
        duration: 200,
        transition: "scale",
        distanceAway: 0,
        jitter: 2,
        offset: 0,
        maxSearchDepth: 15,
        error: { invalidPosition: "The position you specified is not a valid position", cannotPlace: "Popup does not fit within the boundaries of the viewport", method: "The method you called is not defined.", noTransition: "This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>", notFound: "The target or popup you specified does not exist on the page" },
        metadata: { activator: "activator", content: "content", html: "html", offset: "offset", position: "position", title: "title", variation: "variation" },
        className: { active: "active", animating: "animating", dropdown: "dropdown", fluid: "fluid", loading: "loading", popup: "ui popup", position: "top left center bottom right", visible: "visible" },
        selector: { popup: ".ui.popup" },
        templates: { escape(e) {
            let t = /[&<>"'`]/,
                n = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#x27;", "`": "&#x60;" },
                i = function (e) { return n[e]; }; return t.test(e) ? e.replace(/[&<>"'`]/g, i) : e;
        },
            popup(t) {
                let n = "",
                    i = e.fn.popup.settings.templates.escape; return void 0 !== typeof t && (void 0 !== typeof t.title && t.title && (t.title = i(t.title), n += `<div class="header">${t.title}</div>`), void 0 !== typeof t.content && t.content && (t.content = i(t.content), n += `<div class="content">${t.content}</div>`)), n;
            } } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(); void 0 !== t && t.Math == Math || (typeof self !== "undefined" && self.Math == Math ? self : Function("return this")()); e.fn.progress = function (t) {
        let i,
            o = e(this),
            a = o.selector || "",
            r = (new Date()).getTime(),
            s = [],
            l = arguments[0],
            c = typeof l === "string",
            u = [].slice.call(arguments, 1); return o.each(function () {
                let o,
                    d,
                    f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.progress.settings, t) : e.extend({}, e.fn.progress.settings),
                    m = f.className,
                    g = f.metadata,
                    v = f.namespace,
                    p = f.selector,
                    h = f.error,
                    b = `.${v}`,
                    y = `module-${v}`,
                    x = e(this),
                    C = e(this).find(p.bar),
                    w = e(this).find(p.progress),
                    k = e(this).find(p.label),
                    S = this,
                    T = x.data(y),
                    A = !1; d = { initialize() { d.debug("Initializing progress bar", f), d.set.duration(), d.set.transitionEvent(), d.read.metadata(), d.read.settings(), d.instantiate(); },
                        instantiate() { d.verbose("Storing instance of progress", d), T = d, x.data(y, d); },
                        destroy() { d.verbose("Destroying previous progress for", x), clearInterval(T.interval), d.remove.state(), x.removeData(y), T = void 0; },
                        reset() { d.remove.nextValue(), d.update.progress(0); },
                        complete() { (void 0 === d.percent || d.percent < 100) && (d.remove.progressPoll(), d.set.percent(100)); },
                        read: { metadata() { const e = { percent: x.data(g.percent), total: x.data(g.total), value: x.data(g.value) }; e.percent && (d.debug("Current percent value set from metadata", e.percent), d.set.percent(e.percent)), e.total && (d.debug("Total value set from metadata", e.total), d.set.total(e.total)), e.value && (d.debug("Current value set from metadata", e.value), d.set.value(e.value), d.set.progress(e.value)); }, settings() { f.total !== !1 && (d.debug("Current total set in settings", f.total), d.set.total(f.total)), f.value !== !1 && (d.debug("Current value set in settings", f.value), d.set.value(f.value), d.set.progress(d.value)), f.percent !== !1 && (d.debug("Current percent set in settings", f.percent), d.set.percent(f.percent)); } },
                        bind: { transitionEnd(e) { const t = d.get.transitionEnd(); C.one(t + b, function (t) { clearTimeout(d.failSafeTimer), e.call(this, t); }), d.failSafeTimer = setTimeout(() => { C.triggerHandler(t); }, f.duration + f.failSafeDelay), d.verbose("Adding fail safe timer", d.timer); } },
                        increment(e) {
                            let t,
                                n; d.has.total() ? (t = d.get.value(), e = e || 1, n = t + e) : (t = d.get.percent(), e = e || d.get.randomValue(), n = t + e, 100, d.debug("Incrementing percentage by", t, n)), n = d.get.normalizedValue(n), d.set.progress(n);
                        },
                        decrement(e) {
                            let t,
                                n,
                                i = d.get.total(); i ? (t = d.get.value(), e = e || 1, n = t - e, d.debug("Decrementing value by", e, t)) : (t = d.get.percent(), e = e || d.get.randomValue(), n = t - e, d.debug("Decrementing percentage by", e, t)), n = d.get.normalizedValue(n), d.set.progress(n);
                        },
                        has: { progressPoll() { return d.progressPoll; }, total() { return d.get.total() !== !1; } },
                        get: { text(e) {
                            let t = d.value || 0,
                                n = d.total || 0,
                                i = A ? d.get.displayPercent() : d.percent || 0,
                                o = d.total > 0 ? n - t : 100 - i; return e = e || "", e = e.replace("{value}", t).replace("{total}", n).replace("{left}", o).replace("{percent}", i), d.verbose("Adding variables to progress bar text", e), e;
                        },
                            normalizedValue(e) { if (e < 0) return d.debug("Value cannot decrement below 0"), 0; if (d.has.total()) { if (e > d.total) return d.debug("Value cannot increment above total", d.total), d.total; } else if (e > 100) return d.debug("Value cannot increment above 100 percent"), 100; return e; },
                            updateInterval() { return f.updateInterval == "auto" ? f.duration : f.updateInterval; },
                            randomValue() { return d.debug("Generating random increment percentage"), Math.floor(Math.random() * f.random.max + f.random.min); },
                            numericValue(e) { return typeof e === "string" ? e.replace(/[^\d.]/g, "") !== "" && +e.replace(/[^\d.]/g, "") : e; },
                            transitionEnd() {
                                let e,
                                    t = n.createElement("element"),
                                    i = { transition: "transitionend", OTransition: "oTransitionEnd", MozTransition: "transitionend", WebkitTransition: "webkitTransitionEnd" }; for (e in i) if (void 0 !== t.style[e]) return i[e];
                            },
                            displayPercent() {
                                let e = C.width(),
                                    t = x.width(),
                                    n = parseInt(C.css("min-width"), 10),
                                    i = e > n ? e / t * 100 : d.percent; return f.precision > 0 ? Math.round(i * (10 * f.precision)) / (10 * f.precision) : Math.round(i);
                            },
                            percent() { return d.percent || 0; },
                            value() { return d.nextValue || d.value || 0; },
                            total() { return d.total || !1; } },
                        create: { progressPoll() { d.progressPoll = setTimeout(() => { d.update.toNextValue(), d.remove.progressPoll(); }, d.get.updateInterval()); } },
                        is: { complete() { return d.is.success() || d.is.warning() || d.is.error(); }, success() { return x.hasClass(m.success); }, warning() { return x.hasClass(m.warning); }, error() { return x.hasClass(m.error); }, active() { return x.hasClass(m.active); }, visible() { return x.is(":visible"); } },
                        remove: { progressPoll() { d.verbose("Removing progress poll timer"), d.progressPoll && (clearTimeout(d.progressPoll), delete d.progressPoll); }, nextValue() { d.verbose("Removing progress value stored for next update"), delete d.nextValue; }, state() { d.verbose("Removing stored state"), delete d.total, delete d.percent, delete d.value; }, active() { d.verbose("Removing active state"), x.removeClass(m.active); }, success() { d.verbose("Removing success state"), x.removeClass(m.success); }, warning() { d.verbose("Removing warning state"), x.removeClass(m.warning); }, error() { d.verbose("Removing error state"), x.removeClass(m.error); } },
                        set: { barWidth(e) { e > 100 ? d.error(h.tooHigh, e) : e < 0 ? d.error(h.tooLow, e) : (C.css("width", `${e}%`), x.attr("data-percent", parseInt(e, 10))); }, duration(e) { e = e || f.duration, e = typeof e === "number" ? `${e}ms` : e, d.verbose("Setting progress bar transition duration", e), C.css({ "transition-duration": e }); }, percent(e) { e = typeof e === "string" ? +e.replace("%", "") : e, e = f.precision > 0 ? Math.round(e * (10 * f.precision)) / (10 * f.precision) : Math.round(e), d.percent = e, d.has.total() || (d.value = f.precision > 0 ? Math.round(e / 100 * d.total * (10 * f.precision)) / (10 * f.precision) : Math.round(e / 100 * d.total * 10) / 10, f.limitValues && (d.value = d.value > 100 ? 100 : d.value < 0 ? 0 : d.value)), d.set.barWidth(e), d.set.labelInterval(), d.set.labels(), f.onChange.call(S, e, d.value, d.total); }, labelInterval() { const t = function () { d.verbose("Bar finished animating, removing continuous label updates"), clearInterval(d.interval), A = !1, d.set.labels(); }; clearInterval(d.interval), d.bind.transitionEnd(t), A = !0, d.interval = setInterval(() => { e.contains(n.documentElement, S) || (clearInterval(d.interval), A = !1), d.set.labels(); }, f.framerate); }, labels() { d.verbose("Setting both bar progress and outer label text"), d.set.barLabel(), d.set.state(); }, label(e) { (e = e || "") && (e = d.get.text(e), d.verbose("Setting label to text", e), k.text(e)); }, state(e) { e = void 0 !== e ? e : d.percent, e === 100 ? f.autoSuccess && !(d.is.warning() || d.is.error() || d.is.success()) ? (d.set.success(), d.debug("Automatically triggering success at 100%")) : (d.verbose("Reached 100% removing active state"), d.remove.active(), d.remove.progressPoll()) : e > 0 ? (d.verbose("Adjusting active progress bar label", e), d.set.active()) : (d.remove.active(), d.set.label(f.text.active)); }, barLabel(e) { void 0 !== e ? w.text(d.get.text(e)) : f.label == "ratio" && d.total ? (d.verbose("Adding ratio to bar label"), w.text(d.get.text(f.text.ratio))) : f.label == "percent" && (d.verbose("Adding percentage to bar label"), w.text(d.get.text(f.text.percent))); }, active(e) { e = e || f.text.active, d.debug("Setting active state"), f.showActivity && !d.is.active() && x.addClass(m.active), d.remove.warning(), d.remove.error(), d.remove.success(), e = f.onLabelUpdate("active", e, d.value, d.total), e && d.set.label(e), d.bind.transitionEnd(() => { f.onActive.call(S, d.value, d.total); }); }, success(e) { e = e || f.text.success || f.text.active, d.debug("Setting success state"), x.addClass(m.success), d.remove.active(), d.remove.warning(), d.remove.error(), d.complete(), f.text.success ? (e = f.onLabelUpdate("success", e, d.value, d.total), d.set.label(e)) : (e = f.onLabelUpdate("active", e, d.value, d.total), d.set.label(e)), d.bind.transitionEnd(() => { f.onSuccess.call(S, d.total); }); }, warning(e) { e = e || f.text.warning, d.debug("Setting warning state"), x.addClass(m.warning), d.remove.active(), d.remove.success(), d.remove.error(), d.complete(), e = f.onLabelUpdate("warning", e, d.value, d.total), e && d.set.label(e), d.bind.transitionEnd(() => { f.onWarning.call(S, d.value, d.total); }); }, error(e) { e = e || f.text.error, d.debug("Setting error state"), x.addClass(m.error), d.remove.active(), d.remove.success(), d.remove.warning(), d.complete(), e = f.onLabelUpdate("error", e, d.value, d.total), e && d.set.label(e), d.bind.transitionEnd(() => { f.onError.call(S, d.value, d.total); }); }, transitionEvent() { o = d.get.transitionEnd(); }, total(e) { d.total = e; }, value(e) { d.value = e; }, progress(e) { d.has.progressPoll() ? (d.debug("Updated within interval, setting next update to use new value", e), d.set.nextValue(e)) : (d.debug("First update in progress update interval, immediately updating", e), d.update.progress(e), d.create.progressPoll()); }, nextValue(e) { d.nextValue = e; } },
                        update: { toNextValue() { const e = d.nextValue; e && (d.debug("Update interval complete using last updated value", e), d.update.progress(e), d.remove.nextValue()); }, progress(e) { let t; e = d.get.numericValue(e), e === !1 && d.error(h.nonNumeric, e), e = d.get.normalizedValue(e), d.has.total() ? (d.set.value(e), t = e / d.total * 100, d.debug("Calculating percent complete from total", t), d.set.percent(t)) : (t = e, d.debug("Setting value to exact percentage value", t), d.set.percent(t)); } },
                        setting(t, n) { if (d.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; d[t] = n; } },
                        debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
                        verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
                        error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; f.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: S, "Execution Time": n })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
                        },
                            display() {
                                let t = `${f.name}:`,
                                    n = 0; r = !1, clearTimeout(d.performance.timer), e.each(s, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, a && (t += ` '${a}'`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, n, o) {
                            let a,
                                r,
                                s,
                                l = T; return n = n || u, o = S || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (d.error(h.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r;
                        } }, c ? (void 0 === T && d.initialize(), d.invoke(l)) : (void 0 !== T && T.invoke("destroy"), d.initialize());
            }), void 0 !== i ? i : this;
    }, e.fn.progress.settings = { name: "Progress", namespace: "progress", silent: !1, debug: !1, verbose: !1, performance: !0, random: { min: 2, max: 5 }, duration: 300, updateInterval: "auto", autoSuccess: !0, showActivity: !0, limitValues: !0, label: "percent", precision: 0, framerate: 1e3 / 30, percent: !1, total: !1, value: !1, failSafeDelay: 100, onLabelUpdate(e, t, n, i) { return t; }, onChange(e, t, n) {}, onSuccess(e) {}, onActive(e, t) {}, onError(e, t) {}, onWarning(e, t) {}, error: { method: "The method you called is not defined.", nonNumeric: "Progress value is non numeric", tooHigh: "Value specified is above 100%", tooLow: "Value specified is below 0%" }, regExp: { variable: /\{\$*[A-z0-9]+\}/g }, metadata: { percent: "percent", total: "total", value: "value" }, selector: { bar: "> .bar", label: "> .label", progress: ".bar > .progress" }, text: { active: !1, error: !1, success: !1, warning: !1, percent: "{percent}%", ratio: "{value} of {total}" }, className: { active: "active", error: "error", success: "success", warning: "warning" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.rating = function (t) {
        let n,
            i = e(this),
            o = i.selector || "",
            a = (new Date()).getTime(),
            r = [],
            s = arguments[0],
            l = typeof s === "string",
            c = [].slice.call(arguments, 1); return i.each(function () {
                let u,
                    d,
                    f = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.rating.settings, t) : e.extend({}, e.fn.rating.settings),
                    m = f.namespace,
                    g = f.className,
                    v = f.metadata,
                    p = f.selector,
                    h = (f.error, `.${m}`),
                    b = `module-${m}`,
                    y = this,
                    x = e(this).data(b),
                    C = e(this),
                    w = C.find(p.icon); d = { initialize() { d.verbose("Initializing rating module", f), w.length === 0 && d.setup.layout(), f.interactive ? d.enable() : d.disable(), d.set.initialLoad(), d.set.rating(d.get.initialRating()), d.remove.initialLoad(), d.instantiate(); },
                        instantiate() { d.verbose("Instantiating module", f), x = d, C.data(b, d); },
                        destroy() { d.verbose("Destroying previous instance", x), d.remove.events(), C.removeData(b); },
                        refresh() { w = C.find(p.icon); },
                        setup: { layout() {
                            let t = d.get.maxRating(),
                                n = e.fn.rating.settings.templates.icon(t); d.debug("Generating icon html dynamically"), C.html(n), d.refresh();
                        } },
                        event: { mouseenter() { const t = e(this); t.nextAll().removeClass(g.selected), C.addClass(g.selected), t.addClass(g.selected).prevAll().addClass(g.selected); },
                            mouseleave() { C.removeClass(g.selected), w.removeClass(g.selected); },
                            click() {
                                let t = e(this),
                                    n = d.get.rating(),
                                    i = w.index(t) + 1; (f.clearable == "auto" ? w.length === 1 : f.clearable) && n == i ? d.clearRating() : d.set.rating(i);
                            } },
                        clearRating() { d.debug("Clearing current rating"), d.set.rating(0); },
                        bind: { events() { d.verbose("Binding events"), C.on(`mouseenter${h}`, p.icon, d.event.mouseenter).on(`mouseleave${h}`, p.icon, d.event.mouseleave).on(`click${h}`, p.icon, d.event.click); } },
                        remove: { events() { d.verbose("Removing events"), C.off(h); }, initialLoad() { u = !1; } },
                        enable() { d.debug("Setting rating to interactive mode"), d.bind.events(), C.removeClass(g.disabled); },
                        disable() { d.debug("Setting rating to read-only mode"), d.remove.events(), C.addClass(g.disabled); },
                        is: { initialLoad() { return u; } },
                        get: { initialRating() { return void 0 !== C.data(v.rating) ? (C.removeData(v.rating), C.data(v.rating)) : f.initialRating; }, maxRating() { return void 0 !== C.data(v.maxRating) ? (C.removeData(v.maxRating), C.data(v.maxRating)) : f.maxRating; }, rating() { const e = w.filter(`.${g.active}`).length; return d.verbose("Current rating retrieved", e), e; } },
                        set: { rating(e) {
                            let t = e - 1 >= 0 ? e - 1 : 0,
                                n = w.eq(t); C.removeClass(g.selected), w.removeClass(g.selected).removeClass(g.active), e > 0 && (d.verbose("Setting current rating to", e), n.prevAll().addBack().addClass(g.active)), d.is.initialLoad() || f.onRate.call(y, e);
                        },
                            initialLoad() { u = !0; } },
                        setting(t, n) { if (d.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === n) return d[t]; d[t] = n; } },
                        debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
                        verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
                        error() {
                            f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments));
                        },
                        performance: { log(e) {
                            let t,
                                n,
                                i; f.performance && (t = (new Date()).getTime(), i = a || t, n = t - i, a = t, r.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: y, "Execution Time": n })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
                        },
                            display() {
                                let t = `${f.name}:`,
                                    n = 0; a = !1, clearTimeout(d.performance.timer), e.each(r, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, o && (t += ` '${o}'`), i.length > 1 && (t += ` (${i.length})`), (void 0 !== console.group || void 0 !== console.table) && r.length > 0 && (console.groupCollapsed(t), console.table ? console.table(r) : e.each(r, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), r = [];
                            } },
                        invoke(t, i, o) {
                            let a,
                                r,
                                s,
                                l = x; return i = i || c, o = y || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, i) : void 0 !== r && (s = r), e.isArray(n) ? n.push(s) : void 0 !== n ? n = [n, s] : void 0 !== s && (n = s), r;
                        } }, l ? (void 0 === x && d.initialize(), d.invoke(s)) : (void 0 !== x && x.invoke("destroy"), d.initialize());
            }), void 0 !== n ? n : this;
    }, e.fn.rating.settings = { name: "Rating", namespace: "rating", slent: !1, debug: !1, verbose: !1, performance: !0, initialRating: 0, interactive: !0, maxRating: 4, clearable: "auto", fireOnInit: !1, onRate(e) {}, error: { method: "The method you called is not defined", noMaximum: "No maximum rating specified. Cannot generate HTML automatically" }, metadata: { rating: "rating", maxRating: "maxRating" }, className: { active: "active", disabled: "disabled", selected: "selected", loading: "loading" }, selector: { icon: ".icon" }, templates: { icon(e) { for (var t = 1, n = ""; t <= e;)n += "<i class=\"icon\"></i>", t++; return n; } } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.search = function (i) {
        let o,
            a = e(this),
            r = a.selector || "",
            s = (new Date()).getTime(),
            l = [],
            c = arguments[0],
            u = typeof c === "string",
            d = [].slice.call(arguments, 1); return e(this).each(function () {
                let f,
                    m = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.search.settings, i) : e.extend({}, e.fn.search.settings),
                    g = m.className,
                    v = m.metadata,
                    p = m.regExp,
                    h = m.fields,
                    b = m.selector,
                    y = m.error,
                    x = m.namespace,
                    C = `.${x}`,
                    w = `${x}-module`,
                    k = e(this),
                    S = k.find(b.prompt),
                    T = k.find(b.searchButton),
                    A = k.find(b.results),
                    R = k.find(b.result),
                    P = k.find(b.category),
                    E = this,
                    F = k.data(w),
                    O = !1,
                    D = !1; f = { initialize() { f.verbose("Initializing module"), f.determine.searchFields(), f.bind.events(), f.set.type(), f.create.results(), f.instantiate(); },
                        instantiate() { f.verbose("Storing instance of module", f), F = f, k.data(w, f); },
                        destroy() { f.verbose("Destroying instance"), k.off(C).removeData(w); },
                        refresh() { f.debug("Refreshing selector cache"), S = k.find(b.prompt), T = k.find(b.searchButton), P = k.find(b.category), A = k.find(b.results), R = k.find(b.result); },
                        refreshResults() { A = k.find(b.results), R = k.find(b.result); },
                        bind: { events() { f.verbose("Binding events to search"), m.automatic && (k.on(f.get.inputEvent() + C, b.prompt, f.event.input), S.attr("autocomplete", "off")), k.on(`focus${C}`, b.prompt, f.event.focus).on(`blur${C}`, b.prompt, f.event.blur).on(`keydown${C}`, b.prompt, f.handleKeyboard).on(`click${C}`, b.searchButton, f.query).on(`mousedown${C}`, b.results, f.event.result.mousedown).on(`mouseup${C}`, b.results, f.event.result.mouseup).on(`click${C}`, b.result, f.event.result.click); } },
                        determine: { searchFields() { i && void 0 !== i.searchFields && (m.searchFields = i.searchFields); } },
                        event: { input() { clearTimeout(f.timer), f.timer = setTimeout(f.query, m.searchDelay); },
                            focus() { f.set.focus(), m.searchOnFocus && f.has.minimumCharacters() && f.query(() => { f.can.show() && f.showResults(); }); },
                            blur(e) {
                                let t = n.activeElement === this,
                                    i = function () { f.cancel.query(), f.remove.focus(), f.timer = setTimeout(f.hideResults, m.hideDelay); }; t || (D = !1, f.resultsClicked ? (f.debug("Determining if user action caused search to close"), k.one(`click.close${C}`, b.results, (e) => { if (f.is.inMessage(e) || O) return void S.focus(); O = !1, f.is.animating() || f.is.hidden() || i(); })) : (f.debug("Input blurred without user action, closing results"), i()));
                            },
                            result: { mousedown() { f.resultsClicked = !0; },
                                mouseup() { f.resultsClicked = !1; },
                                click(n) {
                                    f.debug("Search result selected"); let i = e(this),
                                        o = i.find(b.title).eq(0),
                                        a = i.is("a[href]") ? i : i.find("a[href]").eq(0),
                                        r = a.attr("href") || !1,
                                        s = a.attr("target") || !1,
                                        l = (o.html(), o.length > 0 && o.text()),
                                        c = f.get.results(),
                                        u = i.data(v.result) || f.get.result(l, c); if (e.isFunction(m.onSelect) && m.onSelect.call(E, u, c) === !1) return f.debug("Custom onSelect callback cancelled default select action"), void (O = !0); f.hideResults(), l && f.set.value(l), r && (f.verbose("Opening search link found in result", a), s == "_blank" || n.ctrlKey ? t.open(r) : t.location.href = r);
                                } } },
                        handleKeyboard(e) {
                            let t,
                                n = k.find(b.result),
                                i = k.find(b.category),
                                o = n.filter(`.${g.active}`),
                                a = n.index(o),
                                r = n.length,
                                s = o.length > 0,
                                l = e.which,
                                c = { backspace: 8, enter: 13, escape: 27, upArrow: 38, downArrow: 40 }; if (l == c.escape && (f.verbose("Escape key pressed, blurring search field"), f.hideResults(), D = !0), f.is.visible()) if (l == c.enter) { if (f.verbose("Enter key pressed, selecting active result"), n.filter(`.${g.active}`).length > 0) return f.event.result.click.call(n.filter(`.${g.active}`), e), e.preventDefault(), !1; } else l == c.upArrow && s ? (f.verbose("Up key pressed, changing active result"), t = a - 1 < 0 ? a : a - 1, i.removeClass(g.active), n.removeClass(g.active).eq(t).addClass(g.active).closest(i).addClass(g.active), e.preventDefault()) : l == c.downArrow && (f.verbose("Down key pressed, changing active result"), t = a + 1 >= r ? a : a + 1, i.removeClass(g.active), n.removeClass(g.active).eq(t).addClass(g.active).closest(i).addClass(g.active), e.preventDefault()); else l == c.enter && (f.verbose("Enter key pressed, executing query"), f.query(), f.set.buttonPressed(), S.one("keyup", f.remove.buttonFocus));
                        },
                        setup: { api(t, n) { const i = { debug: m.debug, on: !1, cache: !0, action: "search", urlData: { query: t }, onSuccess(e) { f.parse.response.call(E, e, t), n(); }, onFailure() { f.displayMessage(y.serverError), n(); }, onAbort(e) {}, onError: f.error }; e.extend(!0, i, m.apiSettings), f.verbose("Setting up API request", i), k.api(i); } },
                        can: { useAPI() { return void 0 !== e.fn.api; }, show() { return f.is.focused() && !f.is.visible() && !f.is.empty(); }, transition() { return m.transition && void 0 !== e.fn.transition && k.transition("is supported"); } },
                        is: { animating() { return A.hasClass(g.animating); }, hidden() { return A.hasClass(g.hidden); }, inMessage(t) { if (t.target) { const i = e(t.target); return e.contains(n.documentElement, t.target) && i.closest(b.message).length > 0; } }, empty() { return A.html() === ""; }, visible() { return A.filter(":visible").length > 0; }, focused() { return S.filter(":focus").length > 0; } },
                        get: { inputEvent() { const e = S[0]; return void 0 !== e && void 0 !== e.oninput ? "input" : void 0 !== e && void 0 !== e.onpropertychange ? "propertychange" : "keyup"; },
                            value() { return S.val(); },
                            results() { return k.data(v.results); },
                            result(t, n) {
                                let i = ["title", "id"],
                                    o = !1; return t = void 0 !== t ? t : f.get.value(), n = void 0 !== n ? n : f.get.results(), m.type === "category" ? (f.debug("Finding result that matches", t), e.each(n, (n, a) => { if (e.isArray(a.results) && (o = f.search.object(t, a.results, i)[0])) return !1; })) : (f.debug("Finding result in results object", t), o = f.search.object(t, n, i)[0]), o || !1;
                            } },
                        select: { firstResult() { f.verbose("Selecting first result"), R.first().addClass(g.active); } },
                        set: { focus() { k.addClass(g.focus); }, loading() { k.addClass(g.loading); }, value(e) { f.verbose("Setting search input value", e), S.val(e); }, type(e) { e = e || m.type, m.type == "category" && k.addClass(m.type); }, buttonPressed() { T.addClass(g.pressed); } },
                        remove: { loading() { k.removeClass(g.loading); }, focus() { k.removeClass(g.focus); }, buttonPressed() { T.removeClass(g.pressed); } },
                        query(t) {
                            t = e.isFunction(t) ? t : function () {}; let n = f.get.value(),
                                i = f.read.cache(n); t = t || function () {}, f.has.minimumCharacters() ? (i ? (f.debug("Reading result from cache", n), f.save.results(i.results), f.addResults(i.html), f.inject.id(i.results), t()) : (f.debug("Querying for", n), e.isPlainObject(m.source) || e.isArray(m.source) ? (f.search.local(n), t()) : f.can.useAPI() ? f.search.remote(n, t) : (f.error(y.source), t())), m.onSearchQuery.call(E, n)) : f.hideResults();
                        },
                        search: { local(e) {
                            let t,
                                n = f.search.object(e, m.content); f.set.loading(), f.save.results(n), f.debug("Returned local search results", n), t = f.generateResults({ results: n }), f.remove.loading(), f.addResults(t), f.inject.id(n), f.write.cache(e, { html: t, results: n });
                        },
                            remote(t, n) { n = e.isFunction(n) ? n : function () {}, k.api("is loading") && k.api("abort"), f.setup.api(t, n), k.api("query"); },
                            object(t, n, i) {
                                let o = [],
                                    a = [],
                                    r = t.toString().replace(p.escape, "\\$&"),
                                    s = new RegExp(p.beginsWith + r, "i"),
                                    l = function (t, n) {
                                        let i = e.inArray(n, o) == -1,
                                            r = e.inArray(n, a) == -1; i && r && t.push(n);
                                    }; return n = n || m.source, i = void 0 !== i ? i : m.searchFields, e.isArray(i) || (i = [i]), void 0 === n || n === !1 ? (f.error(y.source), []) : (e.each(i, (i, r) => { e.each(n, (e, n) => { typeof n[r] === "string" && (n[r].search(s) !== -1 ? l(o, n) : m.searchFullText && f.fuzzySearch(t, n[r]) && l(a, n)); }); }), e.merge(o, a));
                            } },
                        fuzzySearch(e, t) {
                            let n = t.length,
                                i = e.length; if (typeof e !== "string") return !1; if (e = e.toLowerCase(), t = t.toLowerCase(), i > n) return !1; if (i === n) return e === t; e:for (let o = 0, a = 0; o < i; o++) { for (let r = e.charCodeAt(o); a < n;) if (t.charCodeAt(a++) === r) continue e; return !1; } return !0;
                        },
                        parse: { response(e, t) { const n = f.generateResults(e); f.verbose("Parsing server response", e), void 0 !== e && void 0 !== t && void 0 !== e[h.results] && (f.addResults(n), f.inject.id(e[h.results]), f.write.cache(t, { html: n, results: e[h.results] }), f.save.results(e[h.results])); } },
                        cancel: { query() { f.can.useAPI() && k.api("abort"); } },
                        has: { minimumCharacters() { return f.get.value().length >= m.minCharacters; }, results() { return A.length !== 0 && A.html() != ""; } },
                        clear: { cache(e) { const t = k.data(v.cache); e ? e && t && t[e] && (f.debug("Removing value from cache", e), delete t[e], k.data(v.cache, t)) : (f.debug("Clearing cache", e), k.removeData(v.cache)); } },
                        read: { cache(e) { const t = k.data(v.cache); return !!m.cache && (f.verbose("Checking cache for generated html for query", e), typeof t === "object" && void 0 !== t[e] && t[e]); } },
                        create: { id(e, t) {
                            let n,
                                i,
                                o = e + 1; return void 0 !== t ? (n = String.fromCharCode(97 + t), i = n + o, f.verbose("Creating category result id", i)) : (i = o, f.verbose("Creating result id", i)), i;
                        },
                            results() { A.length === 0 && (A = e("<div />").addClass(g.results).appendTo(k)); } },
                        inject: { result(e, t, n) { f.verbose("Injecting result into results"); const i = void 0 !== n ? A.children().eq(n).children(b.result).eq(t) : A.children(b.result).eq(t); f.verbose("Injecting results metadata", i), i.data(v.result, e); },
                            id(t) {
                                f.debug("Injecting unique ids into results"); let n = 0,
                                    i = 0; return m.type === "category" ? e.each(t, (t, o) => { i = 0, e.each(o.results, (e, t) => { const a = o.results[e]; void 0 === a.id && (a.id = f.create.id(i, n)), f.inject.result(a, i, n), i++; }), n++; }) : e.each(t, (e, n) => { const o = t[e]; void 0 === o.id && (o.id = f.create.id(i)), f.inject.result(o, i), i++; }), t;
                            } },
                        save: { results(e) { f.verbose("Saving current search results to metadata", e), k.data(v.results, e); } },
                        write: { cache(e, t) { const n = void 0 !== k.data(v.cache) ? k.data(v.cache) : {}; m.cache && (f.verbose("Writing generated html to cache", e, t), n[e] = t, k.data(v.cache, n)); } },
                        addResults(t) { if (e.isFunction(m.onResultsAdd) && m.onResultsAdd.call(A, t) === !1) return f.debug("onResultsAdd callback cancelled default action"), !1; t ? (A.html(t), f.refreshResults(), m.selectFirstResult && f.select.firstResult(), f.showResults()) : f.hideResults(() => { A.empty(); }); },
                        showResults(t) { t = e.isFunction(t) ? t : function () {}, D || !f.is.visible() && f.has.results() && (f.can.transition() ? (f.debug("Showing results with css animations"), A.transition({ animation: `${m.transition} in`, debug: m.debug, verbose: m.verbose, duration: m.duration, onComplete() { t(); }, queue: !0 })) : (f.debug("Showing results with javascript"), A.stop().fadeIn(m.duration, m.easing)), m.onResultsOpen.call(A)); },
                        hideResults(t) { t = e.isFunction(t) ? t : function () {}, f.is.visible() && (f.can.transition() ? (f.debug("Hiding results with css animations"), A.transition({ animation: `${m.transition} out`, debug: m.debug, verbose: m.verbose, duration: m.duration, onComplete() { t(); }, queue: !0 })) : (f.debug("Hiding results with javascript"), A.stop().fadeOut(m.duration, m.easing)), m.onResultsClose.call(A)); },
                        generateResults(t) {
                            f.debug("Generating html from response", t); let n = m.templates[m.type],
                                i = e.isPlainObject(t[h.results]) && !e.isEmptyObject(t[h.results]),
                                o = e.isArray(t[h.results]) && t[h.results].length > 0,
                                a = ""; return i || o ? (m.maxResults > 0 && (i ? m.type == "standard" && f.error(y.maxResults) : t[h.results] = t[h.results].slice(0, m.maxResults)), e.isFunction(n) ? a = n(t, h) : f.error(y.noTemplate, !1)) : m.showNoResults && (a = f.displayMessage(y.noResults, "empty")), m.onResults.call(E, t), a;
                        },
                        displayMessage(e, t) { return t = t || "standard", f.debug("Displaying message", e, t), f.addResults(m.templates.message(e, t)), m.templates.message(e, t); },
                        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, m, t); else { if (void 0 === n) return m[t]; m[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; f[t] = n; } },
                        debug() { !m.silent && m.debug && (m.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.debug.apply(console, arguments))); },
                        verbose() { !m.silent && m.verbose && m.debug && (m.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${m.name}:`), f.verbose.apply(console, arguments))); },
                        error() { m.silent || (f.error = Function.prototype.bind.call(console.error, console, `${m.name}:`), f.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; m.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: E, "Execution Time": n })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
                        },
                            display() {
                                let t = `${m.name}:`,
                                    n = 0; s = !1, clearTimeout(f.performance.timer), e.each(l, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, r && (t += ` '${r}'`), a.length > 1 && (t += ` (${a.length})`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), l = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = F; return n = n || d, i = E || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, u ? (void 0 === F && f.initialize(), f.invoke(c)) : (void 0 !== F && F.invoke("destroy"), f.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.search.settings = { name: "Search",
        namespace: "search",
        silent: !1,
        debug: !1,
        verbose: !1,
        performance: !0,
        type: "standard",
        minCharacters: 1,
        selectFirstResult: !1,
        apiSettings: !1,
        source: !1,
        searchOnFocus: !0,
        searchFields: ["title", "description"],
        displayField: "",
        searchFullText: !0,
        automatic: !0,
        hideDelay: 0,
        searchDelay: 200,
        maxResults: 7,
        cache: !0,
        showNoResults: !0,
        transition: "scale",
        duration: 200,
        easing: "easeOutExpo",
        onSelect: !1,
        onResultsAdd: !1,
        onSearchQuery(e) {},
        onResults(e) {},
        onResultsOpen() {},
        onResultsClose() {},
        className: { animating: "animating", active: "active", empty: "empty", focus: "focus", hidden: "hidden", loading: "loading", results: "results", pressed: "down" },
        error: { source: "Cannot search. No source used, and Semantic API module was not included", noResults: "Your search returned no results", logging: "Error in debug logging, exiting.", noEndpoint: "No search endpoint was specified", noTemplate: "A valid template name was not specified.", serverError: "There was an issue querying the server.", maxResults: "Results must be an array to use maxResults setting", method: "The method you called is not defined." },
        metadata: { cache: "cache", results: "results", result: "result" },
        regExp: { escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, beginsWith: "(?:s|^)" },
        fields: { categories: "results", categoryName: "name", categoryResults: "results", description: "description", image: "image", price: "price", results: "results", title: "title", url: "url", action: "action", actionText: "text", actionURL: "url" },
        selector: { prompt: ".prompt", searchButton: ".search.button", results: ".results", message: ".results > .message", category: ".category", result: ".result", title: ".title, .name" },
        templates: { escape(e) {
            let t = /[&<>"'`]/,
                n = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#x27;", "`": "&#x60;" },
                i = function (e) { return n[e]; }; return t.test(e) ? e.replace(/[&<>"'`]/g, i) : e;
        },
            message(e, t) { let n = ""; return void 0 !== e && void 0 !== t && (n += `<div class="message ${t}">`, n += t == "empty" ? `<div class="header">No Results</div class="header"><div class="description">${e}</div class="description">` : ` <div class="description">${e}</div>`, n += "</div>"), n; },
            category(t, n) { let i = ""; e.fn.search.settings.templates.escape; return void 0 !== t[n.categoryResults] && (e.each(t[n.categoryResults], (t, o) => { void 0 !== o[n.results] && o.results.length > 0 && (i += "<div class=\"category\">", void 0 !== o[n.categoryName] && (i += `<div class="name">${o[n.categoryName]}</div>`), e.each(o.results, (e, t) => { i += t[n.url] ? `<a class="result" href="${t[n.url]}">` : "<a class=\"result\">", void 0 !== t[n.image] && (i += `<div class="image"> <img src="${t[n.image]}"></div>`), i += "<div class=\"content\">", void 0 !== t[n.price] && (i += `<div class="price">${t[n.price]}</div>`), void 0 !== t[n.title] && (i += `<div class="title">${t[n.title]}</div>`), void 0 !== t[n.description] && (i += `<div class="description">${t[n.description]}</div>`), i += "</div>", i += "</a>"; }), i += "</div>"); }), t[n.action] && (i += `<a href="${t[n.action][n.actionURL]}" class="action">${t[n.action][n.actionText]}</a>`), i); },
            standard(t, n) { let i = ""; return void 0 !== t[n.results] && (e.each(t[n.results], (e, t) => { i += t[n.url] ? `<a class="result" href="${t[n.url]}">` : "<a class=\"result\">", void 0 !== t[n.image] && (i += `<div class="image"> <img src="${t[n.image]}"></div>`), i += "<div class=\"content\">", void 0 !== t[n.price] && (i += `<div class="price">${t[n.price]}</div>`), void 0 !== t[n.title] && (i += `<div class="title">${t[n.title]}</div>`), void 0 !== t[n.description] && (i += `<div class="description">${t[n.description]}</div>`), i += "</div>", i += "</a>"; }), t[n.action] && (i += `<a href="${t[n.action][n.actionURL]}" class="action">${t[n.action][n.actionText]}</a>`), i); } } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.shape = function (i) {
        let o,
            a = e(this),
            r = (e("body"), (new Date()).getTime()),
            s = [],
            l = arguments[0],
            c = typeof l === "string",
            u = [].slice.call(arguments, 1),
            d = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return a.each(function () {
                let t,
                    f,
                    m,
                    g = a.selector || "",
                    v = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.shape.settings, i) : e.extend({}, e.fn.shape.settings),
                    p = v.namespace,
                    h = v.selector,
                    b = v.error,
                    y = v.className,
                    x = `.${p}`,
                    C = `module-${p}`,
                    w = e(this),
                    k = w.find(h.sides),
                    S = w.find(h.side),
                    T = !1,
                    A = this,
                    R = w.data(C); m = { initialize() { m.verbose("Initializing module for", A), m.set.defaultSide(), m.instantiate(); },
                        instantiate() { m.verbose("Storing instance of module", m), R = m, w.data(C, R); },
                        destroy() { m.verbose("Destroying previous module for", A), w.removeData(C).off(x); },
                        refresh() { m.verbose("Refreshing selector cache for", A), w = e(A), k = e(this).find(h.shape), S = e(this).find(h.side); },
                        repaint() { m.verbose("Forcing repaint event"); const e = k[0] || n.createElement("div"); e.offsetWidth; },
                        animate(e, n) { m.verbose("Animating box with properties", e), n = n || function (e) { m.verbose("Executing animation callback"), void 0 !== e && e.stopPropagation(), m.reset(), m.set.active(); }, v.beforeChange.call(f[0]), m.get.transitionEvent() ? (m.verbose("Starting CSS animation"), w.addClass(y.animating), k.css(e).one(m.get.transitionEvent(), n), m.set.duration(v.duration), d(() => { w.addClass(y.animating), t.addClass(y.hidden); })) : n(); },
                        queue(e) { m.debug("Queueing animation of", e), k.one(m.get.transitionEvent(), () => { m.debug("Executing queued animation"), setTimeout(() => { w.shape(e); }, 0); }); },
                        reset() { m.verbose("Animating states reset"), w.removeClass(y.animating).attr("style", "").removeAttr("style"), k.attr("style", "").removeAttr("style"), S.attr("style", "").removeAttr("style").removeClass(y.hidden), f.removeClass(y.animating).attr("style", "").removeAttr("style"); },
                        is: { complete() { return S.filter(`.${y.active}`)[0] == f[0]; }, animating() { return w.hasClass(y.animating); } },
                        set: { defaultSide() { t = w.find(`.${v.className.active}`), f = t.next(h.side).length > 0 ? t.next(h.side) : w.find(h.side).first(), T = !1, m.verbose("Active side set to", t), m.verbose("Next side set to", f); },
                            duration(e) { e = e || v.duration, e = typeof e === "number" ? `${e}ms` : e, m.verbose("Setting animation duration", e), (v.duration || v.duration === 0) && k.add(S).css({ "-webkit-transition-duration": e, "-moz-transition-duration": e, "-ms-transition-duration": e, "-o-transition-duration": e, "transition-duration": e }); },
                            currentStageSize() {
                                let e = w.find(`.${v.className.active}`),
                                    t = e.outerWidth(!0),
                                    n = e.outerHeight(!0); w.css({ width: t, height: n });
                            },
                            stageSize() {
                                let e = w.clone().addClass(y.loading),
                                    t = e.find(`.${v.className.active}`),
                                    n = T ? e.find(h.side).eq(T) : t.next(h.side).length > 0 ? t.next(h.side) : e.find(h.side).first(),
                                    i = v.width == "next" ? n.outerWidth(!0) : v.width == "initial" ? w.width() : v.width,
                                    o = v.height == "next" ? n.outerHeight(!0) : v.height == "initial" ? w.height() : v.height; t.removeClass(y.active), n.addClass(y.active), e.insertAfter(w), e.remove(), v.width != "auto" && (w.css("width", i + v.jitter), m.verbose("Specifying width during animation", i)), v.height != "auto" && (w.css("height", o + v.jitter), m.verbose("Specifying height during animation", o));
                            },
                            nextSide(e) { T = e, f = S.filter(e), T = S.index(f), f.length === 0 && (m.set.defaultSide(), m.error(b.side)), m.verbose("Next side manually set to", f); },
                            active() { m.verbose("Setting new side to active", f), S.removeClass(y.active), f.addClass(y.active), v.onChange.call(f[0]), m.set.defaultSide(); } },
                        flip: { up() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug("Side already visible", f); if (m.is.animating())m.queue("flip up"); else { m.debug("Flipping up", f); const e = m.get.transform.up(); m.set.stageSize(), m.stage.above(), m.animate(e); } }, down() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug("Side already visible", f); if (m.is.animating())m.queue("flip down"); else { m.debug("Flipping down", f); const e = m.get.transform.down(); m.set.stageSize(), m.stage.below(), m.animate(e); } }, left() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug("Side already visible", f); if (m.is.animating())m.queue("flip left"); else { m.debug("Flipping left", f); const e = m.get.transform.left(); m.set.stageSize(), m.stage.left(), m.animate(e); } }, right() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug("Side already visible", f); if (m.is.animating())m.queue("flip right"); else { m.debug("Flipping right", f); const e = m.get.transform.right(); m.set.stageSize(), m.stage.right(), m.animate(e); } }, over() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug("Side already visible", f); m.is.animating() ? m.queue("flip over") : (m.debug("Flipping over", f), m.set.stageSize(), m.stage.behind(), m.animate(m.get.transform.over())); }, back() { if (m.is.complete() && !m.is.animating() && !v.allowRepeats) return void m.debug("Side already visible", f); m.is.animating() ? m.queue("flip back") : (m.debug("Flipping back", f), m.set.stageSize(), m.stage.behind(), m.animate(m.get.transform.back())); } },
                        get: { transform: { up() { const e = { y: -((t.outerHeight(!0) - f.outerHeight(!0)) / 2), z: -(t.outerHeight(!0) / 2) }; return { transform: `translateY(${e.y}px) translateZ(${e.z}px) rotateX(-90deg)` }; }, down() { const e = { y: -((t.outerHeight(!0) - f.outerHeight(!0)) / 2), z: -(t.outerHeight(!0) / 2) }; return { transform: `translateY(${e.y}px) translateZ(${e.z}px) rotateX(90deg)` }; }, left() { const e = { x: -((t.outerWidth(!0) - f.outerWidth(!0)) / 2), z: -(t.outerWidth(!0) / 2) }; return { transform: `translateX(${e.x}px) translateZ(${e.z}px) rotateY(90deg)` }; }, right() { const e = { x: -((t.outerWidth(!0) - f.outerWidth(!0)) / 2), z: -(t.outerWidth(!0) / 2) }; return { transform: `translateX(${e.x}px) translateZ(${e.z}px) rotateY(-90deg)` }; }, over() { return { transform: `translateX(${{ x: -((t.outerWidth(!0) - f.outerWidth(!0)) / 2) }.x}px) rotateY(180deg)` }; }, back() { return { transform: `translateX(${{ x: -((t.outerWidth(!0) - f.outerWidth(!0)) / 2) }.x}px) rotateY(-180deg)` }; } },
                            transitionEvent() {
                                let e,
                                    t = n.createElement("element"),
                                    i = { transition: "transitionend", OTransition: "oTransitionEnd", MozTransition: "transitionend", WebkitTransition: "webkitTransitionEnd" }; for (e in i) if (void 0 !== t.style[e]) return i[e];
                            },
                            nextSide() { return t.next(h.side).length > 0 ? t.next(h.side) : w.find(h.side).first(); } },
                        stage: { above() { const e = { origin: (t.outerHeight(!0) - f.outerHeight(!0)) / 2, depth: { active: f.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; m.verbose("Setting the initial animation position as above", f, e), k.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), f.addClass(y.animating).css({ top: `${e.origin}px`, transform: `rotateX(90deg) translateZ(${e.depth.next}px)` }); },
                            below() { const e = { origin: (t.outerHeight(!0) - f.outerHeight(!0)) / 2, depth: { active: f.outerHeight(!0) / 2, next: t.outerHeight(!0) / 2 } }; m.verbose("Setting the initial animation position as below", f, e), k.css({ transform: `translateZ(-${e.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), f.addClass(y.animating).css({ top: `${e.origin}px`, transform: `rotateX(-90deg) translateZ(${e.depth.next}px)` }); },
                            left() {
                                let e = { active: t.outerWidth(!0), next: f.outerWidth(!0) },
                                    n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; m.verbose("Setting the initial animation position as left", f, n), k.css({ transform: `translateZ(-${n.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: `rotateY(-90deg) translateZ(${n.depth.next}px)` });
                            },
                            right() {
                                let e = { active: t.outerWidth(!0), next: f.outerWidth(!0) },
                                    n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; m.verbose("Setting the initial animation position as left", f, n), k.css({ transform: `translateZ(-${n.depth.active}px)` }), t.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: `rotateY(90deg) translateZ(${n.depth.next}px)` });
                            },
                            behind() {
                                let e = { active: t.outerWidth(!0), next: f.outerWidth(!0) },
                                    n = { origin: (e.active - e.next) / 2, depth: { active: e.next / 2, next: e.active / 2 } }; m.verbose("Setting the initial animation position as behind", f, n), t.css({ transform: "rotateY(0deg)" }), f.addClass(y.animating).css({ left: `${n.origin}px`, transform: "rotateY(-180deg)" });
                            } },
                        setting(t, n) { if (m.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, v, t); else { if (void 0 === n) return v[t]; e.isPlainObject(v[t]) ? e.extend(!0, v[t], n) : v[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, m, t); else { if (void 0 === n) return m[t]; m[t] = n; } },
                        debug() { !v.silent && v.debug && (v.performance ? m.performance.log(arguments) : (m.debug = Function.prototype.bind.call(console.info, console, `${v.name}:`), m.debug.apply(console, arguments))); },
                        verbose() { !v.silent && v.verbose && v.debug && (v.performance ? m.performance.log(arguments) : (m.verbose = Function.prototype.bind.call(console.info, console, `${v.name}:`), m.verbose.apply(console, arguments))); },
                        error() { v.silent || (m.error = Function.prototype.bind.call(console.error, console, `${v.name}:`), m.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; v.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: A, "Execution Time": n })), clearTimeout(m.performance.timer), m.performance.timer = setTimeout(m.performance.display, 500);
                        },
                            display() {
                                let t = `${v.name}:`,
                                    n = 0; r = !1, clearTimeout(m.performance.timer), e.each(s, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, g && (t += ` '${g}'`), a.length > 1 && (t += ` (${a.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = R; return n = n || u, i = A || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, c ? (void 0 === R && m.initialize(), m.invoke(l)) : (void 0 !== R && R.invoke("destroy"), m.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.shape.settings = { name: "Shape", silent: !1, debug: !1, verbose: !1, jitter: 0, performance: !0, namespace: "shape", width: "initial", height: "initial", beforeChange() {}, onChange() {}, allowRepeats: !1, duration: !1, error: { side: "You tried to switch to a side that does not exist.", method: "The method you called is not defined" }, className: { animating: "animating", hidden: "hidden", loading: "loading", active: "active" }, selector: { sides: ".sides", side: ".side" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.sidebar = function (i) {
        let o,
            a = e(this),
            r = e(t),
            s = e(n),
            l = e("html"),
            c = e("head"),
            u = a.selector || "",
            d = (new Date()).getTime(),
            f = [],
            m = arguments[0],
            g = typeof m === "string",
            v = [].slice.call(arguments, 1),
            p = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return a.each(function () {
                let a,
                    h,
                    b,
                    y,
                    x,
                    C,
                    w = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.sidebar.settings, i) : e.extend({}, e.fn.sidebar.settings),
                    k = w.selector,
                    S = w.className,
                    T = w.namespace,
                    A = w.regExp,
                    R = w.error,
                    P = `.${T}`,
                    E = `module-${T}`,
                    F = e(this),
                    O = e(w.context),
                    D = F.children(k.sidebar),
                    q = O.children(k.fixed),
                    j = O.children(k.pusher),
                    z = this,
                    I = F.data(E); C = { initialize() { C.debug("Initializing sidebar", i), C.create.id(), x = C.get.transitionEvent(), C.is.ios() && C.set.ios(), w.delaySetup ? p(C.setup.layout) : C.setup.layout(), p(() => { C.setup.cache(); }), C.instantiate(); },
                        instantiate() { C.verbose("Storing instance of module", C), I = C, F.data(E, C); },
                        create: { id() { b = (`${Math.random().toString(16)}000000000`).substr(2, 8), h = `.${b}`, C.verbose("Creating unique id for element", b); } },
                        destroy() { C.verbose("Destroying previous module for", F), F.off(P).removeData(E), C.is.ios() && C.remove.ios(), O.off(h), r.off(h), s.off(h); },
                        event: { clickaway(e) {
                            let t = j.find(e.target).length > 0 || j.is(e.target),
                                n = O.is(e.target); t && (C.verbose("User clicked on dimmed page"), C.hide()), n && (C.verbose("User clicked on dimmable context (scaled out page)"), C.hide());
                        },
                            touch(e) {},
                            containScroll(e) { z.scrollTop <= 0 && (z.scrollTop = 1), z.scrollTop + z.offsetHeight >= z.scrollHeight && (z.scrollTop = z.scrollHeight - z.offsetHeight - 1); },
                            scroll(t) {
                                e(t.target).closest(k.sidebar).length === 0 && t.preventDefault();
                            } },
                        bind: { clickaway() { C.verbose("Adding clickaway events to context", O), w.closable && O.on(`click${h}`, C.event.clickaway).on(`touchend${h}`, C.event.clickaway); }, scrollLock() { w.scrollLock && (C.debug("Disabling page scroll"), r.on(`DOMMouseScroll${h}`, C.event.scroll)), C.verbose("Adding events to contain sidebar scroll"), s.on(`touchmove${h}`, C.event.touch), F.on(`scroll${P}`, C.event.containScroll); } },
                        unbind: { clickaway() { C.verbose("Removing clickaway events from context", O), O.off(h); }, scrollLock() { C.verbose("Removing scroll lock from page"), s.off(h), r.off(h), F.off(`scroll${P}`); } },
                        add: { inlineCSS() {
                            let t,
                                n = C.cache.width || F.outerWidth(),
                                i = C.cache.height || F.outerHeight(),
                                o = C.is.rtl(),
                                r = C.get.direction(),
                                s = { left: n, right: -n, top: i, bottom: -i }; o && (C.verbose("RTL detected, flipping widths"), s.left = -n, s.right = n), t = "<style>", r === "left" || r === "right" ? (C.debug("Adding CSS rules for animation distance", n), t += ` .ui.visible.${r}.sidebar ~ .fixed, .ui.visible.${r}.sidebar ~ .pusher {   -webkit-transform: translate3d(${s[r]}px, 0, 0);           transform: translate3d(${s[r]}px, 0, 0); }`) : r !== "top" && r != "bottom" || (t += ` .ui.visible.${r}.sidebar ~ .fixed, .ui.visible.${r}.sidebar ~ .pusher {   -webkit-transform: translate3d(0, ${s[r]}px, 0);           transform: translate3d(0, ${s[r]}px, 0); }`), C.is.ie() && (r === "left" || r === "right" ? (C.debug("Adding CSS rules for animation distance", n), t += ` body.pushable > .ui.visible.${r}.sidebar ~ .pusher:after {   -webkit-transform: translate3d(${s[r]}px, 0, 0);           transform: translate3d(${s[r]}px, 0, 0); }`) : r !== "top" && r != "bottom" || (t += ` body.pushable > .ui.visible.${r}.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0, ${s[r]}px, 0);           transform: translate3d(0, ${s[r]}px, 0); }`), t += " body.pushable > .ui.visible.left.sidebar ~ .ui.visible.right.sidebar ~ .pusher:after, body.pushable > .ui.visible.right.sidebar ~ .ui.visible.left.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0px, 0, 0);           transform: translate3d(0px, 0, 0); }"), t += "</style>", a = e(t).appendTo(c), C.debug("Adding sizing css to head", a);
                        } },
                        refresh() { C.verbose("Refreshing selector cache"), O = e(w.context), D = O.children(k.sidebar), j = O.children(k.pusher), q = O.children(k.fixed), C.clear.cache(); },
                        refreshSidebars() { C.verbose("Refreshing other sidebars"), D = O.children(k.sidebar); },
                        repaint() { C.verbose("Forcing repaint event"), z.style.display = "none"; z.offsetHeight; z.scrollTop = z.scrollTop, z.style.display = ""; },
                        setup: { cache() { C.cache = { width: F.outerWidth(), height: F.outerHeight(), rtl: F.css("direction") == "rtl" }; }, layout() { O.children(k.pusher).length === 0 && (C.debug("Adding wrapper element for sidebar"), C.error(R.pusher), j = e("<div class=\"pusher\" />"), O.children().not(k.omitted).not(D).wrapAll(j), C.refresh()), F.nextAll(k.pusher).length !== 0 && F.nextAll(k.pusher)[0] === j[0] || (C.debug("Moved sidebar to correct parent element"), C.error(R.movedSidebar, z), F.detach().prependTo(O), C.refresh()), C.clear.cache(), C.set.pushable(), C.set.direction(); } },
                        attachEvents(t, n) { const i = e(t); n = e.isFunction(C[n]) ? C[n] : C.toggle, i.length > 0 ? (C.debug("Attaching sidebar events to element", t, n), i.on(`click${P}`, n)) : C.error(R.notFound, t); },
                        show(t) { if (t = e.isFunction(t) ? t : function () {}, C.is.hidden()) { if (C.refreshSidebars(), w.overlay && (C.error(R.overlay), w.transition = "overlay"), C.refresh(), C.othersActive()) if (C.debug("Other sidebars currently visible"), w.exclusive) { if (w.transition != "overlay") return void C.hideOthers(C.show); C.hideOthers(); } else w.transition = "overlay"; C.pushPage(() => { t.call(z), w.onShow.call(z); }), w.onChange.call(z), w.onVisible.call(z); } else C.debug("Sidebar is already visible"); },
                        hide(t) { t = e.isFunction(t) ? t : function () {}, (C.is.visible() || C.is.animating()) && (C.debug("Hiding sidebar", t), C.refreshSidebars(), C.pullPage(() => { t.call(z), w.onHidden.call(z); }), w.onChange.call(z), w.onHide.call(z)); },
                        othersAnimating() { return D.not(F).filter(`.${S.animating}`).length > 0; },
                        othersVisible() { return D.not(F).filter(`.${S.visible}`).length > 0; },
                        othersActive() { return C.othersVisible() || C.othersAnimating(); },
                        hideOthers(e) {
                            let t = D.not(F).filter(`.${S.visible}`),
                                n = t.length,
                                i = 0; e = e || function () {}, t.sidebar("hide", () => { ++i == n && e(); });
                        },
                        toggle() { C.verbose("Determining toggled direction"), C.is.hidden() ? C.show() : C.hide(); },
                        pushPage(t) {
                            let n,
                                i,
                                o,
                                a = C.get.transition(),
                                r = a === "overlay" || C.othersActive() ? F : j; t = e.isFunction(t) ? t : function () {}, w.transition == "scale down" && C.scrollToTop(), C.set.transition(a), C.repaint(), n = function () { C.bind.clickaway(), C.add.inlineCSS(), C.set.animating(), C.set.visible(); }, i = function () { C.set.dimmed(); }, o = function (e) { e.target == r[0] && (r.off(x + h, o), C.remove.animating(), C.bind.scrollLock(), t.call(z)); }, r.off(x + h), r.on(x + h, o), p(n), w.dimPage && !C.othersVisible() && p(i);
                        },
                        pullPage(t) {
                            let n,
                                i,
                                o = C.get.transition(),
                                a = o == "overlay" || C.othersActive() ? F : j; t = e.isFunction(t) ? t : function () {}, C.verbose("Removing context push state", C.get.direction()), C.unbind.clickaway(), C.unbind.scrollLock(), n = function () { C.set.transition(o), C.set.animating(), C.remove.visible(), w.dimPage && !C.othersVisible() && j.removeClass(S.dimmed); }, i = function (e) { e.target == a[0] && (a.off(x + h, i), C.remove.animating(), C.remove.transition(), C.remove.inlineCSS(), (o == "scale down" || w.returnScroll && C.is.mobile()) && C.scrollBack(), t.call(z)); }, a.off(x + h), a.on(x + h, i), p(n);
                        },
                        scrollToTop() { C.verbose("Scrolling to top of page to avoid animation issues"), y = e(t).scrollTop(), F.scrollTop(0), t.scrollTo(0, 0); },
                        scrollBack() { C.verbose("Scrolling back to original page position"), t.scrollTo(0, y); },
                        clear: { cache() { C.verbose("Clearing cached dimensions"), C.cache = {}; } },
                        set: { ios() { l.addClass(S.ios); }, pushed() { O.addClass(S.pushed); }, pushable() { O.addClass(S.pushable); }, dimmed() { j.addClass(S.dimmed); }, active() { F.addClass(S.active); }, animating() { F.addClass(S.animating); }, transition(e) { e = e || C.get.transition(), F.addClass(e); }, direction(e) { e = e || C.get.direction(), F.addClass(S[e]); }, visible() { F.addClass(S.visible); }, overlay() { F.addClass(S.overlay); } },
                        remove: { inlineCSS() { C.debug("Removing inline css styles", a), a && a.length > 0 && a.remove(); }, ios() { l.removeClass(S.ios); }, pushed() { O.removeClass(S.pushed); }, pushable() { O.removeClass(S.pushable); }, active() { F.removeClass(S.active); }, animating() { F.removeClass(S.animating); }, transition(e) { e = e || C.get.transition(), F.removeClass(e); }, direction(e) { e = e || C.get.direction(), F.removeClass(S[e]); }, visible() { F.removeClass(S.visible); }, overlay() { F.removeClass(S.overlay); } },
                        get: { direction() { return F.hasClass(S.top) ? S.top : F.hasClass(S.right) ? S.right : F.hasClass(S.bottom) ? S.bottom : S.left; },
                            transition() {
                                let e,
                                    t = C.get.direction(); return e = C.is.mobile() ? w.mobileTransition == "auto" ? w.defaultTransition.mobile[t] : w.mobileTransition : w.transition == "auto" ? w.defaultTransition.computer[t] : w.transition, C.verbose("Determined transition", e), e;
                            },
                            transitionEvent() {
                                let e,
                                    t = n.createElement("element"),
                                    i = { transition: "transitionend", OTransition: "oTransitionEnd", MozTransition: "transitionend", WebkitTransition: "webkitTransitionEnd" }; for (e in i) if (void 0 !== t.style[e]) return i[e];
                            } },
                        is: { ie() {
                            let e = !t.ActiveXObject && "ActiveXObject" in t,
                                n = "ActiveXObject" in t; return e || n;
                        },
                            ios() {
                                let e = navigator.userAgent,
                                    t = e.match(A.ios),
                                    n = e.match(A.mobileChrome); return !(!t || n) && (C.verbose("Browser was found to be iOS", e), !0);
                            },
                            mobile() { const e = navigator.userAgent; return e.match(A.mobile) ? (C.verbose("Browser was found to be mobile", e), !0) : (C.verbose("Browser is not mobile, using regular transition", e), !1); },
                            hidden() { return !C.is.visible(); },
                            visible() { return F.hasClass(S.visible); },
                            open() { return C.is.visible(); },
                            closed() { return C.is.hidden(); },
                            vertical() { return F.hasClass(S.top); },
                            animating() { return O.hasClass(S.animating); },
                            rtl() { return void 0 === C.cache.rtl && (C.cache.rtl = F.css("direction") == "rtl"), C.cache.rtl; } },
                        setting(t, n) { if (C.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, w, t); else { if (void 0 === n) return w[t]; e.isPlainObject(w[t]) ? e.extend(!0, w[t], n) : w[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, C, t); else { if (void 0 === n) return C[t]; C[t] = n; } },
                        debug() { !w.silent && w.debug && (w.performance ? C.performance.log(arguments) : (C.debug = Function.prototype.bind.call(console.info, console, `${w.name}:`), C.debug.apply(console, arguments))); },
                        verbose() { !w.silent && w.verbose && w.debug && (w.performance ? C.performance.log(arguments) : (C.verbose = Function.prototype.bind.call(console.info, console, `${w.name}:`), C.verbose.apply(console, arguments))); },
                        error() { w.silent || (C.error = Function.prototype.bind.call(console.error, console, `${w.name}:`), C.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; w.performance && (t = (new Date()).getTime(), i = d || t, n = t - i, d = t, f.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: z, "Execution Time": n })), clearTimeout(C.performance.timer), C.performance.timer = setTimeout(C.performance.display, 500);
                        },
                            display() {
                                let t = `${w.name}:`,
                                    n = 0; d = !1, clearTimeout(C.performance.timer), e.each(f, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, u && (t += ` '${u}'`), (void 0 !== console.group || void 0 !== console.table) && f.length > 0 && (console.groupCollapsed(t), console.table ? console.table(f) : e.each(f, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), f = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = I; return n = n || v, i = z || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (C.error(R.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, g ? (void 0 === I && C.initialize(), C.invoke(m)) : (void 0 !== I && C.invoke("destroy"), C.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.sidebar.settings = { name: "Sidebar", namespace: "sidebar", silent: !1, debug: !1, verbose: !1, performance: !0, transition: "auto", mobileTransition: "auto", defaultTransition: { computer: { left: "uncover", right: "uncover", top: "overlay", bottom: "overlay" }, mobile: { left: "uncover", right: "uncover", top: "overlay", bottom: "overlay" } }, context: "body", exclusive: !1, closable: !0, dimPage: !0, scrollLock: !1, returnScroll: !1, delaySetup: !1, duration: 500, onChange() {}, onShow() {}, onHide() {}, onHidden() {}, onVisible() {}, className: { active: "active", animating: "animating", dimmed: "dimmed", ios: "ios", pushable: "pushable", pushed: "pushed", right: "right", top: "top", left: "left", bottom: "bottom", visible: "visible" }, selector: { fixed: ".fixed", omitted: "script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed", pusher: ".pusher", sidebar: ".ui.sidebar" }, regExp: { ios: /(iPad|iPhone|iPod)/g, mobileChrome: /(CriOS)/g, mobile: /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g }, error: { method: "The method you called is not defined.", pusher: "Had to add pusher element. For optimal performance make sure body content is inside a pusher element", movedSidebar: "Had to move sidebar. For optimal performance make sure sidebar and pusher are direct children of your body tag", overlay: "The overlay setting is no longer supported, use animation: overlay", notFound: "There were no elements that matched the specified selector" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.sticky = function (i) {
        let o,
            a = e(this),
            r = a.selector || "",
            s = (new Date()).getTime(),
            l = [],
            c = arguments[0],
            u = typeof c === "string",
            d = [].slice.call(arguments, 1); return a.each(function () {
                let a,
                    f,
                    m,
                    g,
                    v,
                    p = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.sticky.settings, i) : e.extend({}, e.fn.sticky.settings),
                    h = p.className,
                    b = p.namespace,
                    y = p.error,
                    x = `.${b}`,
                    C = `module-${b}`,
                    w = e(this),
                    k = e(t),
                    S = e(p.scrollContext),
                    T = (w.selector, w.data(C)),
                    A = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); },
                    R = this; v = { initialize() { v.determineContainer(), v.determineContext(), v.verbose("Initializing sticky", p, a), v.save.positions(), v.checkErrors(), v.bind.events(), p.observeChanges && v.observeChanges(), v.instantiate(); },
                        instantiate() { v.verbose("Storing instance of module", v), T = v, w.data(C, v); },
                        destroy() { v.verbose("Destroying previous instance"), v.reset(), m && m.disconnect(), g && g.disconnect(), k.off(`load${x}`, v.event.load).off(`resize${x}`, v.event.resize), S.off(`scrollchange${x}`, v.event.scrollchange), w.removeData(C); },
                        observeChanges() { "MutationObserver" in t && (m = new MutationObserver(v.event.documentChanged), g = new MutationObserver(v.event.changed), m.observe(n, { childList: !0, subtree: !0 }), g.observe(R, { childList: !0, subtree: !0 }), g.observe(f[0], { childList: !0, subtree: !0 }), v.debug("Setting up mutation observer", g)); },
                        determineContainer() { a = p.container ? e(p.container) : w.offsetParent(); },
                        determineContext() { if (f = p.context ? e(p.context) : a, f.length === 0) return void v.error(y.invalidContext, p.context, w); },
                        checkErrors() { if (v.is.hidden() && v.error(y.visible, w), v.cache.element.height > v.cache.context.height) return v.reset(), void v.error(y.elementSize, w); },
                        bind: { events() { k.on(`load${x}`, v.event.load).on(`resize${x}`, v.event.resize), S.off(`scroll${x}`).on(`scroll${x}`, v.event.scroll).on(`scrollchange${x}`, v.event.scrollchange); } },
                        event: { changed(e) { clearTimeout(v.timer), v.timer = setTimeout(() => { v.verbose("DOM tree modified, updating sticky menu", e), v.refresh(); }, 100); }, documentChanged(t) { [].forEach.call(t, (t) => { t.removedNodes && [].forEach.call(t.removedNodes, (t) => { (t == R || e(t).find(R).length > 0) && (v.debug("Element removed from DOM, tearing down events"), v.destroy()); }); }); }, load() { v.verbose("Page contents finished loading"), A(v.refresh); }, resize() { v.verbose("Window resized"), A(v.refresh); }, scroll() { A(() => { S.triggerHandler(`scrollchange${x}`, S.scrollTop()); }); }, scrollchange(e, t) { v.stick(t), p.onScroll.call(R); } },
                        refresh(e) { v.reset(), p.context || v.determineContext(), e && v.determineContainer(), v.save.positions(), v.stick(), p.onReposition.call(R); },
                        supports: { sticky() { const t = e("<div/>"); t[0]; return t.addClass(h.supported), t.css("position").match("sticky"); } },
                        save: { lastScroll(e) { v.lastScroll = e; },
                            elementScroll(e) { v.elementScroll = e; },
                            positions() {
                                let e = { height: S.height() },
                                    t = { margin: { top: parseInt(w.css("margin-top"), 10), bottom: parseInt(w.css("margin-bottom"), 10) }, offset: w.offset(), width: w.outerWidth(), height: w.outerHeight() },
                                    n = { offset: f.offset(), height: f.outerHeight() }; a.outerHeight(); v.is.standardScroll() || (v.debug("Non-standard scroll. Removing scroll offset from element offset"), e.top = S.scrollTop(), e.left = S.scrollLeft(), t.offset.top += e.top, n.offset.top += e.top, t.offset.left += e.left, n.offset.left += e.left), v.cache = { fits: t.height < e.height, scrollContext: { height: e.height }, element: { margin: t.margin, top: t.offset.top - t.margin.top, left: t.offset.left, width: t.width, height: t.height, bottom: t.offset.top + t.height }, context: { top: n.offset.top, height: n.height, bottom: n.offset.top + n.height } }, v.set.containerSize(), v.set.size(), v.stick(), v.debug("Caching element positions", v.cache);
                            } },
                        get: { direction(e) { let t = "down"; return e = e || S.scrollTop(), void 0 !== v.lastScroll && (v.lastScroll < e ? t = "down" : v.lastScroll > e && (t = "up")), t; },
                            scrollChange(e) { return e = e || S.scrollTop(), v.lastScroll ? e - v.lastScroll : 0; },
                            currentElementScroll() { return v.elementScroll ? v.elementScroll : v.is.top() ? Math.abs(parseInt(w.css("top"), 10)) || 0 : Math.abs(parseInt(w.css("bottom"), 10)) || 0; },
                            elementScroll(e) {
                                e = e || S.scrollTop(); let t = v.cache.element,
                                    n = v.cache.scrollContext,
                                    i = v.get.scrollChange(e),
                                    o = t.height - n.height + p.offset,
                                    a = v.get.currentElementScroll(),
                                    r = a + i; return a = v.cache.fits || r < 0 ? 0 : r > o ? o : r;
                            } },
                        remove: { lastScroll() { delete v.lastScroll; }, elementScroll(e) { delete v.elementScroll; }, offset() { w.css("margin-top", ""); } },
                        set: { offset() { v.verbose("Setting offset on element", p.offset), w.css("margin-top", p.offset); }, containerSize() { const e = a.get(0).tagName; e === "HTML" || e == "body" ? v.determineContainer() : Math.abs(a.outerHeight() - v.cache.context.height) > p.jitter && (v.debug("Context has padding, specifying exact height for container", v.cache.context.height), a.css({ height: v.cache.context.height })); }, minimumSize() { const e = v.cache.element; a.css("min-height", e.height); }, scroll(e) { v.debug("Setting scroll on element", e), v.elementScroll != e && (v.is.top() && w.css("bottom", "").css("top", -e), v.is.bottom() && w.css("top", "").css("bottom", e)); }, size() { v.cache.element.height !== 0 && v.cache.element.width !== 0 && (R.style.setProperty("width", `${v.cache.element.width}px`, "important"), R.style.setProperty("height", `${v.cache.element.height}px`, "important")); } },
                        is: { standardScroll() { return S[0] == t; }, top() { return w.hasClass(h.top); }, bottom() { return w.hasClass(h.bottom); }, initialPosition() { return !v.is.fixed() && !v.is.bound(); }, hidden() { return !w.is(":visible"); }, bound() { return w.hasClass(h.bound); }, fixed() { return w.hasClass(h.fixed); } },
                        stick(e) {
                            var t = e || S.scrollTop(),
                                n = v.cache,
                                i = n.fits,
                                o = n.element,
                                a = n.scrollContext,
                                r = n.context,
                                s = v.is.bottom() && p.pushing ? p.bottomOffset : p.offset,
                                e = { top: t + s, bottom: t + s + a.height },
                                l = (v.get.direction(e.top), i ? 0 : v.get.elementScroll(e.top)),
                                c = !i; o.height !== 0 && (v.is.initialPosition() ? e.top >= r.bottom ? (v.debug("Initial element position is bottom of container"), v.bindBottom()) : e.top > o.top && (o.height + e.top - l >= r.bottom ? (v.debug("Initial element position is bottom of container"), v.bindBottom()) : (v.debug("Initial element position is fixed"), v.fixTop())) : v.is.fixed() ? v.is.top() ? e.top <= o.top ? (v.debug("Fixed element reached top of container"), v.setInitialPosition()) : o.height + e.top - l >= r.bottom ? (v.debug("Fixed element reached bottom of container"), v.bindBottom()) : c && (v.set.scroll(l), v.save.lastScroll(e.top), v.save.elementScroll(l)) : v.is.bottom() && (e.bottom - o.height <= o.top ? (v.debug("Bottom fixed rail has reached top of container"), v.setInitialPosition()) : e.bottom >= r.bottom ? (v.debug("Bottom fixed rail has reached bottom of container"), v.bindBottom()) : c && (v.set.scroll(l), v.save.lastScroll(e.top), v.save.elementScroll(l))) : v.is.bottom() && (e.top <= o.top ? (v.debug("Jumped from bottom fixed to top fixed, most likely used home/end button"), v.setInitialPosition()) : p.pushing ? v.is.bound() && e.bottom <= r.bottom && (v.debug("Fixing bottom attached element to bottom of browser."), v.fixBottom()) : v.is.bound() && e.top <= r.bottom - o.height && (v.debug("Fixing bottom attached element to top of browser."), v.fixTop())));
                        },
                        bindTop() { v.debug("Binding element to top of parent container"), v.remove.offset(), w.css({ left: "", top: "", marginBottom: "" }).removeClass(h.fixed).removeClass(h.bottom).addClass(h.bound).addClass(h.top), p.onTop.call(R), p.onUnstick.call(R); },
                        bindBottom() { v.debug("Binding element to bottom of parent container"), v.remove.offset(), w.css({ left: "", top: "" }).removeClass(h.fixed).removeClass(h.top).addClass(h.bound).addClass(h.bottom), p.onBottom.call(R), p.onUnstick.call(R); },
                        setInitialPosition() { v.debug("Returning to initial position"), v.unfix(), v.unbind(); },
                        fixTop() { v.debug("Fixing element to top of page"), v.set.minimumSize(), v.set.offset(), w.css({ left: v.cache.element.left, bottom: "", marginBottom: "" }).removeClass(h.bound).removeClass(h.bottom).addClass(h.fixed).addClass(h.top), p.onStick.call(R); },
                        fixBottom() { v.debug("Sticking element to bottom of page"), v.set.minimumSize(), v.set.offset(), w.css({ left: v.cache.element.left, bottom: "", marginBottom: "" }).removeClass(h.bound).removeClass(h.top).addClass(h.fixed).addClass(h.bottom), p.onStick.call(R); },
                        unbind() { v.is.bound() && (v.debug("Removing container bound position on element"), v.remove.offset(), w.removeClass(h.bound).removeClass(h.top).removeClass(h.bottom)); },
                        unfix() { v.is.fixed() && (v.debug("Removing fixed position on element"), v.remove.offset(), w.removeClass(h.fixed).removeClass(h.top).removeClass(h.bottom), p.onUnstick.call(R)); },
                        reset() { v.debug("Resetting elements position"), v.unbind(), v.unfix(), v.resetCSS(), v.remove.offset(), v.remove.lastScroll(); },
                        resetCSS() { w.css({ width: "", height: "" }), a.css({ height: "" }); },
                        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, p, t); else { if (void 0 === n) return p[t]; p[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, v, t); else { if (void 0 === n) return v[t]; v[t] = n; } },
                        debug() { !p.silent && p.debug && (p.performance ? v.performance.log(arguments) : (v.debug = Function.prototype.bind.call(console.info, console, `${p.name}:`), v.debug.apply(console, arguments))); },
                        verbose() { !p.silent && p.verbose && p.debug && (p.performance ? v.performance.log(arguments) : (v.verbose = Function.prototype.bind.call(console.info, console, `${p.name}:`), v.verbose.apply(console, arguments))); },
                        error() { p.silent || (v.error = Function.prototype.bind.call(console.error, console, `${p.name}:`), v.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; p.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: R, "Execution Time": n })), clearTimeout(v.performance.timer), v.performance.timer = setTimeout(v.performance.display, 0);
                        },
                            display() {
                                let t = `${p.name}:`,
                                    n = 0; s = !1, clearTimeout(v.performance.timer), e.each(l, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), l = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = T; return n = n || d, i = R || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, u ? (void 0 === T && v.initialize(), v.invoke(c)) : (void 0 !== T && T.invoke("destroy"), v.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.sticky.settings = { name: "Sticky", namespace: "sticky", silent: !1, debug: !1, verbose: !0, performance: !0, pushing: !1, context: !1, container: !1, scrollContext: t, offset: 0, bottomOffset: 0, jitter: 5, observeChanges: !1, onReposition() {}, onScroll() {}, onStick() {}, onUnstick() {}, onTop() {}, onBottom() {}, error: { container: "Sticky element must be inside a relative container", visible: "Element is hidden, you must call refresh after element becomes visible. Use silent setting to surpress this warning in production.", method: "The method you called is not defined.", invalidContext: "Context specified does not exist", elementSize: "Sticky element is larger than its container, cannot create sticky." }, className: { bound: "bound", fixed: "fixed", supported: "native", top: "top", bottom: "bottom" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.tab = function (i) {
        let o,
            a = e(e.isFunction(this) ? t : this),
            r = a.selector || "",
            s = (new Date()).getTime(),
            l = [],
            c = arguments[0],
            u = typeof c === "string",
            d = [].slice.call(arguments, 1),
            f = !1; return a.each(function () {
                let m,
                    g,
                    v,
                    p,
                    h,
                    b,
                    y = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.tab.settings, i) : e.extend({}, e.fn.tab.settings),
                    x = y.className,
                    C = y.metadata,
                    w = y.selector,
                    k = y.error,
                    S = `.${y.namespace}`,
                    T = `module-${y.namespace}`,
                    A = e(this),
                    R = {},
                    P = !0,
                    E = 0,
                    F = this,
                    O = A.data(T); h = { initialize() { h.debug("Initializing tab menu item", A), h.fix.callbacks(), h.determineTabs(), h.debug("Determining tabs", y.context, g), y.auto && h.set.auto(), h.bind.events(), y.history && !f && (h.initializeHistory(), f = !0), h.instantiate(); },
                        instantiate() { h.verbose("Storing instance of module", h), O = h, A.data(T, h); },
                        destroy() { h.debug("Destroying tabs", A), A.removeData(T).off(S); },
                        bind: { events() { e.isWindow(F) || (h.debug("Attaching tab activation events to element", A), A.on(`click${S}`, h.event.click)); } },
                        determineTabs() { let t; y.context === "parent" ? (A.closest(w.ui).length > 0 ? (t = A.closest(w.ui), h.verbose("Using closest UI element as parent", t)) : t = A, m = t.parent(), h.verbose("Determined parent element for creating context", m)) : y.context ? (m = e(y.context), h.verbose("Using selector for tab context", y.context, m)) : m = e("body"), y.childrenOnly ? (g = m.children(w.tabs), h.debug("Searching tab context children for tabs", m, g)) : (g = m.find(w.tabs), h.debug("Searching tab context for tabs", m, g)); },
                        fix: { callbacks() { e.isPlainObject(i) && (i.onTabLoad || i.onTabInit) && (i.onTabLoad && (i.onLoad = i.onTabLoad, delete i.onTabLoad, h.error(k.legacyLoad, i.onLoad)), i.onTabInit && (i.onFirstLoad = i.onTabInit, delete i.onTabInit, h.error(k.legacyInit, i.onFirstLoad)), y = e.extend(!0, {}, e.fn.tab.settings, i)); } },
                        initializeHistory() { if (h.debug("Initializing page state"), void 0 === e.address) return h.error(k.state), !1; if (y.historyType == "state") { if (h.debug("Using HTML5 to manage state"), y.path === !1) return h.error(k.path), !1; e.address.history(!0).state(y.path); }e.address.bind("change", h.event.history.change); },
                        event: { click(t) { const n = e(this).data(C.tab); void 0 !== n ? (y.history ? (h.verbose("Updating page state", t), e.address.value(n)) : (h.verbose("Changing tab", t), h.changeTab(n)), t.preventDefault()) : h.debug("No tab specified"); },
                            history: { change(t) {
                                let n = t.pathNames.join("/") || h.get.initialPath(),
                                    i = y.templates.determineTitle(n) || !1; h.performance.display(), h.debug("History change event", n, t), b = t, void 0 !== n && h.changeTab(n), i && e.address.title(i);
                            } } },
                        refresh() { v && (h.debug("Refreshing tab", v), h.changeTab(v)); },
                        cache: { read(e) { return void 0 !== e && R[e]; }, add(e, t) { e = e || v, h.debug("Adding cached content for", e), R[e] = t; }, remove(e) { e = e || v, h.debug("Removing cached content for", e), delete R[e]; } },
                        set: { auto() { const t = typeof y.path === "string" ? `${y.path.replace(/\/$/, "")}/{$tab}` : "/{$tab}"; h.verbose("Setting up automatic tab retrieval from server", t), e.isPlainObject(y.apiSettings) ? y.apiSettings.url = t : y.apiSettings = { url: t }; }, loading(e) { const t = h.get.tabElement(e); t.hasClass(x.loading) || (h.verbose("Setting loading state for", t), t.addClass(x.loading).siblings(g).removeClass(`${x.active} ${x.loading}`), t.length > 0 && y.onRequest.call(t[0], e)); }, state(t) { e.address.value(t); } },
                        changeTab(n) {
                            let i = t.history && t.history.pushState,
                                o = i && y.ignoreFirstLoad && P,
                                a = y.auto || e.isPlainObject(y.apiSettings),
                                r = a && !o ? h.utilities.pathToArray(n) : h.get.defaultPathArray(n); n = h.utilities.arrayToPath(r), e.each(r, (t, i) => {
                                    let s,
                                        l,
                                        c,
                                        u,
                                        d = r.slice(0, t + 1),
                                        f = h.utilities.arrayToPath(d),
                                        g = h.is.tab(f),
                                        w = t + 1 == r.length,
                                        S = h.get.tabElement(f); if (h.verbose("Looking for tab", i), g) { if (h.verbose("Tab was found", i), v = f, p = h.utilities.filterArray(r, d), w ? u = !0 : (l = r.slice(0, t + 2), c = h.utilities.arrayToPath(l), (u = !h.is.tab(c)) && h.verbose("Tab parameters found", l)), u && a) return o ? (h.debug("Ignoring remote content on first tab load", f), P = !1, h.cache.add(n, S.html()), h.activate.all(f), y.onFirstLoad.call(S[0], f, p, b), y.onLoad.call(S[0], f, p, b)) : (h.activate.navigation(f), h.fetch.content(f, n)), !1; h.debug("Opened local tab", f), h.activate.all(f), h.cache.read(f) || (h.cache.add(f, !0), h.debug("First time tab loaded calling tab init"), y.onFirstLoad.call(S[0], f, p, b)), y.onLoad.call(S[0], f, p, b); } else { if (n.search("/") != -1 || n === "") return h.error(k.missingTab, A, m, f), !1; if (s = e(`#${n}, a[name="${n}"]`), f = s.closest("[data-tab]").data(C.tab), S = h.get.tabElement(f), s && s.length > 0 && f) return h.debug("Anchor link used, opening parent tab", S, s), S.hasClass(x.active) || setTimeout(() => { h.scrollTo(s); }, 0), h.activate.all(f), h.cache.read(f) || (h.cache.add(f, !0), h.debug("First time tab loaded calling tab init"), y.onFirstLoad.call(S[0], f, p, b)), y.onLoad.call(S[0], f, p, b), !1; }
                                });
                        },
                        scrollTo(t) { const i = !!(t && t.length > 0) && t.offset().top; i !== !1 && (h.debug("Forcing scroll to an in-page link in a hidden tab", i, t), e(n).scrollTop(i)); },
                        update: { content(t, n, i) {
                            let o = h.get.tabElement(t),
                                a = o[0]; i = void 0 !== i ? i : y.evaluateScripts, typeof y.cacheType === "string" && y.cacheType.toLowerCase() == "dom" && typeof n !== "string" ? o.empty().append(e(n).clone(!0)) : i ? (h.debug("Updating HTML and evaluating inline scripts", t, n), o.html(n)) : (h.debug("Updating HTML", t, n), a.innerHTML = n);
                        } },
                        fetch: { content(t, n) {
                            let i,
                                o,
                                a = h.get.tabElement(t),
                                r = { dataType: "html", encodeParameters: !1, on: "now", cache: y.alwaysRefresh, headers: { "X-Remote": !0 }, onSuccess(e) { y.cacheType == "response" && h.cache.add(n, e), h.update.content(t, e), t == v ? (h.debug("Content loaded", t), h.activate.tab(t)) : h.debug("Content loaded in background", t), y.onFirstLoad.call(a[0], t, p, b), y.onLoad.call(a[0], t, p, b), y.loadOnce ? h.cache.add(n, !0) : typeof y.cacheType === "string" && y.cacheType.toLowerCase() == "dom" && a.children().length > 0 ? setTimeout(() => { let e = a.children().clone(!0); e = e.not("script"), h.cache.add(n, e); }, 0) : h.cache.add(n, a.html()); }, urlData: { tab: n } },
                                s = a.api("get request") || !1,
                                l = s && s.state() === "pending"; n = n || t, o = h.cache.read(n), y.cache && o ? (h.activate.tab(t), h.debug("Adding cached content", n), y.loadOnce || (y.evaluateScripts == "once" ? h.update.content(t, o, !1) : h.update.content(t, o)), y.onLoad.call(a[0], t, p, b)) : l ? (h.set.loading(t), h.debug("Content is already loading", n)) : void 0 !== e.api ? (i = e.extend(!0, {}, y.apiSettings, r), h.debug("Retrieving remote content", n, i), h.set.loading(t), a.api(i)) : h.error(k.api);
                        } },
                        activate: { all(e) { h.activate.tab(e), h.activate.navigation(e); },
                            tab(e) {
                                let t = h.get.tabElement(e),
                                    n = y.deactivate == "siblings" ? t.siblings(g) : g.not(t),
                                    i = t.hasClass(x.active); h.verbose("Showing tab content for", t), i || (t.addClass(x.active), n.removeClass(`${x.active} ${x.loading}`), t.length > 0 && y.onVisible.call(t[0], e));
                            },
                            navigation(e) {
                                let t = h.get.navElement(e),
                                    n = y.deactivate == "siblings" ? t.siblings(a) : a.not(t),
                                    i = t.hasClass(x.active); h.verbose("Activating tab navigation for", t, e), i || (t.addClass(x.active), n.removeClass(`${x.active} ${x.loading}`));
                            } },
                        deactivate: { all() { h.deactivate.navigation(), h.deactivate.tabs(); }, navigation() { a.removeClass(x.active); }, tabs() { g.removeClass(`${x.active} ${x.loading}`); } },
                        is: { tab(e) { return void 0 !== e && h.get.tabElement(e).length > 0; } },
                        get: { initialPath() { return a.eq(0).data(C.tab) || g.eq(0).data(C.tab); },
                            path() { return e.address.value(); },
                            defaultPathArray(e) { return h.utilities.pathToArray(h.get.defaultPath(e)); },
                            defaultPath(e) {
                                let t = a.filter(`[data-${C.tab}^="${e}/"]`).eq(0),
                                    n = t.data(C.tab) || !1; if (n) { if (h.debug("Found default tab", n), E < y.maxDepth) return E++, h.get.defaultPath(n); h.error(k.recursion); } else h.debug("No default tabs found for", e, g); return E = 0, e;
                            },
                            navElement(e) { return e = e || v, a.filter(`[data-${C.tab}="${e}"]`); },
                            tabElement(e) {
                                let t,
                                    n,
                                    i,
                                    o; return e = e || v, i = h.utilities.pathToArray(e), o = h.utilities.last(i), t = g.filter(`[data-${C.tab}="${e}"]`), n = g.filter(`[data-${C.tab}="${o}"]`), t.length > 0 ? t : n;
                            },
                            tab() { return v; } },
                        utilities: { filterArray(t, n) { return e.grep(t, t => e.inArray(t, n) == -1); }, last(t) { return !!e.isArray(t) && t[t.length - 1]; }, pathToArray(e) { return void 0 === e && (e = v), typeof e === "string" ? e.split("/") : [e]; }, arrayToPath(t) { return !!e.isArray(t) && t.join("/"); } },
                        setting(t, n) {
                            if (h.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, y, t); else {
                                if (void 0 === n) return y[t]
;e.isPlainObject(y[t]) ? e.extend(!0, y[t], n) : y[t] = n;
                            }
                        },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, h, t); else { if (void 0 === n) return h[t]; h[t] = n; } },
                        debug() { !y.silent && y.debug && (y.performance ? h.performance.log(arguments) : (h.debug = Function.prototype.bind.call(console.info, console, `${y.name}:`), h.debug.apply(console, arguments))); },
                        verbose() { !y.silent && y.verbose && y.debug && (y.performance ? h.performance.log(arguments) : (h.verbose = Function.prototype.bind.call(console.info, console, `${y.name}:`), h.verbose.apply(console, arguments))); },
                        error() { y.silent || (h.error = Function.prototype.bind.call(console.error, console, `${y.name}:`), h.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; y.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: F, "Execution Time": n })), clearTimeout(h.performance.timer), h.performance.timer = setTimeout(h.performance.display, 500);
                        },
                            display() {
                                let t = `${y.name}:`,
                                    n = 0; s = !1, clearTimeout(h.performance.timer), e.each(l, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), l = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = O; return n = n || d, i = F || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (h.error(k.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, u ? (void 0 === O && h.initialize(), h.invoke(c)) : (void 0 !== O && O.invoke("destroy"), h.initialize());
            }), void 0 !== o ? o : this;
    }, e.tab = function () { e(t).tab.apply(this, arguments); }, e.fn.tab.settings = { name: "Tab", namespace: "tab", silent: !1, debug: !1, verbose: !1, performance: !0, auto: !1, history: !1, historyType: "hash", path: !1, context: !1, childrenOnly: !1, maxDepth: 25, deactivate: "siblings", alwaysRefresh: !1, cache: !0, loadOnce: !1, cacheType: "response", ignoreFirstLoad: !1, apiSettings: !1, evaluateScripts: "once", onFirstLoad(e, t, n) {}, onLoad(e, t, n) {}, onVisible(e, t, n) {}, onRequest(e, t, n) {}, templates: { determineTitle(e) {} }, error: { api: "You attempted to load content without API module", method: "The method you called is not defined", missingTab: "Activated tab cannot be found. Tabs are case-sensitive.", noContent: "The tab you specified is missing a content url.", path: "History enabled, but no path was specified", recursion: "Max recursive depth reached", legacyInit: "onTabInit has been renamed to onFirstLoad in 2.0, please adjust your code.", legacyLoad: "onTabLoad has been renamed to onLoad in 2.0. Please adjust your code", state: "History requires Asual's Address library <https://github.com/asual/jquery-address>" }, metadata: { tab: "tab", loaded: "loaded", promise: "promise" }, className: { loading: "loading", active: "active" }, selector: { tabs: ".ui.tab", ui: ".ui" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.transition = function () {
        let i,
            o = e(this),
            a = o.selector || "",
            r = (new Date()).getTime(),
            s = [],
            l = arguments,
            c = l[0],
            u = [].slice.call(arguments, 1),
            d = typeof c === "string"; t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame; return o.each(function (t) {
                let f,
                    m,
                    g,
                    v,
                    p,
                    h,
                    b,
                    y,
                    x,
                    C = e(this),
                    w = this; x = { initialize() { f = x.get.settings.apply(w, l), v = f.className, g = f.error, p = f.metadata, y = `.${f.namespace}`, b = `module-${f.namespace}`, m = C.data(b) || x, h = x.get.animationEndEvent(), d && (d = x.invoke(c)), d === !1 && (x.verbose("Converted arguments into settings object", f), f.interval ? x.delay(f.animate) : x.animate(), x.instantiate()); },
                        instantiate() { x.verbose("Storing instance of module", x), m = x, C.data(b, m); },
                        destroy() { x.verbose("Destroying previous module for", w), C.removeData(b); },
                        refresh() { x.verbose("Refreshing display type on next animation"), delete x.displayType; },
                        forceRepaint() {
                            x.verbose("Forcing element repaint"); let e = C.parent(),
                                t = C.next(); t.length === 0 ? C.detach().appendTo(e) : C.detach().insertBefore(t);
                        },
                        repaint() { x.verbose("Repainting element"); w.offsetWidth; },
                        delay(e) {
                            let n,
                                i,
                                a = x.get.animationDirection(); a || (a = x.can.transition() ? x.get.direction() : "static"), e = void 0 !== e ? e : f.interval, n = f.reverse == "auto" && a == v.outward, i = n || f.reverse == 1 ? (o.length - t) * f.interval : t * f.interval, x.debug("Delaying animation by", i), setTimeout(x.animate, i);
                        },
                        animate(e) { if (f = e || f, !x.is.supported()) return x.error(g.support), !1; if (x.debug("Preparing animation", f.animation), x.is.animating()) { if (f.queue) return !f.allowRepeats && x.has.direction() && x.is.occurring() && x.queuing !== !0 ? x.debug("Animation is currently occurring, preventing queueing same animation", f.animation) : x.queue(f.animation), !1; if (!f.allowRepeats && x.is.occurring()) return x.debug("Animation is already occurring, will not execute repeated animation", f.animation), !1; x.debug("New animation started, completing previous early", f.animation), m.complete(); }x.can.animate() ? x.set.animating(f.animation) : x.error(g.noAnimation, f.animation, w); },
                        reset() { x.debug("Resetting animation to beginning conditions"), x.remove.animationCallbacks(), x.restore.conditions(), x.remove.animating(); },
                        queue(e) { x.debug("Queueing animation of", e), x.queuing = !0, C.one(`${h}.queue${y}`, function () { x.queuing = !1, x.repaint(), x.animate.apply(this, f); }); },
                        complete(e) { x.debug("Animation complete", f.animation), x.remove.completeCallback(), x.remove.failSafe(), x.is.looping() || (x.is.outward() ? (x.verbose("Animation is outward, hiding element"), x.restore.conditions(), x.hide()) : x.is.inward() ? (x.verbose("Animation is outward, showing element"), x.restore.conditions(), x.show()) : (x.verbose("Static animation completed"), x.restore.conditions(), f.onComplete.call(w))); },
                        force: { visible() {
                            let e = C.attr("style"),
                                t = x.get.userStyle(),
                                n = x.get.displayType(),
                                i = `${t}display: ${n} !important;`,
                                o = C.css("display"),
                                a = void 0 === e || e === ""; o !== n ? (x.verbose("Overriding default display to show element", n), C.attr("style", i)) : a && C.removeAttr("style");
                        },
                            hidden() {
                                let e = C.attr("style"),
                                    t = C.css("display"),
                                    n = void 0 === e || e === ""; t === "none" || x.is.hidden() ? n && C.removeAttr("style") : (x.verbose("Overriding default display to hide element"), C.css("display", "none"));
                            } },
                        has: { direction(t) { let n = !1; return t = t || f.animation, typeof t === "string" && (t = t.split(" "), e.each(t, (e, t) => { t !== v.inward && t !== v.outward || (n = !0); })), n; }, inlineDisplay() { const t = C.attr("style") || ""; return e.isArray(t.match(/display.*?;/, "")); } },
                        set: { animating(e) { let t; x.remove.completeCallback(), e = e || f.animation, t = x.get.animationClass(e), x.save.animation(t), x.force.visible(), x.remove.hidden(), x.remove.direction(), x.start.animation(t); }, duration(e, t) { t = t || f.duration, ((t = typeof t === "number" ? `${t}ms` : t) || t === 0) && (x.verbose("Setting animation duration", t), C.css({ "animation-duration": t })); }, direction(e) { e = e || x.get.direction(), e == v.inward ? x.set.inward() : x.set.outward(); }, looping() { x.debug("Transition set to loop"), C.addClass(v.looping); }, hidden() { C.addClass(v.transition).addClass(v.hidden); }, inward() { x.debug("Setting direction to inward"), C.removeClass(v.outward).addClass(v.inward); }, outward() { x.debug("Setting direction to outward"), C.removeClass(v.inward).addClass(v.outward); }, visible() { C.addClass(v.transition).addClass(v.visible); } },
                        start: { animation(e) { e = e || x.get.animationClass(), x.debug("Starting tween", e), C.addClass(e).one(`${h}.complete${y}`, x.complete), f.useFailSafe && x.add.failSafe(), x.set.duration(f.duration), f.onStart.call(w); } },
                        save: { animation(e) { x.cache || (x.cache = {}), x.cache.animation = e; }, displayType(e) { e !== "none" && C.data(p.displayType, e); }, transitionExists(t, n) { e.fn.transition.exists[t] = n, x.verbose("Saving existence of transition", t, n); } },
                        restore: { conditions() { const e = x.get.currentAnimation(); e && (C.removeClass(e), x.verbose("Removing animation class", x.cache)), x.remove.duration(); } },
                        add: { failSafe() { const e = x.get.duration(); x.timer = setTimeout(() => { C.triggerHandler(h); }, e + f.failSafeDelay), x.verbose("Adding fail safe timer", x.timer); } },
                        remove: { animating() { C.removeClass(v.animating); }, animationCallbacks() { x.remove.queueCallback(), x.remove.completeCallback(); }, queueCallback() { C.off(`.queue${y}`); }, completeCallback() { C.off(`.complete${y}`); }, display() { C.css("display", ""); }, direction() { C.removeClass(v.inward).removeClass(v.outward); }, duration() { C.css("animation-duration", ""); }, failSafe() { x.verbose("Removing fail safe timer", x.timer), x.timer && clearTimeout(x.timer); }, hidden() { C.removeClass(v.hidden); }, visible() { C.removeClass(v.visible); }, looping() { x.debug("Transitions are no longer looping"), x.is.looping() && (x.reset(), C.removeClass(v.looping)); }, transition() { C.removeClass(v.visible).removeClass(v.hidden); } },
                        get: { settings(t, n, i) { return typeof t === "object" ? e.extend(!0, {}, e.fn.transition.settings, t) : typeof i === "function" ? e.extend({}, e.fn.transition.settings, { animation: t, onComplete: i, duration: n }) : typeof n === "string" || typeof n === "number" ? e.extend({}, e.fn.transition.settings, { animation: t, duration: n }) : typeof n === "object" ? e.extend({}, e.fn.transition.settings, n, { animation: t }) : typeof n === "function" ? e.extend({}, e.fn.transition.settings, { animation: t, onComplete: n }) : e.extend({}, e.fn.transition.settings, { animation: t }); },
                            animationClass(e) {
                                let t = e || f.animation,
                                    n = x.can.transition() && !x.has.direction() ? `${x.get.direction()} ` : ""; return `${v.animating} ${v.transition} ${n}${t}`;
                            },
                            currentAnimation() { return !(!x.cache || void 0 === x.cache.animation) && x.cache.animation; },
                            currentDirection() { return x.is.inward() ? v.inward : v.outward; },
                            direction() { return x.is.hidden() || !x.is.visible() ? v.inward : v.outward; },
                            animationDirection(t) { let n; return t = t || f.animation, typeof t === "string" && (t = t.split(" "), e.each(t, (e, t) => { t === v.inward ? n = v.inward : t === v.outward && (n = v.outward); })), !!n && n; },
                            duration(e) { return e = e || f.duration, e === !1 && (e = C.css("animation-duration") || 0), typeof e === "string" ? e.indexOf("ms") > -1 ? parseFloat(e) : 1e3 * parseFloat(e) : e; },
                            displayType(e) { return e = void 0 === e || e, f.displayType ? f.displayType : (e && void 0 === C.data(p.displayType) && x.can.transition(!0), C.data(p.displayType)); },
                            userStyle(e) { return e = e || C.attr("style") || "", e.replace(/display.*?;/, ""); },
                            transitionExists(t) { return e.fn.transition.exists[t]; },
                            animationStartEvent() {
                                let e,
                                    t = n.createElement("div"),
                                    i = { animation: "animationstart", OAnimation: "oAnimationStart", MozAnimation: "mozAnimationStart", WebkitAnimation: "webkitAnimationStart" }; for (e in i) if (void 0 !== t.style[e]) return i[e]; return !1;
                            },
                            animationEndEvent() {
                                let e,
                                    t = n.createElement("div"),
                                    i = { animation: "animationend", OAnimation: "oAnimationEnd", MozAnimation: "mozAnimationEnd", WebkitAnimation: "webkitAnimationEnd" }; for (e in i) if (void 0 !== t.style[e]) return i[e]; return !1;
                            } },
                        can: { transition(t) {
                            let n,
                                i,
                                o,
                                a,
                                r,
                                s,
                                l = f.animation,
                                c = x.get.transitionExists(l),
                                u = x.get.displayType(!1); if (void 0 === c || t) { if (x.verbose("Determining whether animation exists"), n = C.attr("class"), i = C.prop("tagName"), o = e(`<${i} />`).addClass(n).insertAfter(C), a = o.addClass(l).removeClass(v.inward).removeClass(v.outward).addClass(v.animating).addClass(v.transition).css("animationName"), r = o.addClass(v.inward).css("animationName"), u || (u = o.attr("class", n).removeAttr("style").removeClass(v.hidden).removeClass(v.visible).show().css("display"), x.verbose("Determining final display state", u), x.save.displayType(u)), o.remove(), a != r)x.debug("Direction exists for animation", l), s = !0; else { if (a == "none" || !a) return void x.debug("No animation defined in css", l); x.debug("Static animation found", l, u), s = !1; }x.save.transitionExists(l, s); } return void 0 !== c ? c : s;
                        },
                            animate() { return void 0 !== x.can.transition(); } },
                        is: { animating() { return C.hasClass(v.animating); }, inward() { return C.hasClass(v.inward); }, outward() { return C.hasClass(v.outward); }, looping() { return C.hasClass(v.looping); }, occurring(e) { return e = e || f.animation, e = `.${e.replace(" ", ".")}`, C.filter(e).length > 0; }, visible() { return C.is(":visible"); }, hidden() { return C.css("visibility") === "hidden"; }, supported() { return h !== !1; } },
                        hide() { x.verbose("Hiding element"), x.is.animating() && x.reset(), w.blur(), x.remove.display(), x.remove.visible(), x.set.hidden(), x.force.hidden(), f.onHide.call(w), f.onComplete.call(w); },
                        show(e) { x.verbose("Showing element", e), x.remove.hidden(), x.set.visible(), x.force.visible(), f.onShow.call(w), f.onComplete.call(w); },
                        toggle() { x.is.visible() ? x.hide() : x.show(); },
                        stop() { x.debug("Stopping current animation"), C.triggerHandler(h); },
                        stopAll() { x.debug("Stopping all animation"), x.remove.queueCallback(), C.triggerHandler(h); },
                        clear: { queue() { x.debug("Clearing animation queue"), x.remove.queueCallback(); } },
                        enable() { x.verbose("Starting animation"), C.removeClass(v.disabled); },
                        disable() { x.debug("Stopping animation"), C.addClass(v.disabled); },
                        setting(t, n) { if (x.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, f, t); else { if (void 0 === n) return f[t]; e.isPlainObject(f[t]) ? e.extend(!0, f[t], n) : f[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, x, t); else { if (void 0 === n) return x[t]; x[t] = n; } },
                        debug() { !f.silent && f.debug && (f.performance ? x.performance.log(arguments) : (x.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), x.debug.apply(console, arguments))); },
                        verbose() { !f.silent && f.verbose && f.debug && (f.performance ? x.performance.log(arguments) : (x.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), x.verbose.apply(console, arguments))); },
                        error() { f.silent || (x.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), x.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; f.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: w, "Execution Time": n })), clearTimeout(x.performance.timer), x.performance.timer = setTimeout(x.performance.display, 500);
                        },
                            display() {
                                let t = `${f.name}:`,
                                    n = 0; r = !1, clearTimeout(x.performance.timer), e.each(s, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, a && (t += ` '${a}'`), o.length > 1 && (t += ` (${o.length})`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, n, o) {
                            let a,
                                r,
                                s,
                                l = m; return n = n || u, o = w || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] && (r = l[i], !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), void 0 !== r && r;
                        } }, x.initialize();
            }), void 0 !== i ? i : this;
    }, e.fn.transition.exists = {}, e.fn.transition.settings = { name: "Transition", silent: !1, debug: !1, verbose: !1, performance: !0, namespace: "transition", interval: 0, reverse: "auto", onStart() {}, onComplete() {}, onShow() {}, onHide() {}, useFailSafe: !0, failSafeDelay: 100, allowRepeats: !1, displayType: !1, animation: "fade", duration: !1, queue: !0, metadata: { displayType: "display" }, className: { animating: "animating", disabled: "disabled", hidden: "hidden", inward: "in", loading: "loading", looping: "looping", outward: "out", transition: "transition", visible: "visible" }, error: { noAnimation: "Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.", repeated: "That animation is already occurring, cancelling repeated animation", method: "The method you called is not defined", support: "This browser does not support CSS animations" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    var t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(); e.api = e.fn.api = function (n) {
        let i,
            o = e(e.isFunction(this) ? t : this),
            a = o.selector || "",
            r = (new Date()).getTime(),
            s = [],
            l = arguments[0],
            c = typeof l === "string",
            u = [].slice.call(arguments, 1); return o.each(function () {
                let o,
                    d,
                    f,
                    m,
                    g,
                    v = e.isPlainObject(n) ? e.extend(!0, {}, e.fn.api.settings, n) : e.extend({}, e.fn.api.settings),
                    p = v.namespace,
                    h = v.metadata,
                    b = v.selector,
                    y = v.error,
                    x = v.className,
                    C = `.${p}`,
                    w = `module-${p}`,
                    k = e(this),
                    S = k.closest(b.form),
                    T = v.stateContext ? e(v.stateContext) : k,
                    A = this,
                    R = T[0],
                    P = k.data(w); g = { initialize() { c || g.bind.events(), g.instantiate(); },
                        instantiate() { g.verbose("Storing instance of module", g), P = g, k.data(w, P); },
                        destroy() { g.verbose("Destroying previous module for", A), k.removeData(w).off(C); },
                        bind: { events() { const e = g.get.event(); e ? (g.verbose("Attaching API events to element", e), k.on(e + C, g.event.trigger)) : v.on == "now" && (g.debug("Querying API endpoint immediately"), g.query()); } },
                        decode: { json(e) { if (void 0 !== e && typeof e === "string") try { e = JSON.parse(e); } catch (e) {} return e; } },
                        read: { cachedResponse(e) { let n; return void 0 === t.Storage ? void g.error(y.noStorage) : (n = sessionStorage.getItem(e), g.debug("Using cached response", e, n), n = g.decode.json(n)); } },
                        write: { cachedResponse(n, i) { return i && i === "" ? void g.debug("Response empty, not caching", i) : void 0 === t.Storage ? void g.error(y.noStorage) : (e.isPlainObject(i) && (i = JSON.stringify(i)), sessionStorage.setItem(n, i), void g.verbose("Storing cached response for url", n, i)); } },
                        query() { if (g.is.disabled()) return void g.debug("Element is disabled API request aborted"); if (g.is.loading()) { if (!v.interruptRequests) return void g.debug("Cancelling request, previous request is still pending"); g.debug("Interrupting previous request"), g.abort(); } if (v.defaultData && e.extend(!0, v.urlData, g.get.defaultData()), v.serializeForm && (v.data = g.add.formData(v.data)), (d = g.get.settings()) === !1) return g.cancelled = !0, void g.error(y.beforeSend); if (g.cancelled = !1, !(f = g.get.templatedURL()) && !g.is.mocked()) return void g.error(y.missingURL); if ((f = g.add.urlData(f)) || g.is.mocked()) { if (d.url = v.base + f, o = e.extend(!0, {}, v, { type: v.method || v.type, data: void 0, url: v.base + f, beforeSend: v.beforeXHR, success() {}, failure() {}, complete() {} }), g.debug("Querying URL", o.url), g.verbose("Using AJAX settings", o), v.cache === "local" && g.read.cachedResponse(f)) return g.debug("Response returned from local cache"), g.request = g.create.request(), void g.request.resolveWith(R, [g.read.cachedResponse(f)]); v.throttle ? v.throttleFirstRequest || g.timer ? (g.debug("Throttling request", v.throttle), clearTimeout(g.timer), g.timer = setTimeout(() => { g.timer && delete g.timer, g.debug("Sending throttled request", void 0, o.method), g.send.request(); }, v.throttle)) : (g.debug("Sending request", void 0, o.method), g.send.request(), g.timer = setTimeout(() => {}, v.throttle)) : (g.debug("Sending request", void 0, o.method), g.send.request()); } },
                        should: { removeError() { return v.hideError === !0 || v.hideError === "auto" && !g.is.form(); } },
                        is: { disabled() { return k.filter(b.disabled).length > 0; }, expectingJSON() { return v.dataType === "json" || v.dataType === "jsonp"; }, form() { return k.is("form") || T.is("form"); }, mocked() { return v.mockResponse || v.mockResponseAsync || v.response || v.responseAsync; }, input() { return k.is("input"); }, loading() { return !!g.request && g.request.state() == "pending"; }, abortedRequest(e) { return e && void 0 !== e.readyState && e.readyState === 0 ? (g.verbose("XHR request determined to be aborted"), !0) : (g.verbose("XHR request was not aborted"), !1); }, validResponse(t) { return g.is.expectingJSON() && e.isFunction(v.successTest) ? (g.debug("Checking JSON returned success", v.successTest, t), v.successTest(t) ? (g.debug("Response passed success test", t), !0) : (g.debug("Response failed success test", t), !1)) : (g.verbose("Response is not JSON, skipping validation", v.successTest, t), !0); } },
                        was: { cancelled() { return g.cancelled || !1; }, succesful() { return g.request && g.request.state() == "resolved"; }, failure() { return g.request && g.request.state() == "rejected"; }, complete() { return g.request && (g.request.state() == "resolved" || g.request.state() == "rejected"); } },
                        add: { urlData(t, n) {
                            let i,
                                o; return t && (i = t.match(v.regExp.required), o = t.match(v.regExp.optional), n = n || v.urlData, i && (g.debug("Looking for required URL variables", i), e.each(i, (i, o) => {
                                    let a = o.indexOf("$") !== -1 ? o.substr(2, o.length - 3) : o.substr(1, o.length - 2),
                                        r = e.isPlainObject(n) && void 0 !== n[a] ? n[a] : void 0 !== k.data(a) ? k.data(a) : void 0 !== T.data(a) ? T.data(a) : n[a]; if (void 0 === r) return g.error(y.requiredParameter, a, t), t = !1, !1; g.verbose("Found required variable", a, r), r = v.encodeParameters ? g.get.urlEncodedValue(r) : r, t = t.replace(o, r);
                                })), o && (g.debug("Looking for optional URL variables", i), e.each(o, (i, o) => {
                                    let a = o.indexOf("$") !== -1 ? o.substr(3, o.length - 4) : o.substr(2, o.length - 3),
                                        r = e.isPlainObject(n) && void 0 !== n[a] ? n[a] : void 0 !== k.data(a) ? k.data(a) : void 0 !== T.data(a) ? T.data(a) : n[a]; void 0 !== r ? (g.verbose("Optional variable Found", a, r), t = t.replace(o, r)) : (g.verbose("Optional variable not found", a), t = t.indexOf(`/${o}`) !== -1 ? t.replace(`/${o}`, "") : t.replace(o, ""));
                                }))), t;
                        },
                            formData(t) {
                                let n,
                                    i = void 0 !== e.fn.serializeObject,
                                    o = i ? S.serializeObject() : S.serialize(); return t = t || v.data, n = e.isPlainObject(t), n ? i ? (g.debug("Extending existing data with form data", t, o), t = e.extend(!0, {}, t, o)) : (g.error(y.missingSerialize), g.debug("Cant extend data. Replacing data with form data", t, o), t = o) : (g.debug("Adding form data", o), t = o), t;
                            } },
                        send: { request() { g.set.loading(), g.request = g.create.request(), g.is.mocked() ? g.mockedXHR = g.create.mockedXHR() : g.xhr = g.create.xhr(), v.onRequest.call(R, g.request, g.xhr); } },
                        event: { trigger(e) { g.query(), e.type != "submit" && e.type != "click" || e.preventDefault(); },
                            xhr: { always() {},
                                done(t, n, i) {
                                    let o = this,
                                        a = (new Date()).getTime() - m,
                                        r = v.loadingDuration - a,
                                        s = !!e.isFunction(v.onResponse) && (g.is.expectingJSON() ? v.onResponse.call(o, e.extend(!0, {}, t)) : v.onResponse.call(o, t)); r = r > 0 ? r : 0, s && (g.debug("Modified API response in onResponse callback", v.onResponse, s, t), t = s), r > 0 && g.debug("Response completed early delaying state change by", r), setTimeout(() => { g.is.validResponse(t) ? g.request.resolveWith(o, [t, i]) : g.request.rejectWith(o, [i, "invalid"]); }, r);
                                },
                                fail(e, t, n) {
                                    let i = this,
                                        o = (new Date()).getTime() - m,
                                        a = v.loadingDuration - o; a = a > 0 ? a : 0, a > 0 && g.debug("Response completed early delaying state change by", a), setTimeout(() => { g.is.abortedRequest(e) ? g.request.rejectWith(i, [e, "aborted", n]) : g.request.rejectWith(i, [e, "error", t, n]); }, a);
                                } },
                            request: { done(e, t) { g.debug("Successful API Response", e), v.cache === "local" && f && (g.write.cachedResponse(f, e), g.debug("Saving server response locally", g.cache)), v.onSuccess.call(R, e, k, t); },
                                complete(e, t) {
                                    let n,
                                        i; g.was.succesful() ? (i = e, n = t) : (n = e, i = g.get.responseFromXHR(n)), g.remove.loading(), v.onComplete.call(R, i, k, n);
                                },
                                fail(e, t, n) {
                                    let i = g.get.responseFromXHR(e),
                                        a = g.get.errorFromRequest(i, t, n); if (t == "aborted") return g.debug("XHR Aborted (Most likely caused by page navigation or CORS Policy)", t, n), v.onAbort.call(R, t, k, e), !0; t == "invalid" ? g.debug("JSON did not pass success test. A server-side error has most likely occurred", i) : t == "error" && void 0 !== e && (g.debug("XHR produced a server error", t, n), e.status != 200 && void 0 !== n && n !== "" && g.error(y.statusMessage + n, o.url), v.onError.call(R, a, k, e)), v.errorDuration && t !== "aborted" && (g.debug("Adding error state"), g.set.error(), g.should.removeError() && setTimeout(g.remove.error, v.errorDuration)), g.debug("API Request failed", a, e), v.onFailure.call(R, i, k, e);
                                } } },
                        create: { request() { return e.Deferred().always(g.event.request.complete).done(g.event.request.done).fail(g.event.request.fail); },
                            mockedXHR() {
                                let t,
                                    n,
                                    i,
                                    o = v.mockResponse || v.response,
                                    a = v.mockResponseAsync || v.responseAsync; return i = e.Deferred().always(g.event.xhr.complete).done(g.event.xhr.done).fail(g.event.xhr.fail), o ? (e.isFunction(o) ? (g.debug("Using specified synchronous callback", o), n = o.call(R, d)) : (g.debug("Using settings specified response", o), n = o), i.resolveWith(R, [n, !1, { responseText: n }])) : e.isFunction(a) && (t = function (e) { g.debug("Async callback returned response", e), e ? i.resolveWith(R, [e, !1, { responseText: e }]) : i.rejectWith(R, [{ responseText: e }, !1, !1]); }, g.debug("Using specified async response callback", a), a.call(R, d, t)), i;
                            },
                            xhr() { let t; return t = e.ajax(o).always(g.event.xhr.always).done(g.event.xhr.done).fail(g.event.xhr.fail), g.verbose("Created server request", t, o), t; } },
                        set: { error() { g.verbose("Adding error state to element", T), T.addClass(x.error); }, loading() { g.verbose("Adding loading state to element", T), T.addClass(x.loading), m = (new Date()).getTime(); } },
                        remove: { error() { g.verbose("Removing error state from element", T), T.removeClass(x.error); }, loading() { g.verbose("Removing loading state from element", T), T.removeClass(x.loading); } },
                        get: { responseFromXHR(t) { return !!e.isPlainObject(t) && (g.is.expectingJSON() ? g.decode.json(t.responseText) : t.responseText); },
                            errorFromRequest(t, n, i) { return e.isPlainObject(t) && void 0 !== t.error ? t.error : void 0 !== v.error[n] ? v.error[n] : i; },
                            request() { return g.request || !1; },
                            xhr() { return g.xhr || !1; },
                            settings() { let t; return t = v.beforeSend.call(R, v), t && (void 0 !== t.success && (g.debug("Legacy success callback detected", t), g.error(y.legacyParameters, t.success), t.onSuccess = t.success), void 0 !== t.failure && (g.debug("Legacy failure callback detected", t), g.error(y.legacyParameters, t.failure), t.onFailure = t.failure), void 0 !== t.complete && (g.debug("Legacy complete callback detected", t), g.error(y.legacyParameters, t.complete), t.onComplete = t.complete)), void 0 === t && g.error(y.noReturnedValue), t === !1 ? t : void 0 !== t ? e.extend(!0, {}, t) : e.extend(!0, {}, v); },
                            urlEncodedValue(e) {
                                let n = t.decodeURIComponent(e),
                                    i = t.encodeURIComponent(e); return n !== e ? (g.debug("URL value is already encoded, avoiding double encoding", e), e) : (g.verbose("Encoding value using encodeURIComponent", e, i), i);
                            },
                            defaultData() { const t = {}; return e.isWindow(A) || (g.is.input() ? t.value = k.val() : g.is.form() || (t.text = k.text())), t; },
                            event() { return e.isWindow(A) || v.on == "now" ? (g.debug("API called without element, no events attached"), !1) : v.on == "auto" ? k.is("input") ? void 0 !== A.oninput ? "input" : void 0 !== A.onpropertychange ? "propertychange" : "keyup" : k.is("form") ? "submit" : "click" : v.on; },
                            templatedURL(e) { if (e = e || k.data(h.action) || v.action || !1, f = k.data(h.url) || v.url || !1) return g.debug("Using specified url", f), f; if (e) { if (g.debug("Looking up url for action", e, v.api), void 0 === v.api[e] && !g.is.mocked()) return void g.error(y.missingAction, v.action, v.api); f = v.api[e]; } else g.is.form() && (f = k.attr("action") || T.attr("action") || !1, g.debug("No url or action specified, defaulting to form action", f)); return f; } },
                        abort() { const e = g.get.xhr(); e && e.state() !== "resolved" && (g.debug("Cancelling API request"), e.abort()); },
                        reset() { g.remove.error(), g.remove.loading(); },
                        setting(t, n) { if (g.debug("Changing setting", t, n), e.isPlainObject(t))e.extend(!0, v, t); else { if (void 0 === n) return v[t]; e.isPlainObject(v[t]) ? e.extend(!0, v[t], n) : v[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, g, t); else { if (void 0 === n) return g[t]; g[t] = n; } },
                        debug() { !v.silent && v.debug && (v.performance ? g.performance.log(arguments) : (g.debug = Function.prototype.bind.call(console.info, console, `${v.name}:`), g.debug.apply(console, arguments))); },
                        verbose() { !v.silent && v.verbose && v.debug && (v.performance ? g.performance.log(arguments) : (g.verbose = Function.prototype.bind.call(console.info, console, `${v.name}:`), g.verbose.apply(console, arguments))); },
                        error() { v.silent || (g.error = Function.prototype.bind.call(console.error, console, `${v.name}:`), g.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; v.performance && (t = (new Date()).getTime(), i = r || t, n = t - i, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", "Execution Time": n })), clearTimeout(g.performance.timer), g.performance.timer = setTimeout(g.performance.display, 500);
                        },
                            display() {
                                let t = `${v.name}:`,
                                    n = 0; r = !1, clearTimeout(g.performance.timer), e.each(s, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, a && (t += ` '${a}'`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, n, o) {
                            let a,
                                r,
                                s,
                                l = P; return n = n || u, o = A || o, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (g.error(y.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(o, n) : void 0 !== r && (s = r), e.isArray(i) ? i.push(s) : void 0 !== i ? i = [i, s] : void 0 !== s && (i = s), r;
                        } }, c ? (void 0 === P && g.initialize(), g.invoke(l)) : (void 0 !== P && P.invoke("destroy"), g.initialize());
            }), void 0 !== i ? i : this;
    }, e.api.settings = { name: "API", namespace: "api", debug: !1, verbose: !1, performance: !0, api: {}, cache: !0, interruptRequests: !0, on: "auto", stateContext: !1, loadingDuration: 0, hideError: "auto", errorDuration: 2e3, encodeParameters: !0, action: !1, url: !1, base: "", urlData: {}, defaultData: !0, serializeForm: !1, throttle: 0, throttleFirstRequest: !0, method: "get", data: {}, dataType: "json", mockResponse: !1, mockResponseAsync: !1, response: !1, responseAsync: !1, beforeSend(e) { return e; }, beforeXHR(e) {}, onRequest(e, t) {}, onResponse: !1, onSuccess(e, t) {}, onComplete(e, t) {}, onFailure(e, t) {}, onError(e, t) {}, onAbort(e, t) {}, successTest: !1, error: { beforeSend: "The before send function has aborted the request", error: "There was an error with your request", exitConditions: "API Request Aborted. Exit conditions met", JSONParse: "JSON could not be parsed during error handling", legacyParameters: "You are using legacy API success callback names", method: "The method you called is not defined", missingAction: "API action used but no url was defined", missingSerialize: "jquery-serialize-object is required to add form data to an existing data object", missingURL: "No URL specified for api event", noReturnedValue: "The beforeSend callback must return a settings object, beforeSend ignored.", noStorage: "Caching responses locally requires session storage", parseError: "There was an error parsing your request", requiredParameter: "Missing a required URL parameter: ", statusMessage: "Server gave an error: ", timeout: "Your request timed out" }, regExp: { required: /\{\$*[A-z0-9]+\}/g, optional: /\{\/\$*[A-z0-9]+\}/g }, className: { loading: "loading", error: "error" }, selector: { disabled: ".disabled", form: "form" }, metadata: { action: "action", url: "url" } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.state = function (t) {
        let i,
            o = e(this),
            a = o.selector || "",
            r = (n.documentElement, (new Date()).getTime()),
            s = [],
            l = arguments[0],
            c = typeof l === "string",
            u = [].slice.call(arguments, 1); return o.each(function () {
                let n,
                    d = e.isPlainObject(t) ? e.extend(!0, {}, e.fn.state.settings, t) : e.extend({}, e.fn.state.settings),
                    f = d.error,
                    m = d.metadata,
                    g = d.className,
                    v = d.namespace,
                    p = d.states,
                    h = d.text,
                    b = `.${v}`,
                    y = `${v}-module`,
                    x = e(this),
                    C = this,
                    w = x.data(y); n = { initialize() {
                        n.verbose("Initializing module"), d.automatic && n.add.defaults(),
d.context && a !== "" ? e(d.context).on(a, `mouseenter${b}`, n.change.text).on(a, `mouseleave${b}`, n.reset.text).on(a, `click${b}`, n.toggle.state) : x.on(`mouseenter${b}`, n.change.text).on(`mouseleave${b}`, n.reset.text).on(`click${b}`, n.toggle.state), n.instantiate();
                    },
                        instantiate() { n.verbose("Storing instance of module", n), w = n, x.data(y, n); },
                        destroy() { n.verbose("Destroying previous module", w), x.off(b).removeData(y); },
                        refresh() { n.verbose("Refreshing selector cache"), x = e(C); },
                        add: { defaults() { const i = t && e.isPlainObject(t.states) ? t.states : {}; e.each(d.defaults, (t, o) => { void 0 !== n.is[t] && n.is[t]() && (n.verbose("Adding default states", t, C), e.extend(d.states, o, i)); }); } },
                        is: { active() { return x.hasClass(g.active); }, loading() { return x.hasClass(g.loading); }, inactive() { return !x.hasClass(g.active); }, state(e) { return void 0 !== g[e] && x.hasClass(g[e]); }, enabled() { return !x.is(d.filter.active); }, disabled() { return x.is(d.filter.active); }, textEnabled() { return !x.is(d.filter.text); }, button() { return x.is(".button:not(a, .submit)"); }, input() { return x.is("input"); }, progress() { return x.is(".ui.progress"); } },
                        allow(e) { n.debug("Now allowing state", e), p[e] = !0; },
                        disallow(e) { n.debug("No longer allowing", e), p[e] = !1; },
                        allows(e) { return p[e] || !1; },
                        enable() { x.removeClass(g.disabled); },
                        disable() { x.addClass(g.disabled); },
                        setState(e) { n.allows(e) && x.addClass(g[e]); },
                        removeState(e) { n.allows(e) && x.removeClass(g[e]); },
                        toggle: { state() { let t; if (n.allows("active") && n.is.enabled()) { if (n.refresh(), void 0 !== e.fn.api) if (t = x.api("get request"), x.api("was cancelled"))n.debug("API Request cancelled by beforesend"), d.activateTest = function () { return !1; }, d.deactivateTest = function () { return !1; }; else if (t) return void n.listenTo(t); n.change.state(); } } },
                        listenTo(t) { n.debug("API request detected, waiting for state signal", t), t && (h.loading && n.update.text(h.loading), e.when(t).then(() => { t.state() == "resolved" ? (n.debug("API request succeeded"), d.activateTest = function () { return !0; }, d.deactivateTest = function () { return !0; }) : (n.debug("API request failed"), d.activateTest = function () { return !1; }, d.deactivateTest = function () { return !1; }), n.change.state(); })); },
                        change: { state() { n.debug("Determining state change direction"), n.is.inactive() ? n.activate() : n.deactivate(), d.sync && n.sync(), d.onChange.call(C); }, text() { n.is.textEnabled() && (n.is.disabled() ? (n.verbose("Changing text to disabled text", h.hover), n.update.text(h.disabled)) : n.is.active() ? h.hover ? (n.verbose("Changing text to hover text", h.hover), n.update.text(h.hover)) : h.deactivate && (n.verbose("Changing text to deactivating text", h.deactivate), n.update.text(h.deactivate)) : h.hover ? (n.verbose("Changing text to hover text", h.hover), n.update.text(h.hover)) : h.activate && (n.verbose("Changing text to activating text", h.activate), n.update.text(h.activate))); } },
                        activate() { d.activateTest.call(C) && (n.debug("Setting state to active"), x.addClass(g.active), n.update.text(h.active), d.onActivate.call(C)); },
                        deactivate() { d.deactivateTest.call(C) && (n.debug("Setting state to inactive"), x.removeClass(g.active), n.update.text(h.inactive), d.onDeactivate.call(C)); },
                        sync() { n.verbose("Syncing other buttons to current state"), n.is.active() ? o.not(x).state("activate") : o.not(x).state("deactivate"); },
                        get: { text() { return d.selector.text ? x.find(d.selector.text).text() : x.html(); }, textFor(e) { return h[e] || !1; } },
                        flash: { text(e, t, i) { const o = n.get.text(); n.debug("Flashing text message", e, t), e = e || d.text.flash, t = t || d.flashDuration, i = i || function () {}, n.update.text(e), setTimeout(() => { n.update.text(o), i.call(C); }, t); } },
                        reset: { text() {
                            let e = h.active || x.data(m.storedText),
                                t = h.inactive || x.data(m.storedText); n.is.textEnabled() && (n.is.active() && e ? (n.verbose("Resetting active text", e), n.update.text(e)) : t && (n.verbose("Resetting inactive text", e), n.update.text(t)));
                        } },
                        update: { text(e) { const t = n.get.text(); e && e !== t ? (n.debug("Updating text", e), d.selector.text ? x.data(m.storedText, e).find(d.selector.text).text(e) : x.data(m.storedText, e).html(e)) : n.debug("Text is already set, ignoring update", e); } },
                        setting(t, i) { if (n.debug("Changing setting", t, i), e.isPlainObject(t))e.extend(!0, d, t); else { if (void 0 === i) return d[t]; e.isPlainObject(d[t]) ? e.extend(!0, d[t], i) : d[t] = i; } },
                        internal(t, i) { if (e.isPlainObject(t))e.extend(!0, n, t); else { if (void 0 === i) return n[t]; n[t] = i; } },
                        debug() { !d.silent && d.debug && (d.performance ? n.performance.log(arguments) : (n.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), n.debug.apply(console, arguments))); },
                        verbose() { !d.silent && d.verbose && d.debug && (d.performance ? n.performance.log(arguments) : (n.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), n.verbose.apply(console, arguments))); },
                        error() { d.silent || (n.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), n.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                i,
                                o; d.performance && (t = (new Date()).getTime(), o = r || t, i = t - o, r = t, s.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: C, "Execution Time": i })), clearTimeout(n.performance.timer), n.performance.timer = setTimeout(n.performance.display, 500);
                        },
                            display() {
                                let t = `${d.name}:`,
                                    i = 0; r = !1, clearTimeout(n.performance.timer), e.each(s, (e, t) => { i += t["Execution Time"]; }), t += ` ${i}ms`, a && (t += ` '${a}'`), (void 0 !== console.group || void 0 !== console.table) && s.length > 0 && (console.groupCollapsed(t), console.table ? console.table(s) : e.each(s, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), s = [];
                            } },
                        invoke(t, o, a) {
                            let r,
                                s,
                                l,
                                c = w; return o = o || u, a = C || a, typeof t === "string" && void 0 !== c && (t = t.split(/[\. ]/), r = t.length - 1, e.each(t, (i, o) => { const a = i != r ? o + t[i + 1].charAt(0).toUpperCase() + t[i + 1].slice(1) : t; if (e.isPlainObject(c[a]) && i != r)c = c[a]; else { if (void 0 !== c[a]) return s = c[a], !1; if (!e.isPlainObject(c[o]) || i == r) return void 0 !== c[o] ? (s = c[o], !1) : (n.error(f.method, t), !1); c = c[o]; } })), e.isFunction(s) ? l = s.apply(a, o) : void 0 !== s && (l = s), e.isArray(i) ? i.push(l) : void 0 !== i ? i = [i, l] : void 0 !== l && (i = l), s;
                        } }, c ? (void 0 === w && n.initialize(), n.invoke(l)) : (void 0 !== w && w.invoke("destroy"), n.initialize());
            }), void 0 !== i ? i : this;
    }, e.fn.state.settings = { name: "State", debug: !1, verbose: !1, namespace: "state", performance: !0, onActivate() {}, onDeactivate() {}, onChange() {}, activateTest() { return !0; }, deactivateTest() { return !0; }, automatic: !0, sync: !1, flashDuration: 1e3, filter: { text: ".loading, .disabled", active: ".disabled" }, context: !1, error: { beforeSend: "The before send function has cancelled state change", method: "The method you called is not defined." }, metadata: { promise: "promise", storedText: "stored-text" }, className: { active: "active", disabled: "disabled", error: "error", loading: "loading", success: "success", warning: "warning" }, selector: { text: !1 }, defaults: { input: { disabled: !0, loading: !0, active: !0 }, button: { disabled: !0, loading: !0, active: !0 }, progress: { active: !0, success: !0, warning: !0, error: !0 } }, states: { active: !0, disabled: !0, error: !0, loading: !0, success: !0, warning: !0 }, text: { disabled: !1, flash: !1, hover: !1, active: !1, inactive: !1, activate: !1, deactivate: !1 } };
}(jQuery, window, document)), (function (e, t, n, i) {
    t = void 0 !== t && t.Math == Math ? t : typeof self !== "undefined" && self.Math == Math ? self : Function("return this")(), e.fn.visibility = function (i) {
        let o,
            a = e(this),
            r = a.selector || "",
            s = (new Date()).getTime(),
            l = [],
            c = arguments[0],
            u = typeof c === "string",
            d = [].slice.call(arguments, 1),
            f = a.length,
            m = 0; return a.each(function () {
                let a,
                    g,
                    v,
                    p,
                    h = e.isPlainObject(i) ? e.extend(!0, {}, e.fn.visibility.settings, i) : e.extend({}, e.fn.visibility.settings),
                    b = h.className,
                    y = h.namespace,
                    x = h.error,
                    C = h.metadata,
                    w = `.${y}`,
                    k = `module-${y}`,
                    S = e(t),
                    T = e(this),
                    A = e(h.context),
                    R = (T.selector, T.data(k)),
                    P = t.requestAnimationFrame || t.mozRequestAnimationFrame || t.webkitRequestAnimationFrame || t.msRequestAnimationFrame || function (e) { setTimeout(e, 0); },
                    E = this,
                    F = !1; p = { initialize() { p.debug("Initializing", h), p.setup.cache(), p.should.trackChanges() && (h.type == "image" && p.setup.image(), h.type == "fixed" && p.setup.fixed(), h.observeChanges && p.observeChanges(), p.bind.events()), p.save.position(), p.is.visible() || p.error(x.visible, T), h.initialCheck && p.checkVisibility(), p.instantiate(); },
                        instantiate() { p.debug("Storing instance", p), T.data(k, p), R = p; },
                        destroy() { p.verbose("Destroying previous module"), v && v.disconnect(), g && g.disconnect(), S.off(`load${w}`, p.event.load).off(`resize${w}`, p.event.resize), A.off(`scroll${w}`, p.event.scroll).off(`scrollchange${w}`, p.event.scrollchange), h.type == "fixed" && (p.resetFixed(), p.remove.placeholder()), T.off(w).removeData(k); },
                        observeChanges() { "MutationObserver" in t && (g = new MutationObserver(p.event.contextChanged), v = new MutationObserver(p.event.changed), g.observe(n, { childList: !0, subtree: !0 }), v.observe(E, { childList: !0, subtree: !0 }), p.debug("Setting up mutation observer", v)); },
                        bind: { events() { p.verbose("Binding visibility events to scroll and resize"), h.refreshOnLoad && S.on(`load${w}`, p.event.load), S.on(`resize${w}`, p.event.resize), A.off(`scroll${w}`).on(`scroll${w}`, p.event.scroll).on(`scrollchange${w}`, p.event.scrollchange); } },
                        event: { changed(e) { p.verbose("DOM tree modified, updating visibility calculations"), p.timer = setTimeout(() => { p.verbose("DOM tree modified, updating sticky menu"), p.refresh(); }, 100); }, contextChanged(t) { [].forEach.call(t, (t) => { t.removedNodes && [].forEach.call(t.removedNodes, (t) => { (t == E || e(t).find(E).length > 0) && (p.debug("Element removed from DOM, tearing down events"), p.destroy()); }); }); }, resize() { p.debug("Window resized"), h.refreshOnResize && P(p.refresh); }, load() { p.debug("Page finished loading"), P(p.refresh); }, scroll() { h.throttle ? (clearTimeout(p.timer), p.timer = setTimeout(() => { A.triggerHandler(`scrollchange${w}`, [A.scrollTop()]); }, h.throttle)) : P(() => { A.triggerHandler(`scrollchange${w}`, [A.scrollTop()]); }); }, scrollchange(e, t) { p.checkVisibility(t); } },
                        precache(t, i) { t instanceof Array || (t = [t]); for (var o = t.length, a = 0, r = [], s = n.createElement("img"), l = function () { ++a >= t.length && e.isFunction(i) && i(); }; o--;)s = n.createElement("img"), s.onload = l, s.onerror = l, s.src = t[o], r.push(s); },
                        enableCallbacks() { p.debug("Allowing callbacks to occur"), F = !1; },
                        disableCallbacks() { p.debug("Disabling all callbacks temporarily"), F = !0; },
                        should: { trackChanges() { return u ? (p.debug("One time query, no need to bind events"), !1) : (p.debug("Callbacks being attached"), !0); } },
                        setup: { cache() { p.cache = { occurred: {}, screen: {}, element: {} }; }, image() { const e = T.data(C.src); e && (p.verbose("Lazy loading image", e), h.once = !0, h.observeChanges = !1, h.onOnScreen = function () { p.debug("Image on screen", E), p.precache(e, () => { p.set.image(e, function () { m++, m == f && h.onAllLoaded.call(this), h.onLoad.call(this); }); }); }); }, fixed() { p.debug("Setting up fixed"), h.once = !1, h.observeChanges = !1, h.initialCheck = !0, h.refreshOnLoad = !0, i.transition || (h.transition = !1), p.create.placeholder(), p.debug("Added placeholder", a), h.onTopPassed = function () { p.debug("Element passed, adding fixed position", T), p.show.placeholder(), p.set.fixed(), h.transition && void 0 !== e.fn.transition && T.transition(h.transition, h.duration); }, h.onTopPassedReverse = function () { p.debug("Element returned to position, removing fixed", T), p.hide.placeholder(), p.remove.fixed(); }; } },
                        create: { placeholder() { p.verbose("Creating fixed position placeholder"), a = T.clone(!1).css("display", "none").addClass(b.placeholder).insertAfter(T); } },
                        show: { placeholder() { p.verbose("Showing placeholder"), a.css("display", "block").css("visibility", "hidden"); } },
                        hide: { placeholder() { p.verbose("Hiding placeholder"), a.css("display", "none").css("visibility", ""); } },
                        set: { fixed() { p.verbose("Setting element to fixed position"), T.addClass(b.fixed).css({ position: "fixed", top: `${h.offset}px`, left: "auto", zIndex: h.zIndex }), h.onFixed.call(E); }, image(t, n) { if (T.attr("src", t), h.transition) if (void 0 !== e.fn.transition) { if (T.hasClass(b.visible)) return void p.debug("Transition already occurred on this image, skipping animation"); T.transition(h.transition, h.duration, n); } else T.fadeIn(h.duration, n); else T.show(); } },
                        is: { onScreen() { return p.get.elementCalculations().onScreen; }, offScreen() { return p.get.elementCalculations().offScreen; }, visible() { return !(!p.cache || !p.cache.element) && !(p.cache.element.width === 0 && p.cache.element.offset.top === 0); } },
                        refresh() { p.debug("Refreshing constants (width/height)"), h.type == "fixed" && p.resetFixed(), p.reset(), p.save.position(), h.checkOnRefresh && p.checkVisibility(), h.onRefresh.call(E); },
                        resetFixed() { p.remove.fixed(), p.remove.occurred(); },
                        reset() { p.verbose("Resetting all cached values"), e.isPlainObject(p.cache) && (p.cache.screen = {}, p.cache.element = {}); },
                        checkVisibility(e) { p.verbose("Checking visibility of element", p.cache.element), !F && p.is.visible() && (p.save.scroll(e), p.save.calculations(), p.passed(), p.passingReverse(), p.topVisibleReverse(), p.bottomVisibleReverse(), p.topPassedReverse(), p.bottomPassedReverse(), p.onScreen(), p.offScreen(), p.passing(), p.topVisible(), p.bottomVisible(), p.topPassed(), p.bottomPassed(), h.onUpdate && h.onUpdate.call(E, p.get.elementCalculations())); },
                        passed(t, n) { const i = p.get.elementCalculations(); if (t && n)h.onPassed[t] = n; else { if (void 0 !== t) return p.get.pixelsPassed(t) > i.pixelsPassed; i.passing && e.each(h.onPassed, (e, t) => { i.bottomVisible || i.pixelsPassed > p.get.pixelsPassed(e) ? p.execute(t, e) : h.once || p.remove.occurred(t); }); } },
                        onScreen(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onOnScreen; if (e && (p.debug("Adding callback for onScreen", e), h.onOnScreen = e), t.onScreen ? p.execute(n, "onScreen") : h.once || p.remove.occurred("onScreen"), void 0 !== e) return t.onOnScreen;
                        },
                        offScreen(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onOffScreen; if (e && (p.debug("Adding callback for offScreen", e), h.onOffScreen = e), t.offScreen ? p.execute(n, "offScreen") : h.once || p.remove.occurred("offScreen"), void 0 !== e) return t.onOffScreen;
                        },
                        passing(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onPassing; if (e && (p.debug("Adding callback for passing", e), h.onPassing = e), t.passing ? p.execute(n, "passing") : h.once || p.remove.occurred("passing"), void 0 !== e) return t.passing;
                        },
                        topVisible(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onTopVisible; if (e && (p.debug("Adding callback for top visible", e), h.onTopVisible = e), t.topVisible ? p.execute(n, "topVisible") : h.once || p.remove.occurred("topVisible"), void 0 === e) return t.topVisible;
                        },
                        bottomVisible(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onBottomVisible; if (e && (p.debug("Adding callback for bottom visible", e), h.onBottomVisible = e), t.bottomVisible ? p.execute(n, "bottomVisible") : h.once || p.remove.occurred("bottomVisible"), void 0 === e) return t.bottomVisible;
                        },
                        topPassed(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onTopPassed; if (e && (p.debug("Adding callback for top passed", e), h.onTopPassed = e), t.topPassed ? p.execute(n, "topPassed") : h.once || p.remove.occurred("topPassed"), void 0 === e) return t.topPassed;
                        },
                        bottomPassed(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onBottomPassed; if (e && (p.debug("Adding callback for bottom passed", e), h.onBottomPassed = e), t.bottomPassed ? p.execute(n, "bottomPassed") : h.once || p.remove.occurred("bottomPassed"), void 0 === e) return t.bottomPassed;
                        },
                        passingReverse(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onPassingReverse; if (e && (p.debug("Adding callback for passing reverse", e), h.onPassingReverse = e), t.passing ? h.once || p.remove.occurred("passingReverse") : p.get.occurred("passing") && p.execute(n, "passingReverse"), void 0 !== e) return !t.passing;
                        },
                        topVisibleReverse(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onTopVisibleReverse; if (e && (p.debug("Adding callback for top visible reverse", e), h.onTopVisibleReverse = e), t.topVisible ? h.once || p.remove.occurred("topVisibleReverse") : p.get.occurred("topVisible") && p.execute(n, "topVisibleReverse"), void 0 === e) return !t.topVisible;
                        },
                        bottomVisibleReverse(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onBottomVisibleReverse; if (e && (p.debug("Adding callback for bottom visible reverse", e), h.onBottomVisibleReverse = e), t.bottomVisible ? h.once || p.remove.occurred("bottomVisibleReverse") : p.get.occurred("bottomVisible") && p.execute(n, "bottomVisibleReverse"), void 0 === e) return !t.bottomVisible;
                        },
                        topPassedReverse(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onTopPassedReverse; if (e && (p.debug("Adding callback for top passed reverse", e), h.onTopPassedReverse = e), t.topPassed ? h.once || p.remove.occurred("topPassedReverse") : p.get.occurred("topPassed") && p.execute(n, "topPassedReverse"), void 0 === e) return !t.onTopPassed;
                        },
                        bottomPassedReverse(e) {
                            let t = p.get.elementCalculations(),
                                n = e || h.onBottomPassedReverse; if (e && (p.debug("Adding callback for bottom passed reverse", e), h.onBottomPassedReverse = e), t.bottomPassed ? h.once || p.remove.occurred("bottomPassedReverse") : p.get.occurred("bottomPassed") && p.execute(n, "bottomPassedReverse"), void 0 === e) return !t.bottomPassed;
                        },
                        execute(e, t) {
                            let n = p.get.elementCalculations(),
                                i = p.get.screenCalculations(); e = e || !1, e && (h.continuous ? (p.debug("Callback being called continuously", t, n), e.call(E, n, i)) : p.get.occurred(t) || (p.debug("Conditions met", t, n), e.call(E, n, i))), p.save.occurred(t);
                        },
                        remove: { fixed() { p.debug("Removing fixed position"), T.removeClass(b.fixed).css({ position: "", top: "", left: "", zIndex: "" }), h.onUnfixed.call(E); }, placeholder() { p.debug("Removing placeholder content"), a && a.remove(); }, occurred(e) { if (e) { const t = p.cache.occurred; void 0 !== t[e] && t[e] === !0 && (p.debug("Callback can now be called again", e), p.cache.occurred[e] = !1); } else p.cache.occurred = {}; } },
                        save: { calculations() { p.verbose("Saving all calculations necessary to determine positioning"), p.save.direction(), p.save.screenCalculations(), p.save.elementCalculations(); },
                            occurred(e) { e && (void 0 !== p.cache.occurred[e] && p.cache.occurred[e] === !0 || (p.verbose("Saving callback occurred", e), p.cache.occurred[e] = !0)); },
                            scroll(e) { e = e + h.offset || A.scrollTop() + h.offset, p.cache.scroll = e; },
                            direction() {
                                let e,
                                    t = p.get.scroll(),
                                    n = p.get.lastScroll(); return e = t > n && n ? "down" : t < n && n ? "up" : "static", p.cache.direction = e, p.cache.direction;
                            },
                            elementPosition() {
                                let e = p.cache.element,
                                    t = p.get.screenSize(); return p.verbose("Saving element position"), e.fits = e.height < t.height, e.offset = T.offset(), e.width = T.outerWidth(), e.height = T.outerHeight(), p.cache.element = e, e;
                            },
                            elementCalculations() {
                                let e = p.get.screenCalculations(),
                                    t = p.get.elementPosition(); return h.includeMargin ? (t.margin = {}, t.margin.top = parseInt(T.css("margin-top"), 10), t.margin.bottom = parseInt(T.css("margin-bottom"), 10), t.top = t.offset.top - t.margin.top, t.bottom = t.offset.top + t.height + t.margin.bottom) : (t.top = t.offset.top, t.bottom = t.offset.top + t.height), t.topVisible = e.bottom >= t.top, t.topPassed = e.top >= t.top, t.bottomVisible = e.bottom >= t.bottom, t.bottomPassed = e.top >= t.bottom, t.pixelsPassed = 0, t.percentagePassed = 0, t.onScreen = t.topVisible && !t.bottomPassed, t.passing = t.topPassed && !t.bottomPassed, t.offScreen = !t.onScreen, t.passing && (t.pixelsPassed = e.top - t.top, t.percentagePassed = (e.top - t.top) / t.height), p.cache.element = t, p.verbose("Updated element calculations", t), t;
                            },
                            screenCalculations() { const e = p.get.scroll(); return p.save.direction(), p.cache.screen.top = e, p.cache.screen.bottom = e + p.cache.screen.height, p.cache.screen; },
                            screenSize() { p.verbose("Saving window position"), p.cache.screen = { height: A.height() }; },
                            position() { p.save.screenSize(), p.save.elementPosition(); } },
                        get: { pixelsPassed(e) { const t = p.get.elementCalculations(); return e.search("%") > -1 ? t.height * (parseInt(e, 10) / 100) : parseInt(e, 10); }, occurred(e) { return void 0 !== p.cache.occurred && (p.cache.occurred[e] || !1); }, direction() { return void 0 === p.cache.direction && p.save.direction(), p.cache.direction; }, elementPosition() { return void 0 === p.cache.element && p.save.elementPosition(), p.cache.element; }, elementCalculations() { return void 0 === p.cache.element && p.save.elementCalculations(), p.cache.element; }, screenCalculations() { return void 0 === p.cache.screen && p.save.screenCalculations(), p.cache.screen; }, screenSize() { return void 0 === p.cache.screen && p.save.screenSize(), p.cache.screen; }, scroll() { return void 0 === p.cache.scroll && p.save.scroll(), p.cache.scroll; }, lastScroll() { return void 0 === p.cache.screen ? (p.debug("First scroll event, no last scroll could be found"), !1) : p.cache.screen.top; } },
                        setting(t, n) { if (e.isPlainObject(t))e.extend(!0, h, t); else { if (void 0 === n) return h[t]; h[t] = n; } },
                        internal(t, n) { if (e.isPlainObject(t))e.extend(!0, p, t); else { if (void 0 === n) return p[t]; p[t] = n; } },
                        debug() { !h.silent && h.debug && (h.performance ? p.performance.log(arguments) : (p.debug = Function.prototype.bind.call(console.info, console, `${h.name}:`), p.debug.apply(console, arguments))); },
                        verbose() { !h.silent && h.verbose && h.debug && (h.performance ? p.performance.log(arguments) : (p.verbose = Function.prototype.bind.call(console.info, console, `${h.name}:`), p.verbose.apply(console, arguments))); },
                        error() { h.silent || (p.error = Function.prototype.bind.call(console.error, console, `${h.name}:`), p.error.apply(console, arguments)); },
                        performance: { log(e) {
                            let t,
                                n,
                                i; h.performance && (t = (new Date()).getTime(), i = s || t, n = t - i, s = t, l.push({ Name: e[0], Arguments: [].slice.call(e, 1) || "", Element: E, "Execution Time": n })), clearTimeout(p.performance.timer), p.performance.timer = setTimeout(p.performance.display, 500);
                        },
                            display() {
                                let t = `${h.name}:`,
                                    n = 0; s = !1, clearTimeout(p.performance.timer), e.each(l, (e, t) => { n += t["Execution Time"]; }), t += ` ${n}ms`, r && (t += ` '${r}'`), (void 0 !== console.group || void 0 !== console.table) && l.length > 0 && (console.groupCollapsed(t), console.table ? console.table(l) : e.each(l, (e, t) => { console.log(`${t.Name}: ${t["Execution Time"]}ms`); }), console.groupEnd()), l = [];
                            } },
                        invoke(t, n, i) {
                            let a,
                                r,
                                s,
                                l = R; return n = n || d, i = E || i, typeof t === "string" && void 0 !== l && (t = t.split(/[\. ]/), a = t.length - 1, e.each(t, (n, i) => { const o = n != a ? i + t[n + 1].charAt(0).toUpperCase() + t[n + 1].slice(1) : t; if (e.isPlainObject(l[o]) && n != a)l = l[o]; else { if (void 0 !== l[o]) return r = l[o], !1; if (!e.isPlainObject(l[i]) || n == a) return void 0 !== l[i] ? (r = l[i], !1) : (p.error(x.method, t), !1); l = l[i]; } })), e.isFunction(r) ? s = r.apply(i, n) : void 0 !== r && (s = r), e.isArray(o) ? o.push(s) : void 0 !== o ? o = [o, s] : void 0 !== s && (o = s), r;
                        } }, u ? (void 0 === R && p.initialize(), R.save.scroll(), R.save.calculations(), p.invoke(c)) : (void 0 !== R && R.invoke("destroy"), p.initialize());
            }), void 0 !== o ? o : this;
    }, e.fn.visibility.settings = { name: "Visibility", namespace: "visibility", debug: !1, verbose: !1, performance: !0, observeChanges: !0, initialCheck: !0, refreshOnLoad: !0, refreshOnResize: !0, checkOnRefresh: !0, once: !0, continuous: !1, offset: 0, includeMargin: !1, context: t, throttle: !1, type: !1, zIndex: "10", transition: "fade in", duration: 1e3, onPassed: {}, onOnScreen: !1, onOffScreen: !1, onPassing: !1, onTopVisible: !1, onBottomVisible: !1, onTopPassed: !1, onBottomPassed: !1, onPassingReverse: !1, onTopVisibleReverse: !1, onBottomVisibleReverse: !1, onTopPassedReverse: !1, onBottomPassedReverse: !1, onLoad() {}, onAllLoaded() {}, onFixed() {}, onUnfixed() {}, onUpdate: !1, onRefresh() {}, metadata: { src: "src" }, className: { fixed: "fixed", placeholder: "placeholder", visible: "visible" }, error: { method: "The method you called is not defined.", visible: "Element is hidden, you must call refresh after element becomes visible" } };
}(jQuery, window, document));
